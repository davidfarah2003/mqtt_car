{"ast":null,"code":"import { renderSlot as _renderSlot, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = {\n  class: \"app-main\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"section\", _hoisted_1, [_renderSlot(_ctx.$slots, \"default\", {\n    connected: _ctx.connected,\n    dataObject: _ctx.dataObject,\n    subscribeToFields: _ctx.subscribeToFields,\n    updateChildData: _ctx.updateChildData,\n    canUpdateChildData: _ctx.canUpdateChildData\n  })]);\n}","map":{"version":3,"mappings":";;EACWA,KAAK,EAAC;AAAU;;uBAAzBC,oBAOU,WAPVC,UAOU,GANRC,YAKEC;IALKC,SAAS,EAAED,cAAS;IACpBE,UAAU,EAAEF,eAAU;IACtBG,iBAAiB,EAAEH,sBAAiB;IACpCI,eAAe,EAAEJ,oBAAe;IAChCK,kBAAkB,EAAEL","names":["class","_createElementBlock","_hoisted_1","_renderSlot","_ctx","connected","dataObject","subscribeToFields","updateChildData","canUpdateChildData"],"sourceRoot":"","sources":["/home/davidf/Desktop/SSB/ssb-interface-v2/src/views/ConnectedView.vue"],"sourcesContent":["<template>\n  <section class=\"app-main\">\n    <slot :connected=\"connected\"\n          :dataObject=\"dataObject\"\n          :subscribeToFields=\"subscribeToFields\"\n          :updateChildData=\"updateChildData\"\n          :canUpdateChildData=\"canUpdateChildData\"\n    />\n  </section>\n</template>\n\n<script>\n\nimport {computed, inject, onActivated, onDeactivated, onMounted, onUnmounted, provide, ref, watch} from \"vue\";\nimport mqttUtils from \"@/composables/mqttUtils.mjs\";\nimport configUtils from \"@/composables/configUtils.mjs\";\n\nexport default {\n  setup: function () {\n    let connected = ref(false); //Boolean value that indicates if the client is connected to the broker\n    let dataObject = ref({})  //Object containing all our actual data, gets updated depending on subscribed topics\n    let dataIsPresent = ref(false)\n    let isActive = ref(false);  //indicate if the Home component is isActive\n    let configUtil = null;\n\n    /**\n     * Callback activated when the component is being rendered\n     */\n    onActivated(()=> {\n      isActive.value = true\n      mqttUtil.resubscribeAll()\n    })\n\n    /**\n     * Callback activated when the component stops being rendered\n     */\n    onDeactivated(()=> {\n      isActive.value = false\n      mqttUtil.unsubscribeAll()\n    })\n\n    /**\n     * Creat an mqttUtils instance with arguments the client and a callback to update data\n     * @type {MqttUtils}\n     */\n    const mqttUtil = new mqttUtils(inject('mqttClient'), (topic, message) => {mqttUtils.updateDataFromJSON(message, dataObject)})\n\n    buildDataObject()\n    addConnectedListeners()\n\n    /**\n     * Use the configuration fetched from the api to build the dataObject\n     */\n    function buildDataObject(){\n      inject('apiClient').getConfig(\"CAN_out_config\").then((outConfig)=> {\n        configUtil = new configUtils(outConfig)\n        dataObject.value = configUtil.getDataObject()\n        dataIsPresent.value = true\n      })\n    }\n\n    /**\n     * Add listeners to update the connected status\n     */\n    function addConnectedListeners(){\n      if(mqttUtil.connected()) connected.value = true\n      mqttUtil.on('connect', () => connected.value = true)\n      mqttUtil.on('disconnect', () => connected.value = false)\n      mqttUtil.on('reconnect', () => connected.value = false)\n    }\n\n    /**\n     * Subscribe to the required topics if not already done\n     * @param requiredValues array of required values containing path Strings: Component/Group\n     */\n    const subscribeToFields = (requiredValues) => {\n      let fieldPathArray = []\n      Object.entries(requiredValues).forEach(([, fieldPath])=>{\n        fieldPathArray = fieldPath.split(\"/\")\n        mqttUtil.subscribeTo([`${fieldPathArray[0]}/${fieldPathArray[1]}`])\n      })\n    }\n\n    /**\n     * Update from the dataObject, the data  of a module based on their required fields\n     * @param requiredFields array of required values containing path Strings: \"Component/Group/Field\"\n     * @param childData The data object of the module. Follows the convention:\n     *    {fieldAlias : groupObject} if the desired field is * (3rd value in the path) (refer to documentation for structure)\n     *    {fieldAlias : [value, unit]} otherwise\n     * Where fieldAlias is the name indicated in the childData and not in the main configuration file\n     */\n    const updateChildData = (requiredFields, childData) => {\n      let fieldPathArray = []\n\n      Object.entries(requiredFields).forEach(([fieldAlias, fieldPath]) => {\n        try {\n          fieldPathArray = fieldPath.split(\"/\")\n          console.log(fieldPath[2] == \"*\")\n          if(fieldPath[2] === \"*\") {childData.value[fieldAlias] =\"wtf\"}\n          else{childData.value[fieldAlias] = dataObject.value[fieldPathArray[0]][fieldPathArray[1]][fieldPathArray[2]]}\n          console.log(childData)\n        }\n        catch (error){\n          if (error instanceof TypeError) {\n            throw new Error(\"The path \" + fieldPath + \" doesn't exist in the configuration\")\n          } else {throw error;}\n        }\n      })\n    }\n\n    /**\n     * Return true if a child module can request an update, false otherwise\n     * We use dataIsPresent instead of the dataObject because it could be partially written (not null but not ready)\n     * @type {ComputedRef<boolean>}\n     */\n    const canUpdateChildData = computed(()=>{return (dataIsPresent.value && isActive.value)})\n\n    return {dataObject, connected, subscribeToFields, updateChildData, canUpdateChildData}\n  }\n}\n\n</script>\n\n<style scoped>\n\n</style>\n"]},"metadata":{},"sourceType":"module"}