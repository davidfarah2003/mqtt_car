{"ast":null,"code":"import _classPrivateFieldInitSpec from \"/home/davidf/Desktop/SSB/ssb-interface-v2/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classStaticPrivateMethodGet from \"/home/davidf/Desktop/SSB/ssb-interface-v2/node_modules/@babel/runtime/helpers/esm/classStaticPrivateMethodGet.js\";\nimport _classPrivateFieldGet from \"/home/davidf/Desktop/SSB/ssb-interface-v2/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport _classPrivateFieldSet from \"/home/davidf/Desktop/SSB/ssb-interface-v2/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nimport mqtt from \"precompiled-mqtt\";\n\n/**\n * Class that contains MQTT related logic\n * Written by: David Farah\n * Email: david.farah@epfl.ch\n */\nvar _mqttClientPromise = /*#__PURE__*/new WeakMap();\nvar _subscribedTopics = /*#__PURE__*/new WeakMap();\nvar _previouslySubscribedTopics = /*#__PURE__*/new WeakMap();\nexport default class MqttUtils {\n  /**\n   * Constructor of the class\n   * @param mqttClientPromise mqttClient promise\n   * @param messageCallback method to call back when an MQTT message is received\n   */\n  constructor(mqttClientPromise, messageCallback) {\n    _classPrivateFieldInitSpec(this, _mqttClientPromise, {\n      writable: true,\n      value: null\n    });\n    _classPrivateFieldInitSpec(this, _subscribedTopics, {\n      writable: true,\n      value: new Set()\n    });\n    _classPrivateFieldInitSpec(this, _previouslySubscribedTopics, {\n      writable: true,\n      value: new Set()\n    });\n    if (!mqttClientPromise) throw new Error(\"No mqttClientPromise was provided\");else _classPrivateFieldSet(this, _mqttClientPromise, mqttClientPromise);\n    this.on(\"message\", messageCallback);\n  }\n\n  /**\n   * Method that adds a listener to certain event\n   * @param eventName Name of the event as mentioned in the mqtt docs\n   * @param callbackFunction Function to callback on event\n   */\n  on(eventName, callbackFunction) {\n    _classPrivateFieldGet(this, _mqttClientPromise).then(client => {\n      client.on(eventName, callbackFunction);\n    });\n  }\n\n  /**\n   * Returns true if the client is connected, false otherwise\n   * @returns {boolean}\n   */\n  connected() {\n    return _classPrivateFieldGet(this, _mqttClientPromise).then(client => {\n      client.connected;\n    });\n  }\n\n  /**\n   * Unsubscribe from all the topics in #subscribedTopics\n   */\n  unsubscribeAll() {\n    _classPrivateFieldSet(this, _previouslySubscribedTopics, new Set(_classPrivateFieldGet(this, _subscribedTopics)));\n    this.unsubscribeFrom(Array.from(_classPrivateFieldGet(this, _subscribedTopics)));\n  }\n\n  /**\n   * Subscribe to all the topics in #previouslySubscribedTopics\n   */\n  resubscribeAll() {\n    this.subscribeTo(Array.from(_classPrivateFieldGet(this, _previouslySubscribedTopics)));\n  }\n\n  /**\n   * Subscribe to topics\n   * @param topics Array of topics to subscribe to (not ref)\n   */\n  subscribeTo(topics) {\n    //if(topics.length) { console.log(\"subscribed to \" + topics)}\n    topics.forEach(topic => _classPrivateFieldGet(this, _subscribedTopics).add(topic));\n    _classPrivateFieldGet(this, _mqttClientPromise).then(client => {\n      client.subscribe(topics);\n    });\n  }\n\n  /**\n   * Subscribe from topics\n   * @param topics Array of topics to subscribe from (not ref)\n   */\n  unsubscribeFrom(topics) {\n    //if(topics.length) console.log(\"unsubscribed from \" + topics)\n    topics.forEach(topic => _classPrivateFieldGet(this, _subscribedTopics).delete(topic));\n    _classPrivateFieldGet(this, _mqttClientPromise).then(client => {\n      client.unsubscribe(topics);\n    });\n  }\n\n  /**\n   * Send a message over mqtt on the given topic\n   * @param topic\n   * @param message\n   */\n  send(topic, message) {\n    _classPrivateFieldGet(this, _mqttClientPromise).then(client => {\n      client.publish(topic, message);\n    });\n  }\n\n  /**\n   * Send a predefined command to the boat CAN\n   * @param {String} commandName predetermined name\n   * @param {[Number]} data array containing the fields values\n   */\n  sendCommand(commandName, data) {\n    this.send(\"dahu/execute_command\", {\n      commandName,\n      data\n    });\n  }\n\n  //---------------------------------------------STATIC METHODS-----------------------------------------------\n  /**\n   * Asynchronous method that returns a promise, from which we can obtain the mqtt client if resolved.\n   * We use the MQTT.js library to communicate with broker through websockets (Not TCP - that's why I used precompiled-mqtt)\n   * @returns client\n   */\n  static async getMqttClient() {\n    const clientId = \"ssb_\";\n    //const host = 'ws://34.65.125.98:9001'\n    const host = 'ws://localhost:9001';\n    const options = {\n      keepalive: 60,\n      clientId: clientId + Math.random().toString(16).substring(2, 10),\n      username: 'ssb',\n      password: 'ssbgs',\n      protocolId: 'MQTT',\n      protocolVersion: 4,\n      clean: true,\n      reconnectPeriod: 1000,\n      connectTimeout: 30 * 1000,\n      will: {\n        topic: 'WillMsg',\n        payload: 'Connection Closed abnormally..!',\n        qos: 0,\n        retain: false\n      }\n    };\n    const client = await _classStaticPrivateMethodGet(this, MqttUtils, _getClient).call(this, host, options);\n    client.on('error', err => {\n      console.log('Connection error: ', err);\n    });\n    client.on('reconnect', () => {\n      console.log('Reconnecting...');\n    });\n    client.on('connect', () => {\n      console.log(`Connected to broker: ${host}`);\n    });\n    client.on('offline', function () {\n      console.log('Client Offline');\n    });\n    return client;\n  }\n\n  /**\n   * Return Client as a promise (for using async and await) so that the code waits for a response\n   * @param host broker ip address and port\n   * @param options options applied to client\n   * @returns {Promise<mqtt.MqttClient | String>}\n   */\n\n  /**\n   * Method that extracts data from receivedData using the structure convention, then updates the values in dataObject\n   * @param receivedData raw json received from mqtt broker\n   * @param dataObject javascript json-like object reference to update (ref)\n   * @param dataIsPresent Boolean specifying if the dataObject is fetched from the api\n   */\n  static updateDataFromJSON(receivedData, dataObject, dataIsPresent) {\n    if (dataIsPresent) {\n      const parsed = JSON.parse(receivedData);\n      let component_name = \"\";\n      let message_name = \"\";\n      let field_name = \"\";\n      try {\n        component_name = parsed[\"component_name\"];\n        message_name = parsed[\"group_name\"];\n        parsed[\"fields\"].forEach(sensor => {\n          field_name = sensor[\"field_name\"];\n          if (sensor[\"field_name\"] === undefined) {\n            throw new Error(\"Received JSON is not well formatted\");\n          }\n          dataObject.value[component_name][message_name][field_name][0] = sensor[\"value\"];\n        });\n      } catch (err) {\n        console.log(err);\n      }\n    }\n  }\n}\nfunction _getClient(host, options) {\n  return new Promise((resolve, reject) => {\n    const client = mqtt.connect(host, options);\n    if (client) {\n      resolve(client);\n    } else reject(\"Client connection couldn't be established \");\n  });\n}","map":{"version":3,"names":["mqtt","MqttUtils","constructor","mqttClientPromise","messageCallback","Set","Error","on","eventName","callbackFunction","then","client","connected","unsubscribeAll","unsubscribeFrom","Array","from","resubscribeAll","subscribeTo","topics","forEach","topic","add","subscribe","delete","unsubscribe","send","message","publish","sendCommand","commandName","data","getMqttClient","clientId","host","options","keepalive","Math","random","toString","substring","username","password","protocolId","protocolVersion","clean","reconnectPeriod","connectTimeout","will","payload","qos","retain","err","console","log","updateDataFromJSON","receivedData","dataObject","dataIsPresent","parsed","JSON","parse","component_name","message_name","field_name","sensor","undefined","value","Promise","resolve","reject","connect"],"sources":["/home/davidf/Desktop/SSB/ssb-interface-v2/src/composables/mqttUtils.mjs"],"sourcesContent":["import mqtt from \"precompiled-mqtt\";\n\n/**\n * Class that contains MQTT related logic\n * Written by: David Farah\n * Email: david.farah@epfl.ch\n */\nexport default class MqttUtils {\n    #mqttClientPromise = null\n    #subscribedTopics = new Set()\n    #previouslySubscribedTopics = new Set()\n\n    /**\n     * Constructor of the class\n     * @param mqttClientPromise mqttClient promise\n     * @param messageCallback method to call back when an MQTT message is received\n     */\n    constructor(mqttClientPromise, messageCallback) {\n        if (!mqttClientPromise) throw new Error(\"No mqttClientPromise was provided\")\n        else this.#mqttClientPromise = mqttClientPromise\n\n        this.on(\"message\", messageCallback)\n    }\n\n    /**\n     * Method that adds a listener to certain event\n     * @param eventName Name of the event as mentioned in the mqtt docs\n     * @param callbackFunction Function to callback on event\n     */\n    on(eventName, callbackFunction) {\n        this.#mqttClientPromise.then((client) => {\n            client.on(eventName, callbackFunction)\n        })\n    }\n\n    /**\n     * Returns true if the client is connected, false otherwise\n     * @returns {boolean}\n     */\n    connected() {\n        return this.#mqttClientPromise.then((client) => {client.connected})\n    }\n\n    /**\n     * Unsubscribe from all the topics in #subscribedTopics\n     */\n    unsubscribeAll() {\n        this.#previouslySubscribedTopics = new Set(this.#subscribedTopics)\n        this.unsubscribeFrom(Array.from(this.#subscribedTopics))\n    }\n\n    /**\n     * Subscribe to all the topics in #previouslySubscribedTopics\n     */\n    resubscribeAll() {\n        this.subscribeTo(Array.from(this.#previouslySubscribedTopics))\n    }\n\n    /**\n     * Subscribe to topics\n     * @param topics Array of topics to subscribe to (not ref)\n     */\n    subscribeTo(topics){\n        //if(topics.length) { console.log(\"subscribed to \" + topics)}\n        topics.forEach(topic => this.#subscribedTopics.add(topic))\n        this.#mqttClientPromise.then((client) => {client.subscribe(topics)})\n    }\n\n    /**\n     * Subscribe from topics\n     * @param topics Array of topics to subscribe from (not ref)\n     */\n    unsubscribeFrom(topics){\n        //if(topics.length) console.log(\"unsubscribed from \" + topics)\n        topics.forEach(topic => this.#subscribedTopics.delete(topic))\n        this.#mqttClientPromise.then((client) => { client.unsubscribe(topics) })\n    }\n\n    /**\n     * Send a message over mqtt on the given topic\n     * @param topic\n     * @param message\n     */\n    send(topic, message) {\n        this.#mqttClientPromise.then((client) => {\n            client.publish(topic, message)\n        })\n    }\n\n    /**\n     * Send a predefined command to the boat CAN\n     * @param {String} commandName predetermined name\n     * @param {[Number]} data array containing the fields values\n     */\n    sendCommand(commandName, data) {\n        this.send(\"dahu/execute_command\", {commandName, data})\n    }\n\n\n//---------------------------------------------STATIC METHODS-----------------------------------------------\n    /**\n     * Asynchronous method that returns a promise, from which we can obtain the mqtt client if resolved.\n     * We use the MQTT.js library to communicate with broker through websockets (Not TCP - that's why I used precompiled-mqtt)\n     * @returns client\n     */\n    static async getMqttClient(){\n        const clientId = \"ssb_\"\n        //const host = 'ws://34.65.125.98:9001'\n        const host = 'ws://localhost:9001'\n\n        const options = {\n            keepalive: 60,\n            clientId: clientId + Math.random().toString(16).substring(2, 10),\n            username: 'ssb',\n            password: 'ssbgs',\n            protocolId: 'MQTT',\n            protocolVersion: 4,\n            clean: true,\n            reconnectPeriod: 1000,\n            connectTimeout: 30 * 1000,\n            will: {\n                topic: 'WillMsg',\n                payload: 'Connection Closed abnormally..!',\n                qos: 0,\n                retain: false\n            },\n        }\n\n        const client = await this.#getClient(host, options)\n\n        client.on('error', (err) => {\n            console.log('Connection error: ', err)\n        })\n        client.on('reconnect', () => {\n            console.log('Reconnecting...')\n        })\n        client.on('connect', () => {\n            console.log(`Connected to broker: ${host}`)\n        })\n\n        client.on('offline', function () {\n            console.log('Client Offline')\n        })\n\n        return client;\n    }\n\n\n    /**\n     * Return Client as a promise (for using async and await) so that the code waits for a response\n     * @param host broker ip address and port\n     * @param options options applied to client\n     * @returns {Promise<mqtt.MqttClient | String>}\n     */\n    static #getClient(host, options){\n        return new Promise((resolve, reject) => {\n            const client = mqtt.connect(host, options)\n\n            if(client){resolve(client)}\n            else reject(\"Client connection couldn't be established \")\n        })\n    }\n\n\n    /**\n     * Method that extracts data from receivedData using the structure convention, then updates the values in dataObject\n     * @param receivedData raw json received from mqtt broker\n     * @param dataObject javascript json-like object reference to update (ref)\n     * @param dataIsPresent Boolean specifying if the dataObject is fetched from the api\n     */\n    static updateDataFromJSON(receivedData, dataObject, dataIsPresent) {\n        if (dataIsPresent) {\n            const parsed = JSON.parse(receivedData)\n            let component_name = \"\"\n            let message_name = \"\"\n            let field_name = \"\"\n\n            try {\n                component_name = parsed[\"component_name\"]\n                message_name = parsed[\"group_name\"]\n\n                parsed[\"fields\"].forEach((sensor) => {\n                    field_name = sensor[\"field_name\"]\n\n                    if(sensor[\"field_name\"] === undefined) {throw new Error(\"Received JSON is not well formatted\")}\n                    dataObject.value[component_name][message_name][field_name][0] = sensor[\"value\"]\n                })\n            }\n            catch (err) {\n                console.log(err)\n            }\n        }\n    }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}