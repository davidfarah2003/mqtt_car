{"ast":null,"code":"import { computed, inject, onActivated, onDeactivated, onMounted, onUnmounted, provide, ref, watch } from \"vue\";\nimport mqttUtils from \"@/composables/mqttUtils.mjs\";\nimport configUtils from \"@/composables/configUtils.mjs\";\nexport default {\n  props: [],\n  setup: function (props) {\n    let connected = ref(false); //Boolean value that indicates if the client is connected to the broker\n    let dataObject = ref({}); //Object containing all our actual data, gets updated depending on subscribed topics\n    let subscribedTopics = ref([]); //Array containing the subscribed topics for this component\n    let dataIsPresent = ref(false);\n    let isActive = ref(false); //indicate if the Home component is isActive\n    let configUtil = null;\n\n    /**\n     * Callback activated when the component is being rendered\n     */\n    onActivated(() => {\n      console.log(\"activated\");\n      isActive.value = true;\n      mqttUtil.subscribeTo(subscribedTopics);\n    });\n\n    /**\n     * Callback activated when the component stops being rendered\n     */\n    onDeactivated(() => {\n      console.log(\"deactivated\");\n      isActive.value = false;\n      mqttUtil.resetClient();\n    });\n\n    /**\n     * Creat an mqttUtils instance with arguments the client and a callback to update data\n     * @type {MqttUtils}\n     */\n    const mqttUtil = new mqttUtils(inject('mqttClient'), (topic, message) => {\n      mqttUtils.updateDataFromJSON(message, dataObject);\n    });\n    buildDataObject();\n    addConnectedListeners();\n\n    /**\n     * Use the configuration fetched from the api to build the dataObject\n     */\n    function buildDataObject() {\n      inject('apiClient').getConfig(\"CAN_out_config\").then(outConfig => {\n        configUtil = new configUtils(outConfig);\n        dataObject.value = configUtil.getDataObject();\n        dataIsPresent.value = true;\n      });\n    }\n\n    /**\n     * Add listeners to update the connected status\n     */\n    function addConnectedListeners() {\n      if (mqttUtil.connected()) connected.value = true;\n      mqttUtil.on('connect', () => connected.value = true);\n      mqttUtil.on('disconnect', () => connected.value = false);\n      mqttUtil.on('reconnect', () => connected.value = false);\n    }\n\n    /**\n     * Callback activated when the subscribedTopics list is modified\n     * Subscribe to the new topics (there are no duplicates in mqttUtil)\n     */\n    watch(subscribedTopics.value, () => {\n      mqttUtil.subscribeTo(subscribedTopics.value);\n    });\n\n    /**\n     * Subscribe to the required topics if not already done\n     * @param requiredValues array of required values containing path Strings: Component/Group\n     */\n    const subscribeFromFields = requiredValues => {\n      let fieldPathArray = [];\n      Object.entries(requiredValues).forEach(_ref => {\n        let [, fieldPath] = _ref;\n        fieldPathArray = fieldPath.split(\"/\");\n        mqttUtil.subscribeTo([`${fieldPathArray[0]}/${fieldPathArray[1]}`]);\n      });\n    };\n\n    /**\n     * Update the data of a module based on their required values\n     * @param requiredValues array of required values containing path Strings\n     * @param childData The data object of the module. follows the same convention\n     */\n    const updateChildData = (requiredValues, childData) => {\n      let fieldPathArray = [];\n      let data = {};\n      Object.entries(requiredValues).forEach(_ref2 => {\n        let [fieldName, fieldPath] = _ref2;\n        try {\n          fieldPathArray = fieldPath.split(\"/\");\n          data[fieldName] = dataObject.value[fieldPathArray[0]][fieldPathArray[1]][fieldPathArray[2]];\n        } catch (error) {\n          if (error instanceof TypeError) {\n            throw new Error(\"The path \" + fieldPath + \" doesn't exist in the configuration\");\n          } else {\n            throw error;\n          }\n        }\n      });\n      childData.value = data;\n    };\n\n    /**\n     * Return true if a child module can request an update, false otherwise\n     * We use dataIsPresent instead of the dataObject because it could be partially written (not null but not ready)\n     * @type {ComputedRef<boolean>}\n     */\n    const canUpdateChildData = computed(() => {\n      return dataIsPresent.value && isActive.value;\n    });\n    return {\n      dataObject,\n      connected,\n      subscribeFromFields,\n      updateChildData,\n      canUpdateChildData,\n      subscribedTopics\n    };\n  }\n};","map":{"version":3,"mappings":"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","names":["computed","inject","onActivated","onDeactivated","onMounted","onUnmounted","provide","ref","watch","mqttUtils","configUtils","props","setup","connected","dataObject","subscribedTopics","dataIsPresent","isActive","configUtil","console","log","value","mqttUtil","subscribeTo","resetClient","topic","message","updateDataFromJSON","buildDataObject","addConnectedListeners","getConfig","then","outConfig","getDataObject","on","subscribeFromFields","requiredValues","fieldPathArray","Object","entries","forEach","fieldPath","split","updateChildData","childData","data","fieldName","error","TypeError","Error","canUpdateChildData"],"sourceRoot":"","sources":["/home/davidf/Desktop/SSB/ssb-interface-v2/src/views/ConnectedView.vue"],"sourcesContent":["<template>\n  <section class=\"app-main\">\n    <slot :connected=\"connected\"\n          :dataObject=\"dataObject\"\n          :subscribedTopics=\"subscribedTopics\"\n          :subscribeFromFields=\"subscribeFromFields\"\n          :updateChildData=\"updateChildData\"\n          :canUpdateChildData=\"canUpdateChildData\"\n    />\n  </section>\n</template>\n\n<script>\n\nimport {computed, inject, onActivated, onDeactivated, onMounted, onUnmounted, provide, ref, watch} from \"vue\";\nimport mqttUtils from \"@/composables/mqttUtils.mjs\";\nimport configUtils from \"@/composables/configUtils.mjs\";\n\nexport default {\n  props: [],\n\n  setup: function (props) {\n    let connected = ref(false); //Boolean value that indicates if the client is connected to the broker\n    let dataObject = ref({})  //Object containing all our actual data, gets updated depending on subscribed topics\n    let subscribedTopics = ref([]); //Array containing the subscribed topics for this component\n    let dataIsPresent = ref(false)\n    let isActive = ref(false);  //indicate if the Home component is isActive\n    let configUtil = null;\n\n    /**\n     * Callback activated when the component is being rendered\n     */\n    onActivated(()=> {\n      console.log(\"activated\")\n      isActive.value = true\n      mqttUtil.subscribeTo(subscribedTopics)\n    })\n\n    /**\n     * Callback activated when the component stops being rendered\n     */\n    onDeactivated(()=> {\n      console.log(\"deactivated\")\n      isActive.value = false\n      mqttUtil.resetClient()\n    })\n\n    /**\n     * Creat an mqttUtils instance with arguments the client and a callback to update data\n     * @type {MqttUtils}\n     */\n    const mqttUtil = new mqttUtils(inject('mqttClient'), (topic, message) => {mqttUtils.updateDataFromJSON(message, dataObject)})\n\n    buildDataObject()\n    addConnectedListeners()\n\n    /**\n     * Use the configuration fetched from the api to build the dataObject\n     */\n    function buildDataObject(){\n      inject('apiClient').getConfig(\"CAN_out_config\").then((outConfig)=> {\n        configUtil = new configUtils(outConfig)\n        dataObject.value = configUtil.getDataObject()\n        dataIsPresent.value = true\n      })\n    }\n\n    /**\n     * Add listeners to update the connected status\n     */\n    function addConnectedListeners(){\n      if(mqttUtil.connected()) connected.value = true\n      mqttUtil.on('connect', () => connected.value = true)\n      mqttUtil.on('disconnect', () => connected.value = false)\n      mqttUtil.on('reconnect', () => connected.value = false)\n    }\n\n    /**\n     * Callback activated when the subscribedTopics list is modified\n     * Subscribe to the new topics (there are no duplicates in mqttUtil)\n     */\n    watch(subscribedTopics.value, ()=>{\n      mqttUtil.subscribeTo(subscribedTopics.value)\n    })\n\n    /**\n     * Subscribe to the required topics if not already done\n     * @param requiredValues array of required values containing path Strings: Component/Group\n     */\n    const subscribeFromFields = (requiredValues) => {\n      let fieldPathArray = []\n      Object.entries(requiredValues).forEach(([, fieldPath])=>{\n        fieldPathArray = fieldPath.split(\"/\")\n        mqttUtil.subscribeTo([`${fieldPathArray[0]}/${fieldPathArray[1]}`])\n      })\n    }\n\n    /**\n     * Update the data of a module based on their required values\n     * @param requiredValues array of required values containing path Strings\n     * @param childData The data object of the module. follows the same convention\n     */\n    const updateChildData = (requiredValues, childData) => {\n      let fieldPathArray = []\n      let data = {}\n\n      Object.entries(requiredValues).forEach(([fieldName, fieldPath]) => {\n        try {\n          fieldPathArray = fieldPath.split(\"/\")\n          data[fieldName] = dataObject.value[fieldPathArray[0]][fieldPathArray[1]][fieldPathArray[2]]\n        }\n        catch (error){\n          if (error instanceof TypeError) {\n            throw new Error(\"The path \" + fieldPath + \" doesn't exist in the configuration\")\n          } else {throw error;}\n        }\n      })\n      childData.value = data\n    }\n\n    /**\n     * Return true if a child module can request an update, false otherwise\n     * We use dataIsPresent instead of the dataObject because it could be partially written (not null but not ready)\n     * @type {ComputedRef<boolean>}\n     */\n    const canUpdateChildData = computed(()=>{return (dataIsPresent.value && isActive.value)})\n\n\n    return {dataObject, connected, subscribeFromFields, updateChildData, canUpdateChildData, subscribedTopics}\n  }\n}\n\n</script>\n\n<style scoped>\n\n</style>\n"]},"metadata":{},"sourceType":"module"}