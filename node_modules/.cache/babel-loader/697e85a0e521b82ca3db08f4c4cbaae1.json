{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.unshift.js\";\n/*!\n  * vue-router v4.0.3\n  * (c) 2021 Eduardo San Martin Morote\n  * @license MIT\n  */\nimport { getCurrentInstance, inject, onUnmounted, onDeactivated, onActivated, computed, unref, defineComponent, reactive, h, provide, ref, watch, shallowRef, nextTick } from 'vue';\nconst hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\nconst PolySymbol = name =>\n// vr = vue router\nhasSymbol ? Symbol(process.env.NODE_ENV !== 'production' ? '[vue-router]: ' + name : name) : (process.env.NODE_ENV !== 'production' ? '[vue-router]: ' : '_vr_') + name;\n// rvlm = Router View Location Matched\n/**\r\n * RouteRecord being rendered by the closest ancestor Router View. Used for\r\n * `onBeforeRouteUpdate` and `onBeforeRouteLeave`. rvlm stands for Router View\r\n * Location Matched\r\n *\r\n * @internal\r\n */\nconst matchedRouteKey = /*#__PURE__*/PolySymbol(process.env.NODE_ENV !== 'production' ? 'router view location matched' : 'rvlm');\n/**\r\n * Allows overriding the router view depth to control which component in\r\n * `matched` is rendered. rvd stands for Router View Depth\r\n *\r\n * @internal\r\n */\nconst viewDepthKey = /*#__PURE__*/PolySymbol(process.env.NODE_ENV !== 'production' ? 'router view depth' : 'rvd');\n/**\r\n * Allows overriding the router instance returned by `useRouter` in tests. r\r\n * stands for router\r\n *\r\n * @internal\r\n */\nconst routerKey = /*#__PURE__*/PolySymbol(process.env.NODE_ENV !== 'production' ? 'router' : 'r');\n/**\r\n * Allows overriding the current route returned by `useRoute` in tests. rl\r\n * stands for route location\r\n *\r\n * @internal\r\n */\nconst routeLocationKey = /*#__PURE__*/PolySymbol(process.env.NODE_ENV !== 'production' ? 'route location' : 'rl');\n/**\r\n * Allows overriding the current route used by router-view. Internally this is\r\n * used when the `route` prop is passed.\r\n *\r\n * @internal\r\n */\nconst routerViewLocationKey = /*#__PURE__*/PolySymbol(process.env.NODE_ENV !== 'production' ? 'router view location' : 'rvl');\nconst isBrowser = typeof window !== 'undefined';\nfunction isESModule(obj) {\n  return obj.__esModule || hasSymbol && obj[Symbol.toStringTag] === 'Module';\n}\nconst assign = Object.assign;\nfunction applyToParams(fn, params) {\n  const newParams = {};\n  for (const key in params) {\n    const value = params[key];\n    newParams[key] = Array.isArray(value) ? value.map(fn) : fn(value);\n  }\n  return newParams;\n}\nlet noop = () => {};\nfunction warn(msg) {\n  // avoid using ...args as it breaks in older Edge builds\n  const args = Array.from(arguments).slice(1);\n  console.warn.apply(console, ['[Vue Router warn]: ' + msg].concat(args));\n}\nconst TRAILING_SLASH_RE = /\\/$/;\nconst removeTrailingSlash = path => path.replace(TRAILING_SLASH_RE, '');\n/**\r\n * Transforms an URI into a normalized history location\r\n *\r\n * @param parseQuery\r\n * @param location - URI to normalize\r\n * @param currentLocation - current absolute location. Allows resolving relative\r\n * paths. Must start with `/`. Defaults to `/`\r\n * @returns a normalized history location\r\n */\nfunction parseURL(parseQuery, location) {\n  let currentLocation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '/';\n  let path,\n    query = {},\n    searchString = '',\n    hash = '';\n  // Could use URL and URLSearchParams but IE 11 doesn't support it\n  const searchPos = location.indexOf('?');\n  const hashPos = location.indexOf('#', searchPos > -1 ? searchPos : 0);\n  if (searchPos > -1) {\n    path = location.slice(0, searchPos);\n    searchString = location.slice(searchPos + 1, hashPos > -1 ? hashPos : location.length);\n    query = parseQuery(searchString);\n  }\n  if (hashPos > -1) {\n    path = path || location.slice(0, hashPos);\n    // keep the # character\n    hash = location.slice(hashPos, location.length);\n  }\n  // no search and no query\n  path = resolveRelativePath(path != null ? path : location, currentLocation);\n  // empty path means a relative query or hash `?foo=f`, `#thing`\n  return {\n    fullPath: path + (searchString && '?') + searchString + hash,\n    path,\n    query,\n    hash\n  };\n}\n/**\r\n * Stringifies a URL object\r\n *\r\n * @param stringifyQuery\r\n * @param location\r\n */\nfunction stringifyURL(stringifyQuery, location) {\n  let query = location.query ? stringifyQuery(location.query) : '';\n  return location.path + (query && '?') + query + (location.hash || '');\n}\n/**\r\n * Strips off the base from the beginning of a location.pathname in a non\r\n * case-sensitive way.\r\n *\r\n * @param pathname - location.pathname\r\n * @param base - base to strip off\r\n */\nfunction stripBase(pathname, base) {\n  // no base or base is not found at the beginning\n  if (!base || pathname.toLowerCase().indexOf(base.toLowerCase())) return pathname;\n  return pathname.slice(base.length) || '/';\n}\n/**\r\n * Checks if two RouteLocation are equal. This means that both locations are\r\n * pointing towards the same {@link RouteRecord} and that all `params`, `query`\r\n * parameters and `hash` are the same\r\n *\r\n * @param a - first {@link RouteLocation}\r\n * @param b - second {@link RouteLocation}\r\n */\nfunction isSameRouteLocation(stringifyQuery, a, b) {\n  let aLastIndex = a.matched.length - 1;\n  let bLastIndex = b.matched.length - 1;\n  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery(a.query) === stringifyQuery(b.query) && a.hash === b.hash;\n}\n/**\r\n * Check if two `RouteRecords` are equal. Takes into account aliases: they are\r\n * considered equal to the `RouteRecord` they are aliasing.\r\n *\r\n * @param a - first {@link RouteRecord}\r\n * @param b - second {@link RouteRecord}\r\n */\nfunction isSameRouteRecord(a, b) {\n  // since the original record has an undefined value for aliasOf\n  // but all aliases point to the original record, this will always compare\n  // the original record\n  return (a.aliasOf || a) === (b.aliasOf || b);\n}\nfunction isSameRouteLocationParams(a, b) {\n  if (Object.keys(a).length !== Object.keys(b).length) return false;\n  for (let key in a) {\n    if (!isSameRouteLocationParamsValue(a[key], b[key])) return false;\n  }\n  return true;\n}\nfunction isSameRouteLocationParamsValue(a, b) {\n  return Array.isArray(a) ? isEquivalentArray(a, b) : Array.isArray(b) ? isEquivalentArray(b, a) : a === b;\n}\n/**\r\n * Check if two arrays are the same or if an array with one single entry is the\r\n * same as another primitive value. Used to check query and parameters\r\n *\r\n * @param a - array of values\r\n * @param b - array of values or a single value\r\n */\nfunction isEquivalentArray(a, b) {\n  return Array.isArray(b) ? a.length === b.length && a.every((value, i) => value === b[i]) : a.length === 1 && a[0] === b;\n}\n/**\r\n * Resolves a relative path that starts with `.`.\r\n *\r\n * @param to - path location we are resolving\r\n * @param from - currentLocation.path, should start with `/`\r\n */\nfunction resolveRelativePath(to, from) {\n  if (to.startsWith('/')) return to;\n  if (process.env.NODE_ENV !== 'production' && !from.startsWith('/')) {\n    warn(`Cannot resolve a relative location without an absolute path. Trying to resolve \"${to}\" from \"${from}\". It should look like \"/${from}\".`);\n    return to;\n  }\n  if (!to) return from;\n  const fromSegments = from.split('/');\n  const toSegments = to.split('/');\n  let position = fromSegments.length - 1;\n  let toPosition;\n  let segment;\n  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {\n    segment = toSegments[toPosition];\n    // can't go below zero\n    if (position === 1 || segment === '.') continue;\n    if (segment === '..') position--;\n    // found something that is not relative path\n    else break;\n  }\n  return fromSegments.slice(0, position).join('/') + '/' + toSegments.slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join('/');\n}\nvar NavigationType;\n(function (NavigationType) {\n  NavigationType[\"pop\"] = \"pop\";\n  NavigationType[\"push\"] = \"push\";\n})(NavigationType || (NavigationType = {}));\nvar NavigationDirection;\n(function (NavigationDirection) {\n  NavigationDirection[\"back\"] = \"back\";\n  NavigationDirection[\"forward\"] = \"forward\";\n  NavigationDirection[\"unknown\"] = \"\";\n})(NavigationDirection || (NavigationDirection = {}));\n/**\r\n * Starting location for Histories\r\n */\nconst START = '';\n// Generic utils\n/**\r\n * Normalizes a base by removing any trailing slash and reading the base tag if\r\n * present.\r\n *\r\n * @param base - base to normalize\r\n */\nfunction normalizeBase(base) {\n  if (!base) {\n    if (isBrowser) {\n      // respect <base> tag\n      const baseEl = document.querySelector('base');\n      base = baseEl && baseEl.getAttribute('href') || '/';\n      // strip full URL origin\n      base = base.replace(/^\\w+:\\/\\/[^\\/]+/, '');\n    } else {\n      base = '/';\n    }\n  }\n  // ensure leading slash when it was removed by the regex above avoid leading\n  // slash with hash because the file could be read from the disk like file://\n  // and the leading slash would cause problems\n  if (base[0] !== '/' && base[0] !== '#') base = '/' + base;\n  // remove the trailing slash so all other method can just do `base + fullPath`\n  // to build an href\n  return removeTrailingSlash(base);\n}\n// remove any character before the hash\nconst BEFORE_HASH_RE = /^[^#]+#/;\nfunction createHref(base, location) {\n  return base.replace(BEFORE_HASH_RE, '#') + location;\n}\nfunction getElementPosition(el, offset) {\n  const docRect = document.documentElement.getBoundingClientRect();\n  const elRect = el.getBoundingClientRect();\n  return {\n    behavior: offset.behavior,\n    left: elRect.left - docRect.left - (offset.left || 0),\n    top: elRect.top - docRect.top - (offset.top || 0)\n  };\n}\nconst computeScrollPosition = () => ({\n  left: window.pageXOffset,\n  top: window.pageYOffset\n});\nfunction scrollToPosition(position) {\n  let scrollToOptions;\n  if ('el' in position) {\n    let positionEl = position.el;\n    const isIdSelector = typeof positionEl === 'string' && positionEl.startsWith('#');\n    /**\r\n     * `id`s can accept pretty much any characters, including CSS combinators\r\n     * like `>` or `~`. It's still possible to retrieve elements using\r\n     * `document.getElementById('~')` but it needs to be escaped when using\r\n     * `document.querySelector('#\\\\~')` for it to be valid. The only\r\n     * requirements for `id`s are them to be unique on the page and to not be\r\n     * empty (`id=\"\"`). Because of that, when passing an id selector, it should\r\n     * be properly escaped for it to work with `querySelector`. We could check\r\n     * for the id selector to be simple (no CSS combinators `+ >~`) but that\r\n     * would make things inconsistent since they are valid characters for an\r\n     * `id` but would need to be escaped when using `querySelector`, breaking\r\n     * their usage and ending up in no selector returned. Selectors need to be\r\n     * escaped:\r\n     *\r\n     * - `#1-thing` becomes `#\\31 -thing`\r\n     * - `#with~symbols` becomes `#with\\\\~symbols`\r\n     *\r\n     * - More information about  the topic can be found at\r\n     *   https://mathiasbynens.be/notes/html5-id-class.\r\n     * - Practical example: https://mathiasbynens.be/demo/html5-id\r\n     */\n    if (process.env.NODE_ENV !== 'production' && typeof position.el === 'string') {\n      if (!isIdSelector || !document.getElementById(position.el.slice(1))) {\n        try {\n          let foundEl = document.querySelector(position.el);\n          if (isIdSelector && foundEl) {\n            warn(`The selector \"${position.el}\" should be passed as \"el: document.querySelector('${position.el}')\" because it starts with \"#\".`);\n            // return to avoid other warnings\n            return;\n          }\n        } catch (err) {\n          warn(`The selector \"${position.el}\" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);\n          // return to avoid other warnings\n          return;\n        }\n      }\n    }\n    const el = typeof positionEl === 'string' ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;\n    if (!el) {\n      process.env.NODE_ENV !== 'production' && warn(`Couldn't find element using selector \"${position.el}\" returned by scrollBehavior.`);\n      return;\n    }\n    scrollToOptions = getElementPosition(el, position);\n  } else {\n    scrollToOptions = position;\n  }\n  if ('scrollBehavior' in document.documentElement.style) window.scrollTo(scrollToOptions);else {\n    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);\n  }\n}\nfunction getScrollKey(path, delta) {\n  const position = history.state ? history.state.position - delta : -1;\n  return position + path;\n}\nconst scrollPositions = new Map();\nfunction saveScrollPosition(key, scrollPosition) {\n  scrollPositions.set(key, scrollPosition);\n}\nfunction getSavedScrollPosition(key) {\n  const scroll = scrollPositions.get(key);\n  // consume it so it's not used again\n  scrollPositions.delete(key);\n  return scroll;\n}\n// TODO: RFC about how to save scroll position\n/**\r\n * ScrollBehavior instance used by the router to compute and restore the scroll\r\n * position when navigating.\r\n */\n// export interface ScrollHandler<ScrollPositionEntry extends HistoryStateValue, ScrollPosition extends ScrollPositionEntry> {\n//   // returns a scroll position that can be saved in history\n//   compute(): ScrollPositionEntry\n//   // can take an extended ScrollPositionEntry\n//   scroll(position: ScrollPosition): void\n// }\n// export const scrollHandler: ScrollHandler<ScrollPosition> = {\n//   compute: computeScroll,\n//   scroll: scrollToPosition,\n// }\n\nlet createBaseLocation = () => location.protocol + '//' + location.host;\n/**\r\n * Creates a normalized history location from a window.location object\r\n * @param location -\r\n */\nfunction createCurrentLocation(base, location) {\n  const {\n    pathname,\n    search,\n    hash\n  } = location;\n  // allows hash based url\n  const hashPos = base.indexOf('#');\n  if (hashPos > -1) {\n    // prepend the starting slash to hash so the url starts with /#\n    let pathFromHash = hash.slice(1);\n    if (pathFromHash[0] !== '/') pathFromHash = '/' + pathFromHash;\n    return stripBase(pathFromHash, '');\n  }\n  const path = stripBase(pathname, base);\n  return path + search + hash;\n}\nfunction useHistoryListeners(base, historyState, currentLocation, replace) {\n  let listeners = [];\n  let teardowns = [];\n  // TODO: should it be a stack? a Dict. Check if the popstate listener\n  // can trigger twice\n  let pauseState = null;\n  const popStateHandler = _ref => {\n    let {\n      state\n    } = _ref;\n    const to = createCurrentLocation(base, location);\n    const from = currentLocation.value;\n    const fromState = historyState.value;\n    let delta = 0;\n    if (state) {\n      currentLocation.value = to;\n      historyState.value = state;\n      // ignore the popstate and reset the pauseState\n      if (pauseState && pauseState === from) {\n        pauseState = null;\n        return;\n      }\n      delta = fromState ? state.position - fromState.position : 0;\n    } else {\n      replace(to);\n    }\n    // console.log({ deltaFromCurrent })\n    // Here we could also revert the navigation by calling history.go(-delta)\n    // this listener will have to be adapted to not trigger again and to wait for the url\n    // to be updated before triggering the listeners. Some kind of validation function would also\n    // need to be passed to the listeners so the navigation can be accepted\n    // call all listeners\n    listeners.forEach(listener => {\n      listener(currentLocation.value, from, {\n        delta,\n        type: NavigationType.pop,\n        direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown\n      });\n    });\n  };\n  function pauseListeners() {\n    pauseState = currentLocation.value;\n  }\n  function listen(callback) {\n    // setup the listener and prepare teardown callbacks\n    listeners.push(callback);\n    const teardown = () => {\n      const index = listeners.indexOf(callback);\n      if (index > -1) listeners.splice(index, 1);\n    };\n    teardowns.push(teardown);\n    return teardown;\n  }\n  function beforeUnloadListener() {\n    const {\n      history\n    } = window;\n    if (!history.state) return;\n    history.replaceState(assign({}, history.state, {\n      scroll: computeScrollPosition()\n    }), '');\n  }\n  function destroy() {\n    for (const teardown of teardowns) teardown();\n    teardowns = [];\n    window.removeEventListener('popstate', popStateHandler);\n    window.removeEventListener('beforeunload', beforeUnloadListener);\n  }\n  // setup the listeners and prepare teardown callbacks\n  window.addEventListener('popstate', popStateHandler);\n  window.addEventListener('beforeunload', beforeUnloadListener);\n  return {\n    pauseListeners,\n    listen,\n    destroy\n  };\n}\n/**\r\n * Creates a state object\r\n */\nfunction buildState(back, current, forward) {\n  let replaced = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let computeScroll = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  return {\n    back,\n    current,\n    forward,\n    replaced,\n    position: window.history.length,\n    scroll: computeScroll ? computeScrollPosition() : null\n  };\n}\nfunction useHistoryStateNavigation(base) {\n  const {\n    history,\n    location\n  } = window;\n  // private variables\n  let currentLocation = {\n    value: createCurrentLocation(base, location)\n  };\n  let historyState = {\n    value: history.state\n  };\n  // build current history entry as this is a fresh navigation\n  if (!historyState.value) {\n    changeLocation(currentLocation.value, {\n      back: null,\n      current: currentLocation.value,\n      forward: null,\n      // the length is off by one, we need to decrease it\n      position: history.length - 1,\n      replaced: true,\n      // don't add a scroll as the user may have an anchor and we want\n      // scrollBehavior to be triggered without a saved position\n      scroll: null\n    }, true);\n  }\n  function changeLocation(to, state, replace) {\n    /**\r\n     * if a base tag is provided and we are on a normal domain, we have to\r\n     * respect the provided `base` attribute because pushState() will use it and\r\n     * potentially erase anything before the `#` like at\r\n     * https://github.com/vuejs/vue-router-next/issues/685 where a base of\r\n     * `/folder/#` but a base of `/` would erase the `/folder/` section. If\r\n     * there is no host, the `<base>` tag makes no sense and if there isn't a\r\n     * base tag we can just use everything after the `#`.\r\n     */\n    const hashIndex = base.indexOf('#');\n    const url = hashIndex > -1 ? (location.host && document.querySelector('base') ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;\n    try {\n      // BROWSER QUIRK\n      // NOTE: Safari throws a SecurityError when calling this function 100 times in 30 seconds\n      history[replace ? 'replaceState' : 'pushState'](state, '', url);\n      historyState.value = state;\n    } catch (err) {\n      if (process.env.NODE_ENV !== 'production') {\n        warn('Error with push/replace State', err);\n      } else {\n        console.error(err);\n      }\n      // Force the navigation, this also resets the call count\n      location[replace ? 'replace' : 'assign'](url);\n    }\n  }\n  function replace(to, data) {\n    const state = assign({}, history.state, buildState(historyState.value.back,\n    // keep back and forward entries but override current position\n    to, historyState.value.forward, true), data, {\n      position: historyState.value.position\n    });\n    changeLocation(to, state, true);\n    currentLocation.value = to;\n  }\n  function push(to, data) {\n    // Add to current entry the information of where we are going\n    // as well as saving the current position\n    const currentState = assign({},\n    // use current history state to gracefully handle a wrong call to\n    // history.replaceState\n    // https://github.com/vuejs/vue-router-next/issues/366\n    historyState.value, history.state, {\n      forward: to,\n      scroll: computeScrollPosition()\n    });\n    if (process.env.NODE_ENV !== 'production' && !history.state) {\n      warn(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:\\n\\n` + `history.replaceState(history.state, '', url)\\n\\n` + `You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`);\n    }\n    changeLocation(currentState.current, currentState, true);\n    const state = assign({}, buildState(currentLocation.value, to, null), {\n      position: currentState.position + 1\n    }, data);\n    changeLocation(to, state, false);\n    currentLocation.value = to;\n  }\n  return {\n    location: currentLocation,\n    state: historyState,\n    push,\n    replace\n  };\n}\n/**\r\n * Creates an HTML5 history. Most common history for single page applications.\r\n *\r\n * @param base -\r\n */\nfunction createWebHistory(base) {\n  base = normalizeBase(base);\n  const historyNavigation = useHistoryStateNavigation(base);\n  const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);\n  function go(delta) {\n    let triggerListeners = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (!triggerListeners) historyListeners.pauseListeners();\n    history.go(delta);\n  }\n  const routerHistory = assign({\n    // it's overridden right after\n    location: '',\n    base,\n    go,\n    createHref: createHref.bind(null, base)\n  }, historyNavigation, historyListeners);\n  Object.defineProperty(routerHistory, 'location', {\n    get: () => historyNavigation.location.value\n  });\n  Object.defineProperty(routerHistory, 'state', {\n    get: () => historyNavigation.state.value\n  });\n  return routerHistory;\n}\n\n/**\r\n * Creates a in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere.\r\n * It's up to the user to replace that location with the starter location by either calling `router.push` or `router.replace`.\r\n *\r\n * @param base - Base applied to all urls, defaults to '/'\r\n * @returns a history object that can be passed to the router constructor\r\n */\nfunction createMemoryHistory() {\n  let base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  let listeners = [];\n  let queue = [START];\n  let position = 0;\n  function setLocation(location) {\n    position++;\n    if (position === queue.length) {\n      // we are at the end, we can simply append a new entry\n      queue.push(location);\n    } else {\n      // we are in the middle, we remove everything from here in the queue\n      queue.splice(position);\n      queue.push(location);\n    }\n  }\n  function triggerListeners(to, from, _ref2) {\n    let {\n      direction,\n      delta\n    } = _ref2;\n    const info = {\n      direction,\n      delta,\n      type: NavigationType.pop\n    };\n    for (let callback of listeners) {\n      callback(to, from, info);\n    }\n  }\n  const routerHistory = {\n    // rewritten by Object.defineProperty\n    location: START,\n    state: {},\n    base,\n    createHref: createHref.bind(null, base),\n    replace(to) {\n      // remove current entry and decrement position\n      queue.splice(position--, 1);\n      setLocation(to);\n    },\n    push(to, data) {\n      setLocation(to);\n    },\n    listen(callback) {\n      listeners.push(callback);\n      return () => {\n        const index = listeners.indexOf(callback);\n        if (index > -1) listeners.splice(index, 1);\n      };\n    },\n    destroy() {\n      listeners = [];\n    },\n    go(delta) {\n      let shouldTrigger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      const from = this.location;\n      const direction =\n      // we are considering delta === 0 going forward, but in abstract mode\n      // using 0 for the delta doesn't make sense like it does in html5 where\n      // it reloads the page\n      delta < 0 ? NavigationDirection.back : NavigationDirection.forward;\n      position = Math.max(0, Math.min(position + delta, queue.length - 1));\n      if (shouldTrigger) {\n        triggerListeners(this.location, from, {\n          direction,\n          delta\n        });\n      }\n    }\n  };\n  Object.defineProperty(routerHistory, 'location', {\n    get: () => queue[position]\n  });\n  return routerHistory;\n}\n\n/**\r\n * Creates a hash history. Useful for web applications with no host (e.g.\r\n * `file://`) or when configuring a server to handle any URL is not possible.\r\n *\r\n * @param base - optional base to provide. Defaults to `location.pathname +\r\n * location.search` If there is a `<base>` tag in the `head`, its value will be\r\n * ignored in favor of this parameter **but note it affects all the\r\n * history.pushState() calls**, meaning that if you use a `<base>` tag, it's\r\n * `href` value **has to match this parameter** (ignoring anything after the\r\n * `#`).\r\n *\r\n * @example\r\n * ```js\r\n * // at https://example.com/folder\r\n * createWebHashHistory() // gives a url of `https://example.com/folder#`\r\n * createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`\r\n * // if the `#` is provided in the base, it won't be added by `createWebHashHistory`\r\n * createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`\r\n * // you should avoid doing this because it changes the original url and breaks copying urls\r\n * createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`\r\n *\r\n * // at file:///usr/etc/folder/index.html\r\n * // for locations with no `host`, the base is ignored\r\n * createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`\r\n * ```\r\n */\nfunction createWebHashHistory(base) {\n  // Make sure this implementation is fine in terms of encoding, specially for IE11\n  // for `file://`, directly use the pathname and ignore the base\n  // location.pathname contains an initial `/` even at the root: `https://example.com`\n  base = location.host ? base || location.pathname + location.search : '';\n  // allow the user to provide a `#` in the middle: `/base/#/app`\n  if (base.indexOf('#') < 0) base += '#';\n  if (process.env.NODE_ENV !== 'production' && !base.endsWith('#/') && !base.endsWith('#')) {\n    warn(`A hash base must end with a \"#\":\\n\"${base}\" should be \"${base.replace(/#.*$/, '#')}\".`);\n  }\n  return createWebHistory(base);\n}\nfunction isRouteLocation(route) {\n  return typeof route === 'string' || route && typeof route === 'object';\n}\nfunction isRouteName(name) {\n  return typeof name === 'string' || typeof name === 'symbol';\n}\n\n/**\r\n * Initial route location where the router is. Can be used in navigation guards\r\n * to differentiate the initial navigation.\r\n *\r\n * @example\r\n * ```js\r\n * import { START_LOCATION } from 'vue-router'\r\n *\r\n * router.beforeEach((to, from) => {\r\n *   if (from === START_LOCATION) {\r\n *     // initial navigation\r\n *   }\r\n * })\r\n * ```\r\n */\nconst START_LOCATION_NORMALIZED = {\n  path: '/',\n  name: undefined,\n  params: {},\n  query: {},\n  hash: '',\n  fullPath: '/',\n  matched: [],\n  meta: {},\n  redirectedFrom: undefined\n};\nconst NavigationFailureSymbol = /*#__PURE__*/PolySymbol(process.env.NODE_ENV !== 'production' ? 'navigation failure' : 'nf');\n/**\r\n * Enumeration with all possible types for navigation failures. Can be passed to\r\n * {@link isNavigationFailure} to check for specific failures.\r\n */\nvar NavigationFailureType;\n(function (NavigationFailureType) {\n  /**\r\n   * An aborted navigation is a navigation that failed because a navigation\r\n   * guard returned `false` or called `next(false)`\r\n   */\n  NavigationFailureType[NavigationFailureType[\"aborted\"] = 4] = \"aborted\";\n  /**\r\n   * A cancelled navigation is a navigation that failed because a more recent\r\n   * navigation finished started (not necessarily finished).\r\n   */\n  NavigationFailureType[NavigationFailureType[\"cancelled\"] = 8] = \"cancelled\";\n  /**\r\n   * A duplicated navigation is a navigation that failed because it was\r\n   * initiated while already being at the exact same location.\r\n   */\n  NavigationFailureType[NavigationFailureType[\"duplicated\"] = 16] = \"duplicated\";\n})(NavigationFailureType || (NavigationFailureType = {}));\n// DEV only debug messages\nconst ErrorTypeMessages = {\n  [1 /* MATCHER_NOT_FOUND */](_ref3) {\n    let {\n      location,\n      currentLocation\n    } = _ref3;\n    return `No match for\\n ${JSON.stringify(location)}${currentLocation ? '\\nwhile being at\\n' + JSON.stringify(currentLocation) : ''}`;\n  },\n  [2 /* NAVIGATION_GUARD_REDIRECT */](_ref4) {\n    let {\n      from,\n      to\n    } = _ref4;\n    return `Redirected from \"${from.fullPath}\" to \"${stringifyRoute(to)}\" via a navigation guard.`;\n  },\n  [4 /* NAVIGATION_ABORTED */](_ref5) {\n    let {\n      from,\n      to\n    } = _ref5;\n    return `Navigation aborted from \"${from.fullPath}\" to \"${to.fullPath}\" via a navigation guard.`;\n  },\n  [8 /* NAVIGATION_CANCELLED */](_ref6) {\n    let {\n      from,\n      to\n    } = _ref6;\n    return `Navigation cancelled from \"${from.fullPath}\" to \"${to.fullPath}\" with a new navigation.`;\n  },\n  [16 /* NAVIGATION_DUPLICATED */](_ref7) {\n    let {\n      from,\n      to\n    } = _ref7;\n    return `Avoided redundant navigation to current location: \"${from.fullPath}\".`;\n  }\n};\nfunction createRouterError(type, params) {\n  if (process.env.NODE_ENV !== 'production' || !true) {\n    return assign(new Error(ErrorTypeMessages[type](params)), {\n      type,\n      [NavigationFailureSymbol]: true\n    }, params);\n  } else {\n    return assign(new Error(), {\n      type,\n      [NavigationFailureSymbol]: true\n    }, params);\n  }\n}\nfunction isNavigationFailure(error, type) {\n  return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));\n}\nconst propertiesToLog = ['params', 'query', 'hash'];\nfunction stringifyRoute(to) {\n  if (typeof to === 'string') return to;\n  if ('path' in to) return to.path;\n  const location = {};\n  for (const key of propertiesToLog) {\n    if (key in to) location[key] = to[key];\n  }\n  return JSON.stringify(location, null, 2);\n}\n\n// default pattern for a param: non greedy everything but /\nconst BASE_PARAM_PATTERN = '[^/]+?';\nconst BASE_PATH_PARSER_OPTIONS = {\n  sensitive: false,\n  strict: false,\n  start: true,\n  end: true\n};\n// Special Regex characters that must be escaped in static tokens\nconst REGEX_CHARS_RE = /[.+*?^${}()[\\]/\\\\]/g;\n/**\r\n * Creates a path parser from an array of Segments (a segment is an array of Tokens)\r\n *\r\n * @param segments - array of segments returned by tokenizePath\r\n * @param extraOptions - optional options for the regexp\r\n * @returns a PathParser\r\n */\nfunction tokensToParser(segments, extraOptions) {\n  const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);\n  // the amount of scores is the same as the length of segments except for the root segment \"/\"\n  let score = [];\n  // the regexp as a string\n  let pattern = options.start ? '^' : '';\n  // extracted keys\n  const keys = [];\n  for (const segment of segments) {\n    // the root segment needs special treatment\n    const segmentScores = segment.length ? [] : [90 /* Root */];\n    // allow trailing slash\n    if (options.strict && !segment.length) pattern += '/';\n    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {\n      const token = segment[tokenIndex];\n      // resets the score if we are inside a sub segment /:a-other-:b\n      let subSegmentScore = 40 /* Segment */ + (options.sensitive ? 0.25 /* BonusCaseSensitive */ : 0);\n      if (token.type === 0 /* Static */) {\n        // prepend the slash if we are starting a new segment\n        if (!tokenIndex) pattern += '/';\n        pattern += token.value.replace(REGEX_CHARS_RE, '\\\\$&');\n        subSegmentScore += 40 /* Static */;\n      } else if (token.type === 1 /* Param */) {\n        const {\n          value,\n          repeatable,\n          optional,\n          regexp\n        } = token;\n        keys.push({\n          name: value,\n          repeatable,\n          optional\n        });\n        const re = regexp ? regexp : BASE_PARAM_PATTERN;\n        // the user provided a custom regexp /:id(\\\\d+)\n        if (re !== BASE_PARAM_PATTERN) {\n          subSegmentScore += 10 /* BonusCustomRegExp */;\n          // make sure the regexp is valid before using it\n          try {\n            new RegExp(`(${re})`);\n          } catch (err) {\n            throw new Error(`Invalid custom RegExp for param \"${value}\" (${re}): ` + err.message);\n          }\n        }\n        // when we repeat we must take care of the repeating leading slash\n        let subPattern = repeatable ? `((?:${re})(?:/(?:${re}))*)` : `(${re})`;\n        // prepend the slash if we are starting a new segment\n        if (!tokenIndex) subPattern = optional ? `(?:/${subPattern})` : '/' + subPattern;\n        if (optional) subPattern += '?';\n        pattern += subPattern;\n        subSegmentScore += 20 /* Dynamic */;\n        if (optional) subSegmentScore += -8 /* BonusOptional */;\n        if (repeatable) subSegmentScore += -20 /* BonusRepeatable */;\n        if (re === '.*') subSegmentScore += -50 /* BonusWildcard */;\n      }\n\n      segmentScores.push(subSegmentScore);\n    }\n    // an empty array like /home/ -> [[{home}], []]\n    // if (!segment.length) pattern += '/'\n    score.push(segmentScores);\n  }\n  // only apply the strict bonus to the last score\n  if (options.strict && options.end) {\n    const i = score.length - 1;\n    score[i][score[i].length - 1] += 0.7000000000000001 /* BonusStrict */;\n  }\n  // TODO: dev only warn double trailing slash\n  if (!options.strict) pattern += '/?';\n  if (options.end) pattern += '$';\n  // allow paths like /dynamic to only match dynamic or dynamic/... but not dynamic_something_else\n  else if (options.strict) pattern += '(?:/|$)';\n  const re = new RegExp(pattern, options.sensitive ? '' : 'i');\n  function parse(path) {\n    const match = path.match(re);\n    const params = {};\n    if (!match) return null;\n    for (let i = 1; i < match.length; i++) {\n      const value = match[i] || '';\n      const key = keys[i - 1];\n      params[key.name] = value && key.repeatable ? value.split('/') : value;\n    }\n    return params;\n  }\n  function stringify(params) {\n    let path = '';\n    // for optional parameters to allow to be empty\n    let avoidDuplicatedSlash = false;\n    for (const segment of segments) {\n      if (!avoidDuplicatedSlash || !path.endsWith('/')) path += '/';\n      avoidDuplicatedSlash = false;\n      for (const token of segment) {\n        if (token.type === 0 /* Static */) {\n          path += token.value;\n        } else if (token.type === 1 /* Param */) {\n          const {\n            value,\n            repeatable,\n            optional\n          } = token;\n          const param = value in params ? params[value] : '';\n          if (Array.isArray(param) && !repeatable) throw new Error(`Provided param \"${value}\" is an array but it is not repeatable (* or + modifiers)`);\n          const text = Array.isArray(param) ? param.join('/') : param;\n          if (!text) {\n            if (optional) {\n              // remove the last slash as we could be at the end\n              if (path.endsWith('/')) path = path.slice(0, -1);\n              // do not append a slash on the next iteration\n              else avoidDuplicatedSlash = true;\n            } else throw new Error(`Missing required param \"${value}\"`);\n          }\n          path += text;\n        }\n      }\n    }\n    return path;\n  }\n  return {\n    re,\n    score,\n    keys,\n    parse,\n    stringify\n  };\n}\n/**\r\n * Compares an array of numbers as used in PathParser.score and returns a\r\n * number. This function can be used to `sort` an array\r\n * @param a - first array of numbers\r\n * @param b - second array of numbers\r\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\r\n * should be sorted first\r\n */\nfunction compareScoreArray(a, b) {\n  let i = 0;\n  while (i < a.length && i < b.length) {\n    const diff = b[i] - a[i];\n    // only keep going if diff === 0\n    if (diff) return diff;\n    i++;\n  }\n  // if the last subsegment was Static, the shorter segments should be sorted first\n  // otherwise sort the longest segment first\n  if (a.length < b.length) {\n    return a.length === 1 && a[0] === 40 /* Static */ + 40 /* Segment */ ? -1 : 1;\n  } else if (a.length > b.length) {\n    return b.length === 1 && b[0] === 40 /* Static */ + 40 /* Segment */ ? 1 : -1;\n  }\n  return 0;\n}\n/**\r\n * Compare function that can be used with `sort` to sort an array of PathParser\r\n * @param a - first PathParser\r\n * @param b - second PathParser\r\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\r\n */\nfunction comparePathParserScore(a, b) {\n  let i = 0;\n  const aScore = a.score;\n  const bScore = b.score;\n  while (i < aScore.length && i < bScore.length) {\n    const comp = compareScoreArray(aScore[i], bScore[i]);\n    // do not return if both are equal\n    if (comp) return comp;\n    i++;\n  }\n  // if a and b share the same score entries but b has more, sort b first\n  return bScore.length - aScore.length;\n  // this is the ternary version\n  // return aScore.length < bScore.length\n  //   ? 1\n  //   : aScore.length > bScore.length\n  //   ? -1\n  //   : 0\n}\n\nconst ROOT_TOKEN = {\n  type: 0 /* Static */,\n  value: ''\n};\nconst VALID_PARAM_RE = /[a-zA-Z0-9_]/;\n// After some profiling, the cache seems to be unnecessary because tokenizePath\n// (the slowest part of adding a route) is very fast\n// const tokenCache = new Map<string, Token[][]>()\nfunction tokenizePath(path) {\n  if (!path) return [[]];\n  if (path === '/') return [[ROOT_TOKEN]];\n  if (!path.startsWith('/')) {\n    throw new Error(process.env.NODE_ENV !== 'production' ? `Route paths should start with a \"/\": \"${path}\" should be \"/${path}\".` : `Invalid path \"${path}\"`);\n  }\n  // if (tokenCache.has(path)) return tokenCache.get(path)!\n  function crash(message) {\n    throw new Error(`ERR (${state})/\"${buffer}\": ${message}`);\n  }\n  let state = 0 /* Static */;\n  let previousState = state;\n  const tokens = [];\n  // the segment will always be valid because we get into the initial state\n  // with the leading /\n  let segment;\n  function finalizeSegment() {\n    if (segment) tokens.push(segment);\n    segment = [];\n  }\n  // index on the path\n  let i = 0;\n  // char at index\n  let char;\n  // buffer of the value read\n  let buffer = '';\n  // custom regexp for a param\n  let customRe = '';\n  function consumeBuffer() {\n    if (!buffer) return;\n    if (state === 0 /* Static */) {\n      segment.push({\n        type: 0 /* Static */,\n        value: buffer\n      });\n    } else if (state === 1 /* Param */ || state === 2 /* ParamRegExp */ || state === 3 /* ParamRegExpEnd */) {\n      if (segment.length > 1 && (char === '*' || char === '+')) crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);\n      segment.push({\n        type: 1 /* Param */,\n        value: buffer,\n        regexp: customRe,\n        repeatable: char === '*' || char === '+',\n        optional: char === '*' || char === '?'\n      });\n    } else {\n      crash('Invalid state to consume buffer');\n    }\n    buffer = '';\n  }\n  function addCharToBuffer() {\n    buffer += char;\n  }\n  while (i < path.length) {\n    char = path[i++];\n    if (char === '\\\\' && state !== 2 /* ParamRegExp */) {\n      previousState = state;\n      state = 4 /* EscapeNext */;\n      continue;\n    }\n    switch (state) {\n      case 0 /* Static */:\n        if (char === '/') {\n          if (buffer) {\n            consumeBuffer();\n          }\n          finalizeSegment();\n        } else if (char === ':') {\n          consumeBuffer();\n          state = 1 /* Param */;\n        } else {\n          addCharToBuffer();\n        }\n        break;\n      case 4 /* EscapeNext */:\n        addCharToBuffer();\n        state = previousState;\n        break;\n      case 1 /* Param */:\n        if (char === '(') {\n          state = 2 /* ParamRegExp */;\n        } else if (VALID_PARAM_RE.test(char)) {\n          addCharToBuffer();\n        } else {\n          consumeBuffer();\n          state = 0 /* Static */;\n          // go back one character if we were not modifying\n          if (char !== '*' && char !== '?' && char !== '+') i--;\n        }\n        break;\n      case 2 /* ParamRegExp */:\n        // TODO: is it worth handling nested regexp? like :p(?:prefix_([^/]+)_suffix)\n        // it already works by escaping the closing )\n        // https://paths.esm.dev/?p=AAMeJbiAwQEcDKbAoAAkP60PG2R6QAvgNaA6AFACM2ABuQBB#\n        // is this really something people need since you can also write\n        // /prefix_:p()_suffix\n        if (char === ')') {\n          // handle the escaped )\n          if (customRe[customRe.length - 1] == '\\\\') customRe = customRe.slice(0, -1) + char;else state = 3 /* ParamRegExpEnd */;\n        } else {\n          customRe += char;\n        }\n        break;\n      case 3 /* ParamRegExpEnd */:\n        // same as finalizing a param\n        consumeBuffer();\n        state = 0 /* Static */;\n        // go back one character if we were not modifying\n        if (char !== '*' && char !== '?' && char !== '+') i--;\n        customRe = '';\n        break;\n      default:\n        crash('Unknown state');\n        break;\n    }\n  }\n  if (state === 2 /* ParamRegExp */) crash(`Unfinished custom RegExp for param \"${buffer}\"`);\n  consumeBuffer();\n  finalizeSegment();\n  // tokenCache.set(path, tokens)\n  return tokens;\n}\nfunction createRouteRecordMatcher(record, parent, options) {\n  const parser = tokensToParser(tokenizePath(record.path), options);\n  // warn against params with the same name\n  if (process.env.NODE_ENV !== 'production') {\n    const existingKeys = new Set();\n    for (const key of parser.keys) {\n      if (existingKeys.has(key.name)) warn(`Found duplicated params with name \"${key.name}\" for path \"${record.path}\". Only the last one will be available on \"$route.params\".`);\n      existingKeys.add(key.name);\n    }\n  }\n  const matcher = assign(parser, {\n    record,\n    parent,\n    // these needs to be populated by the parent\n    children: [],\n    alias: []\n  });\n  if (parent) {\n    // both are aliases or both are not aliases\n    // we don't want to mix them because the order is used when\n    // passing originalRecord in Matcher.addRoute\n    if (!matcher.record.aliasOf === !parent.record.aliasOf) parent.children.push(matcher);\n  }\n  return matcher;\n}\n\n/**\r\n * Creates a Router Matcher.\r\n *\r\n * @internal\r\n * @param routes - array of initial routes\r\n * @param globalOptions - global route options\r\n */\nfunction createRouterMatcher(routes, globalOptions) {\n  // normalized ordered array of matchers\n  const matchers = [];\n  const matcherMap = new Map();\n  globalOptions = mergeOptions({\n    strict: false,\n    end: true,\n    sensitive: false\n  }, globalOptions);\n  function getRecordMatcher(name) {\n    return matcherMap.get(name);\n  }\n  function addRoute(record, parent, originalRecord) {\n    // used later on to remove by name\n    let isRootAdd = !originalRecord;\n    let mainNormalizedRecord = normalizeRouteRecord(record);\n    // we might be the child of an alias\n    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;\n    const options = mergeOptions(globalOptions, record);\n    // generate an array of records to correctly handle aliases\n    const normalizedRecords = [mainNormalizedRecord];\n    if ('alias' in record) {\n      const aliases = typeof record.alias === 'string' ? [record.alias] : record.alias;\n      for (const alias of aliases) {\n        normalizedRecords.push(assign({}, mainNormalizedRecord, {\n          // this allows us to hold a copy of the `components` option\n          // so that async components cache is hold on the original record\n          components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,\n          path: alias,\n          // we might be the child of an alias\n          aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord\n        }));\n      }\n    }\n    let matcher;\n    let originalMatcher;\n    for (const normalizedRecord of normalizedRecords) {\n      let {\n        path\n      } = normalizedRecord;\n      // Build up the path for nested routes if the child isn't an absolute\n      // route. Only add the / delimiter if the child path isn't empty and if the\n      // parent path doesn't have a trailing slash\n      if (parent && path[0] !== '/') {\n        let parentPath = parent.record.path;\n        let connectingSlash = parentPath[parentPath.length - 1] === '/' ? '' : '/';\n        normalizedRecord.path = parent.record.path + (path && connectingSlash + path);\n      }\n      if (process.env.NODE_ENV !== 'production' && normalizedRecord.path === '*') {\n        throw new Error('Catch all routes (\"*\") must now be defined using a param with a custom regexp.\\n' + 'See more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.');\n      }\n      // create the object before hand so it can be passed to children\n      matcher = createRouteRecordMatcher(normalizedRecord, parent, options);\n      if (process.env.NODE_ENV !== 'production' && parent && path[0] === '/') checkMissingParamsInAbsolutePath(matcher, parent);\n      // if we are an alias we must tell the original record that we exist\n      // so we can be removed\n      if (originalRecord) {\n        originalRecord.alias.push(matcher);\n        if (process.env.NODE_ENV !== 'production') {\n          checkSameParams(originalRecord, matcher);\n        }\n      } else {\n        // otherwise, the first record is the original and others are aliases\n        originalMatcher = originalMatcher || matcher;\n        if (originalMatcher !== matcher) originalMatcher.alias.push(matcher);\n        // remove the route if named and only for the top record (avoid in nested calls)\n        // this works because the original record is the first one\n        if (isRootAdd && record.name && !isAliasRecord(matcher)) removeRoute(record.name);\n      }\n      if ('children' in mainNormalizedRecord) {\n        let children = mainNormalizedRecord.children;\n        for (let i = 0; i < children.length; i++) {\n          addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);\n        }\n      }\n      // if there was no original record, then the first one was not an alias and all\n      // other alias (if any) need to reference this record when adding children\n      originalRecord = originalRecord || matcher;\n      // TODO: add normalized records for more flexibility\n      // if (parent && isAliasRecord(originalRecord)) {\n      //   parent.children.push(originalRecord)\n      // }\n      insertMatcher(matcher);\n    }\n    return originalMatcher ? () => {\n      // since other matchers are aliases, they should be removed by the original matcher\n      removeRoute(originalMatcher);\n    } : noop;\n  }\n  function removeRoute(matcherRef) {\n    if (isRouteName(matcherRef)) {\n      const matcher = matcherMap.get(matcherRef);\n      if (matcher) {\n        matcherMap.delete(matcherRef);\n        matchers.splice(matchers.indexOf(matcher), 1);\n        matcher.children.forEach(removeRoute);\n        matcher.alias.forEach(removeRoute);\n      }\n    } else {\n      let index = matchers.indexOf(matcherRef);\n      if (index > -1) {\n        matchers.splice(index, 1);\n        if (matcherRef.record.name) matcherMap.delete(matcherRef.record.name);\n        matcherRef.children.forEach(removeRoute);\n        matcherRef.alias.forEach(removeRoute);\n      }\n    }\n  }\n  function getRoutes() {\n    return matchers;\n  }\n  function insertMatcher(matcher) {\n    let i = 0;\n    // console.log('i is', { i })\n    while (i < matchers.length && comparePathParserScore(matcher, matchers[i]) >= 0) i++;\n    // console.log('END i is', { i })\n    // while (i < matchers.length && matcher.score <= matchers[i].score) i++\n    matchers.splice(i, 0, matcher);\n    // only add the original record to the name map\n    if (matcher.record.name && !isAliasRecord(matcher)) matcherMap.set(matcher.record.name, matcher);\n  }\n  function resolve(location, currentLocation) {\n    let matcher;\n    let params = {};\n    let path;\n    let name;\n    if ('name' in location && location.name) {\n      matcher = matcherMap.get(location.name);\n      if (!matcher) throw createRouterError(1 /* MATCHER_NOT_FOUND */, {\n        location\n      });\n      name = matcher.record.name;\n      params = assign(\n      // paramsFromLocation is a new object\n      paramsFromLocation(currentLocation.params,\n      // only keep params that exist in the resolved location\n      // TODO: only keep optional params coming from a parent record\n      matcher.keys.filter(k => !k.optional).map(k => k.name)), location.params);\n      // throws if cannot be stringified\n      path = matcher.stringify(params);\n    } else if ('path' in location) {\n      // no need to resolve the path with the matcher as it was provided\n      // this also allows the user to control the encoding\n      path = location.path;\n      if (process.env.NODE_ENV !== 'production' && !path.startsWith('/')) {\n        warn(`The Matcher cannot resolve relative paths but received \"${path}\". Unless you directly called \\`matcher.resolve(\"${path}\")\\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-router-next.`);\n      }\n      matcher = matchers.find(m => m.re.test(path));\n      // matcher should have a value after the loop\n      if (matcher) {\n        // TODO: dev warning of unused params if provided\n        // we know the matcher works because we tested the regexp\n        params = matcher.parse(path);\n        name = matcher.record.name;\n      }\n      // location is a relative path\n    } else {\n      // match by name or path of current route\n      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find(m => m.re.test(currentLocation.path));\n      if (!matcher) throw createRouterError(1 /* MATCHER_NOT_FOUND */, {\n        location,\n        currentLocation\n      });\n      name = matcher.record.name;\n      // since we are navigating to the same location, we don't need to pick the\n      // params like when `name` is provided\n      params = assign({}, currentLocation.params, location.params);\n      path = matcher.stringify(params);\n    }\n    const matched = [];\n    let parentMatcher = matcher;\n    while (parentMatcher) {\n      // reversed order so parents are at the beginning\n      matched.unshift(parentMatcher.record);\n      parentMatcher = parentMatcher.parent;\n    }\n    return {\n      name,\n      path,\n      params,\n      matched,\n      meta: mergeMetaFields(matched)\n    };\n  }\n  // add initial routes\n  routes.forEach(route => addRoute(route));\n  return {\n    addRoute,\n    resolve,\n    removeRoute,\n    getRoutes,\n    getRecordMatcher\n  };\n}\nfunction paramsFromLocation(params, keys) {\n  let newParams = {};\n  for (let key of keys) {\n    if (key in params) newParams[key] = params[key];\n  }\n  return newParams;\n}\n/**\r\n * Normalizes a RouteRecordRaw. Creates a copy\r\n *\r\n * @param record\r\n * @returns the normalized version\r\n */\nfunction normalizeRouteRecord(record) {\n  return {\n    path: record.path,\n    redirect: record.redirect,\n    name: record.name,\n    meta: record.meta || {},\n    aliasOf: undefined,\n    beforeEnter: record.beforeEnter,\n    props: normalizeRecordProps(record),\n    children: record.children || [],\n    instances: {},\n    leaveGuards: new Set(),\n    updateGuards: new Set(),\n    enterCallbacks: {},\n    components: 'components' in record ? record.components || {} : {\n      default: record.component\n    }\n  };\n}\n/**\r\n * Normalize the optional `props` in a record to always be an object similar to\r\n * components. Also accept a boolean for components.\r\n * @param record\r\n */\nfunction normalizeRecordProps(record) {\n  const propsObject = {};\n  // props does not exist on redirect records but we can set false directly\n  const props = record.props || false;\n  if ('component' in record) {\n    propsObject.default = props;\n  } else {\n    // NOTE: we could also allow a function to be applied to every component.\n    // Would need user feedback for use cases\n    for (let name in record.components) propsObject[name] = typeof props === 'boolean' ? props : props[name];\n  }\n  return propsObject;\n}\n/**\r\n * Checks if a record or any of its parent is an alias\r\n * @param record\r\n */\nfunction isAliasRecord(record) {\n  while (record) {\n    if (record.record.aliasOf) return true;\n    record = record.parent;\n  }\n  return false;\n}\n/**\r\n * Merge meta fields of an array of records\r\n *\r\n * @param matched - array of matched records\r\n */\nfunction mergeMetaFields(matched) {\n  return matched.reduce((meta, record) => assign(meta, record.meta), {});\n}\nfunction mergeOptions(defaults, partialOptions) {\n  let options = {};\n  for (let key in defaults) {\n    options[key] = key in partialOptions ? partialOptions[key] : defaults[key];\n  }\n  return options;\n}\nfunction isSameParam(a, b) {\n  return a.name === b.name && a.optional === b.optional && a.repeatable === b.repeatable;\n}\nfunction checkSameParams(a, b) {\n  for (let key of a.keys) {\n    if (!b.keys.find(isSameParam.bind(null, key))) return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" should have the exact same param named \"${key.name}\"`);\n  }\n  for (let key of b.keys) {\n    if (!a.keys.find(isSameParam.bind(null, key))) return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" should have the exact same param named \"${key.name}\"`);\n  }\n}\nfunction checkMissingParamsInAbsolutePath(record, parent) {\n  for (let key of parent.keys) {\n    if (!record.keys.find(isSameParam.bind(null, key))) return warn(`Absolute path \"${record.record.path}\" should have the exact same param named \"${key.name}\" as its parent \"${parent.record.path}\".`);\n  }\n}\n\n/**\r\n * Encoding Rules ␣ = Space Path: ␣ \" < > # ? { } Query: ␣ \" < > # & = Hash: ␣ \"\r\n * < > `\r\n *\r\n * On top of that, the RFC3986 (https://tools.ietf.org/html/rfc3986#section-2.2)\r\n * defines some extra characters to be encoded. Most browsers do not encode them\r\n * in encodeURI https://github.com/whatwg/url/issues/369, so it may be safer to\r\n * also encode `!'()*`. Leaving unencoded only ASCII alphanumeric(`a-zA-Z0-9`)\r\n * plus `-._~`. This extra safety should be applied to query by patching the\r\n * string returned by encodeURIComponent encodeURI also encodes `[\\]^`. `\\`\r\n * should be encoded to avoid ambiguity. Browsers (IE, FF, C) transform a `\\`\r\n * into a `/` if directly typed in. The _backtick_ (`````) should also be\r\n * encoded everywhere because some browsers like FF encode it when directly\r\n * written while others don't. Safari and IE don't encode ``\"<>{}``` in hash.\r\n */\n// const EXTRA_RESERVED_RE = /[!'()*]/g\n// const encodeReservedReplacer = (c: string) => '%' + c.charCodeAt(0).toString(16)\nconst HASH_RE = /#/g; // %23\nconst AMPERSAND_RE = /&/g; // %26\nconst SLASH_RE = /\\//g; // %2F\nconst EQUAL_RE = /=/g; // %3D\nconst IM_RE = /\\?/g; // %3F\nconst PLUS_RE = /\\+/g; // %2B\n/**\r\n * NOTE: It's not clear to me if we should encode the + symbol in queries, it\r\n * seems to be less flexible than not doing so and I can't find out the legacy\r\n * systems requiring this for regular requests like text/html. In the standard,\r\n * the encoding of the plus character is only mentioned for\r\n * application/x-www-form-urlencoded\r\n * (https://url.spec.whatwg.org/#urlencoded-parsing) and most browsers seems lo\r\n * leave the plus character as is in queries. To be more flexible, we allow the\r\n * plus character on the query but it can also be manually encoded by the user.\r\n *\r\n * Resources:\r\n * - https://url.spec.whatwg.org/#urlencoded-parsing\r\n * - https://stackoverflow.com/questions/1634271/url-encoding-the-space-character-or-20\r\n */\nconst ENC_BRACKET_OPEN_RE = /%5B/g; // [\nconst ENC_BRACKET_CLOSE_RE = /%5D/g; // ]\nconst ENC_CARET_RE = /%5E/g; // ^\nconst ENC_BACKTICK_RE = /%60/g; // `\nconst ENC_CURLY_OPEN_RE = /%7B/g; // {\nconst ENC_PIPE_RE = /%7C/g; // |\nconst ENC_CURLY_CLOSE_RE = /%7D/g; // }\nconst ENC_SPACE_RE = /%20/g; // }\n/**\r\n * Encode characters that need to be encoded on the path, search and hash\r\n * sections of the URL.\r\n *\r\n * @internal\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\nfunction commonEncode(text) {\n  return encodeURI('' + text).replace(ENC_PIPE_RE, '|').replace(ENC_BRACKET_OPEN_RE, '[').replace(ENC_BRACKET_CLOSE_RE, ']');\n}\n/**\r\n * Encode characters that need to be encoded on the hash section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\nfunction encodeHash(text) {\n  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, '{').replace(ENC_CURLY_CLOSE_RE, '}').replace(ENC_CARET_RE, '^');\n}\n/**\r\n * Encode characters that need to be encoded query values on the query\r\n * section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\nfunction encodeQueryValue(text) {\n  return commonEncode(text)\n  // Encode the space as +, encode the + to differentiate it from the space\n  .replace(PLUS_RE, '%2B').replace(ENC_SPACE_RE, '+').replace(HASH_RE, '%23').replace(AMPERSAND_RE, '%26').replace(ENC_BACKTICK_RE, '`').replace(ENC_CURLY_OPEN_RE, '{').replace(ENC_CURLY_CLOSE_RE, '}').replace(ENC_CARET_RE, '^');\n}\n/**\r\n * Like `encodeQueryValue` but also encodes the `=` character.\r\n *\r\n * @param text - string to encode\r\n */\nfunction encodeQueryKey(text) {\n  return encodeQueryValue(text).replace(EQUAL_RE, '%3D');\n}\n/**\r\n * Encode characters that need to be encoded on the path section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\nfunction encodePath(text) {\n  return commonEncode(text).replace(HASH_RE, '%23').replace(IM_RE, '%3F');\n}\n/**\r\n * Encode characters that need to be encoded on the path section of the URL as a\r\n * param. This function encodes everything {@link encodePath} does plus the\r\n * slash (`/`) character.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\nfunction encodeParam(text) {\n  return encodePath(text).replace(SLASH_RE, '%2F');\n}\n/**\r\n * Decode text using `decodeURIComponent`. Returns the original text if it\r\n * fails.\r\n *\r\n * @param text - string to decode\r\n * @returns decoded string\r\n */\nfunction decode(text) {\n  try {\n    return decodeURIComponent('' + text);\n  } catch (err) {\n    process.env.NODE_ENV !== 'production' && warn(`Error decoding \"${text}\". Using original value`);\n  }\n  return '' + text;\n}\n\n/**\r\n * Transforms a queryString into a {@link LocationQuery} object. Accept both, a\r\n * version with the leading `?` and without Should work as URLSearchParams\r\n\n * @internal\r\n *\r\n * @param search - search string to parse\r\n * @returns a query object\r\n */\nfunction parseQuery(search) {\n  const query = {};\n  // avoid creating an object with an empty key and empty value\n  // because of split('&')\n  if (search === '' || search === '?') return query;\n  const hasLeadingIM = search[0] === '?';\n  const searchParams = (hasLeadingIM ? search.slice(1) : search).split('&');\n  for (let i = 0; i < searchParams.length; ++i) {\n    // pre decode the + into space\n    const searchParam = searchParams[i].replace(PLUS_RE, ' ');\n    // allow the = character\n    let eqPos = searchParam.indexOf('=');\n    let key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));\n    let value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));\n    if (key in query) {\n      // an extra variable for ts types\n      let currentValue = query[key];\n      if (!Array.isArray(currentValue)) {\n        currentValue = query[key] = [currentValue];\n      }\n      currentValue.push(value);\n    } else {\n      query[key] = value;\n    }\n  }\n  return query;\n}\n/**\r\n * Stringifies a {@link LocationQueryRaw} object. Like `URLSearchParams`, it\r\n * doesn't prepend a `?`\r\n *\r\n * @internal\r\n *\r\n * @param query - query object to stringify\r\n * @returns string version of the query without the leading `?`\r\n */\nfunction stringifyQuery(query) {\n  let search = '';\n  for (let key in query) {\n    if (search.length) search += '&';\n    const value = query[key];\n    key = encodeQueryKey(key);\n    if (value == null) {\n      // only null adds the value\n      if (value !== undefined) search += key;\n      continue;\n    }\n    // keep null values\n    let values = Array.isArray(value) ? value.map(v => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)];\n    for (let i = 0; i < values.length; i++) {\n      // only append & with i > 0\n      search += (i ? '&' : '') + key;\n      if (values[i] != null) search += '=' + values[i];\n    }\n  }\n  return search;\n}\n/**\r\n * Transforms a {@link LocationQueryRaw} into a {@link LocationQuery} by casting\r\n * numbers into strings, removing keys with an undefined value and replacing\r\n * undefined with null in arrays\r\n *\r\n * @param query - query object to normalize\r\n * @returns a normalized query object\r\n */\nfunction normalizeQuery(query) {\n  const normalizedQuery = {};\n  for (let key in query) {\n    let value = query[key];\n    if (value !== undefined) {\n      normalizedQuery[key] = Array.isArray(value) ? value.map(v => v == null ? null : '' + v) : value == null ? value : '' + value;\n    }\n  }\n  return normalizedQuery;\n}\n\n/**\r\n * Create a list of callbacks that can be reset. Used to create before and after navigation guards list\r\n */\nfunction useCallbacks() {\n  let handlers = [];\n  function add(handler) {\n    handlers.push(handler);\n    return () => {\n      const i = handlers.indexOf(handler);\n      if (i > -1) handlers.splice(i, 1);\n    };\n  }\n  function reset() {\n    handlers = [];\n  }\n  return {\n    add,\n    list: () => handlers,\n    reset\n  };\n}\nfunction registerGuard(record, name, guard) {\n  const removeFromList = () => {\n    record[name].delete(guard);\n  };\n  onUnmounted(removeFromList);\n  onDeactivated(removeFromList);\n  onActivated(() => {\n    record[name].add(guard);\n  });\n  record[name].add(guard);\n}\n/**\r\n * Add a navigation guard that triggers whenever the component for the current\r\n * location is about to be left. Similar to {@link beforeRouteLeave} but can be\r\n * used in any component. The guard is removed when the component is unmounted.\r\n *\r\n * @param leaveGuard - {@link NavigationGuard}\r\n */\nfunction onBeforeRouteLeave(leaveGuard) {\n  if (process.env.NODE_ENV !== 'production' && !getCurrentInstance()) {\n    warn('getCurrentInstance() returned null. onBeforeRouteLeave() must be called at the top of a setup function');\n    return;\n  }\n  const activeRecord = inject(matchedRouteKey, {}).value;\n  if (!activeRecord) {\n    process.env.NODE_ENV !== 'production' && warn('No active route record was found. Are you missing a <router-view> component?');\n    return;\n  }\n  registerGuard(activeRecord, 'leaveGuards', leaveGuard);\n}\n/**\r\n * Add a navigation guard that triggers whenever the current location is about\r\n * to be updated. Similar to {@link beforeRouteUpdate} but can be used in any\r\n * component. The guard is removed when the component is unmounted.\r\n *\r\n * @param updateGuard - {@link NavigationGuard}\r\n */\nfunction onBeforeRouteUpdate(updateGuard) {\n  if (process.env.NODE_ENV !== 'production' && !getCurrentInstance()) {\n    warn('getCurrentInstance() returned null. onBeforeRouteUpdate() must be called at the top of a setup function');\n    return;\n  }\n  const activeRecord = inject(matchedRouteKey, {}).value;\n  if (!activeRecord) {\n    process.env.NODE_ENV !== 'production' && warn('No active route record was found. Are you missing a <router-view> component?');\n    return;\n  }\n  registerGuard(activeRecord, 'updateGuards', updateGuard);\n}\nfunction guardToPromiseFn(guard, to, from, record, name) {\n  // keep a reference to the enterCallbackArray to prevent pushing callbacks if a new navigation took place\n  const enterCallbackArray = record && (\n  // name is defined if record is because of the function overload\n  record.enterCallbacks[name] = record.enterCallbacks[name] || []);\n  return () => new Promise((resolve, reject) => {\n    const next = valid => {\n      if (valid === false) reject(createRouterError(4 /* NAVIGATION_ABORTED */, {\n        from,\n        to\n      }));else if (valid instanceof Error) {\n        reject(valid);\n      } else if (isRouteLocation(valid)) {\n        reject(createRouterError(2 /* NAVIGATION_GUARD_REDIRECT */, {\n          from: to,\n          to: valid\n        }));\n      } else {\n        if (enterCallbackArray &&\n        // since enterCallbackArray is truthy, both record and name also are\n        record.enterCallbacks[name] === enterCallbackArray && typeof valid === 'function') enterCallbackArray.push(valid);\n        resolve();\n      }\n    };\n    // wrapping with Promise.resolve allows it to work with both async and sync guards\n    const guardReturn = guard.call(record && record.instances[name], to, from, process.env.NODE_ENV !== 'production' ? canOnlyBeCalledOnce(next, to, from) : next);\n    let guardCall = Promise.resolve(guardReturn);\n    if (guard.length < 3) guardCall = guardCall.then(next);\n    if (process.env.NODE_ENV !== 'production' && guard.length > 2) {\n      const message = `The \"next\" callback was never called inside of ${guard.name ? '\"' + guard.name + '\"' : ''}:\\n${guard.toString()}\\n. If you are returning a value instead of calling \"next\", make sure to remove the \"next\" parameter from your function.`;\n      if (typeof guardReturn === 'object' && 'then' in guardReturn) {\n        guardCall = guardCall.then(resolvedValue => {\n          // @ts-ignore: _called is added at canOnlyBeCalledOnce\n          if (!next._called) {\n            warn(message);\n            return Promise.reject(new Error('Invalid navigation guard'));\n          }\n          return resolvedValue;\n        });\n        // TODO: test me!\n      } else if (guardReturn !== undefined) {\n        // @ts-ignore: _called is added at canOnlyBeCalledOnce\n        if (!next._called) {\n          warn(message);\n          reject(new Error('Invalid navigation guard'));\n          return;\n        }\n      }\n    }\n    guardCall.catch(err => reject(err));\n  });\n}\nfunction canOnlyBeCalledOnce(next, to, from) {\n  let called = 0;\n  return function () {\n    if (called++ === 1) warn(`The \"next\" callback was called more than once in one navigation guard when going from \"${from.fullPath}\" to \"${to.fullPath}\". It should be called exactly one time in each navigation guard. This will fail in production.`);\n    // @ts-ignore: we put it in the original one because it's easier to check\n    next._called = true;\n    if (called === 1) next.apply(null, arguments);\n  };\n}\nfunction extractComponentsGuards(matched, guardType, to, from) {\n  const guards = [];\n  for (const record of matched) {\n    for (const name in record.components) {\n      let rawComponent = record.components[name];\n      if (process.env.NODE_ENV !== 'production') {\n        if (!rawComponent || typeof rawComponent !== 'object' && typeof rawComponent !== 'function') {\n          warn(`Component \"${name}\" in record with path \"${record.path}\" is not` + ` a valid component. Received \"${String(rawComponent)}\".`);\n          // throw to ensure we stop here but warn to ensure the message isn't\n          // missed by the user\n          throw new Error('Invalid route component');\n        } else if ('then' in rawComponent) {\n          // warn if user wrote import('/component.vue') instead of () =>\n          // import('./component.vue')\n          warn(`Component \"${name}\" in record with path \"${record.path}\" is a ` + `Promise instead of a function that returns a Promise. Did you ` + `write \"import('./MyPage.vue')\" instead of ` + `\"() => import('./MyPage.vue')\" ? This will break in ` + `production if not fixed.`);\n          let promise = rawComponent;\n          rawComponent = () => promise;\n        } else if (rawComponent.__asyncLoader &&\n        // warn only once per component\n        !rawComponent.__warnedDefineAsync) {\n          rawComponent.__warnedDefineAsync = true;\n          warn(`Component \"${name}\" in record with path \"${record.path}\" is defined ` + `using \"defineAsyncComponent()\". ` + `Write \"() => import('./MyPage.vue')\" instead of ` + `\"defineAsyncComponent(() => import('./MyPage.vue'))\".`);\n        }\n      }\n      // skip update and leave guards if the route component is not mounted\n      if (guardType !== 'beforeRouteEnter' && !record.instances[name]) continue;\n      if (isRouteComponent(rawComponent)) {\n        // __vccOpts is added by vue-class-component and contain the regular options\n        let options = rawComponent.__vccOpts || rawComponent;\n        const guard = options[guardType];\n        guard && guards.push(guardToPromiseFn(guard, to, from, record, name));\n      } else {\n        // start requesting the chunk already\n        let componentPromise = rawComponent();\n        if (process.env.NODE_ENV !== 'production' && !('catch' in componentPromise)) {\n          warn(`Component \"${name}\" in record with path \"${record.path}\" is a function that does not return a Promise. If you were passing a functional component, make sure to add a \"displayName\" to the component. This will break in production if not fixed.`);\n          componentPromise = Promise.resolve(componentPromise);\n        } else {\n          // display the error if any\n          componentPromise = componentPromise.catch(process.env.NODE_ENV !== 'production' ? err => err && warn(err) : console.error);\n        }\n        guards.push(() => componentPromise.then(resolved => {\n          if (!resolved) return Promise.reject(new Error(`Couldn't resolve component \"${name}\" at \"${record.path}\"`));\n          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;\n          // replace the function with the resolved component\n          record.components[name] = resolvedComponent;\n          // @ts-ignore: the options types are not propagated to Component\n          const guard = resolvedComponent[guardType];\n          return guard && guardToPromiseFn(guard, to, from, record, name)();\n        }));\n      }\n    }\n  }\n  return guards;\n}\n/**\r\n * Allows differentiating lazy components from functional components and vue-class-component\r\n * @param component\r\n */\nfunction isRouteComponent(component) {\n  return typeof component === 'object' || 'displayName' in component || 'props' in component || '__vccOpts' in component;\n}\n\n// TODO: we could allow currentRoute as a prop to expose `isActive` and\n// `isExactActive` behavior should go through an RFC\nfunction useLink(props) {\n  const router = inject(routerKey);\n  const currentRoute = inject(routeLocationKey);\n  const route = computed(() => router.resolve(unref(props.to)));\n  const activeRecordIndex = computed(() => {\n    let {\n      matched\n    } = route.value;\n    let {\n      length\n    } = matched;\n    const routeMatched = matched[length - 1];\n    let currentMatched = currentRoute.matched;\n    if (!routeMatched || !currentMatched.length) return -1;\n    let index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));\n    if (index > -1) return index;\n    // possible parent record\n    let parentRecordPath = getOriginalPath(matched[length - 2]);\n    return (\n      // we are dealing with nested routes\n      length > 1 &&\n      // if the parent and matched route have the same path, this link is\n      // referring to the empty child. Or we currently are on a different\n      // child of the same parent\n      getOriginalPath(routeMatched) === parentRecordPath &&\n      // avoid comparing the child with its parent\n      currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index\n    );\n  });\n  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));\n  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));\n  function navigate() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (guardEvent(e)) return router[unref(props.replace) ? 'replace' : 'push'](unref(props.to));\n    return Promise.resolve();\n  }\n  return {\n    route,\n    href: computed(() => route.value.href),\n    isActive,\n    isExactActive,\n    navigate\n  };\n}\nconst RouterLinkImpl = /*#__PURE__*/defineComponent({\n  name: 'RouterLink',\n  props: {\n    to: {\n      type: [String, Object],\n      required: true\n    },\n    replace: Boolean,\n    activeClass: String,\n    // inactiveClass: String,\n    exactActiveClass: String,\n    custom: Boolean,\n    ariaCurrentValue: {\n      type: String,\n      default: 'page'\n    }\n  },\n  setup(props, _ref8) {\n    let {\n      slots,\n      attrs\n    } = _ref8;\n    const link = reactive(useLink(props));\n    const {\n      options\n    } = inject(routerKey);\n    const elClass = computed(() => ({\n      [getLinkClass(props.activeClass, options.linkActiveClass, 'router-link-active')]: link.isActive,\n      // [getLinkClass(\n      //   props.inactiveClass,\n      //   options.linkInactiveClass,\n      //   'router-link-inactive'\n      // )]: !link.isExactActive,\n      [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, 'router-link-exact-active')]: link.isExactActive\n    }));\n    return () => {\n      const children = slots.default && slots.default(link);\n      return props.custom ? children : h('a', assign({\n        'aria-current': link.isExactActive ? props.ariaCurrentValue : null,\n        onClick: link.navigate,\n        href: link.href\n      }, attrs, {\n        class: elClass.value\n      }), children);\n    };\n  }\n});\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\n/**\r\n * Component to render a link that triggers a navigation on click.\r\n */\nconst RouterLink = RouterLinkImpl;\nfunction guardEvent(e) {\n  // don't redirect with control keys\n  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) return;\n  // don't redirect when preventDefault called\n  if (e.defaultPrevented) return;\n  // don't redirect on right click\n  if (e.button !== undefined && e.button !== 0) return;\n  // don't redirect if `target=\"_blank\"`\n  // @ts-ignore getAttribute does exist\n  if (e.currentTarget && e.currentTarget.getAttribute) {\n    // @ts-ignore getAttribute exists\n    const target = e.currentTarget.getAttribute('target');\n    if (/\\b_blank\\b/i.test(target)) return;\n  }\n  // this may be a Weex event which doesn't have this method\n  if (e.preventDefault) e.preventDefault();\n  return true;\n}\nfunction includesParams(outer, inner) {\n  for (let key in inner) {\n    let innerValue = inner[key];\n    let outerValue = outer[key];\n    if (typeof innerValue === 'string') {\n      if (innerValue !== outerValue) return false;\n    } else {\n      if (!Array.isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i])) return false;\n    }\n  }\n  return true;\n}\n/**\r\n * Get the original path value of a record by following its aliasOf\r\n * @param record\r\n */\nfunction getOriginalPath(record) {\n  return record ? record.aliasOf ? record.aliasOf.path : record.path : '';\n}\n/**\r\n * Utility class to get the active class based on defaults.\r\n * @param propClass\r\n * @param globalClass\r\n * @param defaultClass\r\n */\nconst getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;\nconst RouterViewImpl = /*#__PURE__*/defineComponent({\n  name: 'RouterView',\n  // #674 we manually inherit them\n  inheritAttrs: false,\n  props: {\n    name: {\n      type: String,\n      default: 'default'\n    },\n    route: Object\n  },\n  setup(props, _ref9) {\n    let {\n      attrs,\n      slots\n    } = _ref9;\n    process.env.NODE_ENV !== 'production' && warnDeprecatedUsage();\n    const injectedRoute = inject(routerViewLocationKey);\n    const routeToDisplay = computed(() => props.route || injectedRoute.value);\n    const depth = inject(viewDepthKey, 0);\n    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth]);\n    provide(viewDepthKey, depth + 1);\n    provide(matchedRouteKey, matchedRouteRef);\n    provide(routerViewLocationKey, routeToDisplay);\n    const viewRef = ref();\n    // watch at the same time the component instance, the route record we are\n    // rendering, and the name\n    watch(() => [viewRef.value, matchedRouteRef.value, props.name], (_ref10, _ref11) => {\n      let [instance, to, name] = _ref10;\n      let [oldInstance, from, oldName] = _ref11;\n      // copy reused instances\n      if (to) {\n        // this will update the instance for new instances as well as reused\n        // instances when navigating to a new route\n        to.instances[name] = instance;\n        // the component instance is reused for a different route or name so\n        // we copy any saved update or leave guards\n        if (from && from !== to && instance && instance === oldInstance) {\n          to.leaveGuards = from.leaveGuards;\n          to.updateGuards = from.updateGuards;\n        }\n      }\n      // trigger beforeRouteEnter next callbacks\n      if (instance && to && (\n      // if there is no instance but to and from are the same this might be\n      // the first visit\n      !from || !isSameRouteRecord(to, from) || !oldInstance)) {\n        (to.enterCallbacks[name] || []).forEach(callback => callback(instance));\n      }\n    }, {\n      flush: 'post'\n    });\n    return () => {\n      const route = routeToDisplay.value;\n      const matchedRoute = matchedRouteRef.value;\n      const ViewComponent = matchedRoute && matchedRoute.components[props.name];\n      // we need the value at the time we render because when we unmount, we\n      // navigated to a different location so the value is different\n      const currentName = props.name;\n      if (!ViewComponent) {\n        return normalizeSlot(slots.default, {\n          Component: ViewComponent,\n          route\n        });\n      }\n      // props from route configuration\n      const routePropsOption = matchedRoute.props[props.name];\n      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === 'function' ? routePropsOption(route) : routePropsOption : null;\n      const onVnodeUnmounted = vnode => {\n        // remove the instance reference to prevent leak\n        if (vnode.component.isUnmounted) {\n          matchedRoute.instances[currentName] = null;\n        }\n      };\n      const component = h(ViewComponent, assign({}, routeProps, attrs, {\n        onVnodeUnmounted,\n        ref: viewRef\n      }));\n      return (\n        // pass the vnode to the slot as a prop.\n        // h and <component :is=\"...\"> both accept vnodes\n        normalizeSlot(slots.default, {\n          Component: component,\n          route\n        }) || component\n      );\n    };\n  }\n});\nfunction normalizeSlot(slot, data) {\n  if (!slot) return null;\n  const slotContent = slot(data);\n  return slotContent.length === 1 ? slotContent[0] : slotContent;\n}\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\n/**\r\n * Component to display the current route the user is at.\r\n */\nconst RouterView = RouterViewImpl;\n// warn against deprecated usage with <transition> & <keep-alive>\n// due to functional component being no longer eager in Vue 3\nfunction warnDeprecatedUsage() {\n  const instance = getCurrentInstance();\n  const parentName = instance.parent && instance.parent.type.name;\n  if (parentName && (parentName === 'KeepAlive' || parentName.includes('Transition'))) {\n    const comp = parentName === 'KeepAlive' ? 'keep-alive' : 'transition';\n    warn(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.\\n` + `Use slot props instead:\\n\\n` + `<router-view v-slot=\"{ Component }\">\\n` + `  <${comp}>\\n` + `    <component :is=\"Component\" />\\n` + `  </${comp}>\\n` + `</router-view>`);\n  }\n}\nfunction getDevtoolsGlobalHook() {\n  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;\n}\nfunction getTarget() {\n  // @ts-ignore\n  return typeof navigator !== 'undefined' ? window : typeof global !== 'undefined' ? global : {};\n}\nconst HOOK_SETUP = 'devtools-plugin:setup';\nfunction setupDevtoolsPlugin(pluginDescriptor, setupFn) {\n  const hook = getDevtoolsGlobalHook();\n  if (hook) {\n    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);\n  } else {\n    const target = getTarget();\n    const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];\n    list.push({\n      pluginDescriptor,\n      setupFn\n    });\n  }\n}\nfunction formatRouteLocation(routeLocation, tooltip) {\n  const copy = assign({}, routeLocation, {\n    // remove variables that can contain vue instances\n    matched: routeLocation.matched.map(matched => omit(matched, ['instances', 'children', 'aliasOf']))\n  });\n  return {\n    _custom: {\n      type: null,\n      readOnly: true,\n      display: routeLocation.fullPath,\n      tooltip,\n      value: copy\n    }\n  };\n}\nfunction formatDisplay(display) {\n  return {\n    _custom: {\n      display\n    }\n  };\n}\n// to support multiple router instances\nlet routerId = 0;\nfunction addDevtools(app, router, matcher) {\n  // Take over router.beforeEach and afterEach\n  // increment to support multiple router instances\n  const id = routerId++;\n  setupDevtoolsPlugin({\n    id: 'Router' + id ? ' ' + id : '',\n    label: 'Router devtools',\n    app\n  }, api => {\n    api.on.inspectComponent((payload, ctx) => {\n      if (payload.instanceData) {\n        payload.instanceData.state.push({\n          type: 'Routing',\n          key: '$route',\n          editable: false,\n          value: formatRouteLocation(router.currentRoute.value, 'Current Route')\n        });\n      }\n    });\n    watch(router.currentRoute, () => {\n      // refresh active state\n      refreshRoutesView();\n      // @ts-ignore\n      api.notifyComponentUpdate();\n      api.sendInspectorTree(routerInspectorId);\n    });\n    const navigationsLayerId = 'router:navigations:' + id;\n    api.addTimelineLayer({\n      id: navigationsLayerId,\n      label: `Router${id ? ' ' + id : ''} Navigations`,\n      color: 0x40a8c4\n    });\n    // const errorsLayerId = 'router:errors'\n    // api.addTimelineLayer({\n    //   id: errorsLayerId,\n    //   label: 'Router Errors',\n    //   color: 0xea5455,\n    // })\n    router.onError(error => {\n      api.addTimelineEvent({\n        layerId: navigationsLayerId,\n        event: {\n          // @ts-ignore\n          logType: 'error',\n          time: Date.now(),\n          data: {\n            error\n          }\n        }\n      });\n    });\n    router.beforeEach((to, from) => {\n      const data = {\n        guard: formatDisplay('beforeEach'),\n        from: formatRouteLocation(from, 'Current Location during this navigation'),\n        to: formatRouteLocation(to, 'Target location')\n      };\n      api.addTimelineEvent({\n        layerId: navigationsLayerId,\n        event: {\n          time: Date.now(),\n          meta: {},\n          data\n        }\n      });\n    });\n    router.afterEach((to, from, failure) => {\n      const data = {\n        guard: formatDisplay('afterEach')\n      };\n      if (failure) {\n        data.failure = {\n          _custom: {\n            type: Error,\n            readOnly: true,\n            display: failure ? failure.message : '',\n            tooltip: 'Navigation Failure',\n            value: failure\n          }\n        };\n        data.status = formatDisplay('❌');\n      } else {\n        data.status = formatDisplay('✅');\n      }\n      // we set here to have the right order\n      data.from = formatRouteLocation(from, 'Current Location during this navigation');\n      data.to = formatRouteLocation(to, 'Target location');\n      api.addTimelineEvent({\n        layerId: navigationsLayerId,\n        event: {\n          time: Date.now(),\n          data,\n          // @ts-ignore\n          logType: failure ? 'warning' : 'default',\n          meta: {}\n        }\n      });\n    });\n    /**\r\n     * Inspector of Existing routes\r\n     */\n    const routerInspectorId = 'router-inspector:' + id;\n    api.addInspector({\n      id: routerInspectorId,\n      label: 'Routes' + (id ? ' ' + id : ''),\n      icon: 'book',\n      treeFilterPlaceholder: 'Search routes'\n    });\n    function refreshRoutesView() {\n      // the routes view isn't active\n      if (!activeRoutesPayload) return;\n      const payload = activeRoutesPayload;\n      // children routes will appear as nested\n      let routes = matcher.getRoutes().filter(route => !route.parent);\n      // reset match state to false\n      routes.forEach(resetMatchStateOnRouteRecord);\n      // apply a match state if there is a payload\n      if (payload.filter) {\n        routes = routes.filter(route =>\n        // save matches state based on the payload\n        isRouteMatching(route, payload.filter.toLowerCase()));\n      }\n      // mark active routes\n      routes.forEach(route => markRouteRecordActive(route, router.currentRoute.value));\n      payload.rootNodes = routes.map(formatRouteRecordForInspector);\n    }\n    let activeRoutesPayload;\n    api.on.getInspectorTree(payload => {\n      activeRoutesPayload = payload;\n      if (payload.app === app && payload.inspectorId === routerInspectorId) {\n        refreshRoutesView();\n      }\n    });\n    /**\r\n     * Display information about the currently selected route record\r\n     */\n    api.on.getInspectorState(payload => {\n      if (payload.app === app && payload.inspectorId === routerInspectorId) {\n        const routes = matcher.getRoutes();\n        const route = routes.find(route => route.record.__vd_id === payload.nodeId);\n        if (route) {\n          payload.state = {\n            options: formatRouteRecordMatcherForStateInspector(route)\n          };\n        }\n      }\n    });\n    api.sendInspectorTree(routerInspectorId);\n    api.sendInspectorState(routerInspectorId);\n  });\n}\nfunction modifierForKey(key) {\n  if (key.optional) {\n    return key.repeatable ? '*' : '?';\n  } else {\n    return key.repeatable ? '+' : '';\n  }\n}\nfunction formatRouteRecordMatcherForStateInspector(route) {\n  const {\n    record\n  } = route;\n  const fields = [{\n    editable: false,\n    key: 'path',\n    value: record.path\n  }];\n  if (record.name != null) {\n    fields.push({\n      editable: false,\n      key: 'name',\n      value: record.name\n    });\n  }\n  fields.push({\n    editable: false,\n    key: 'regexp',\n    value: route.re\n  });\n  if (route.keys.length) {\n    fields.push({\n      editable: false,\n      key: 'keys',\n      value: {\n        _custom: {\n          type: null,\n          readOnly: true,\n          display: route.keys.map(key => `${key.name}${modifierForKey(key)}`).join(' '),\n          tooltip: 'Param keys',\n          value: route.keys\n        }\n      }\n    });\n  }\n  if (record.redirect != null) {\n    fields.push({\n      editable: false,\n      key: 'redirect',\n      value: record.redirect\n    });\n  }\n  if (route.alias.length) {\n    fields.push({\n      editable: false,\n      key: 'aliases',\n      value: route.alias.map(alias => alias.record.path)\n    });\n  }\n  fields.push({\n    key: 'score',\n    editable: false,\n    value: {\n      _custom: {\n        type: null,\n        readOnly: true,\n        display: route.score.map(score => score.join(', ')).join(' | '),\n        tooltip: 'Score used to sort routes',\n        value: route.score\n      }\n    }\n  });\n  return fields;\n}\n/**\r\n * Extracted from tailwind palette\r\n */\nconst PINK_500 = 0xec4899;\nconst BLUE_600 = 0x2563eb;\nconst LIME_500 = 0x84cc16;\nconst CYAN_400 = 0x22d3ee;\nconst ORANGE_400 = 0xfb923c;\n// const GRAY_100 = 0xf4f4f5\nconst DARK = 0x666666;\nfunction formatRouteRecordForInspector(route) {\n  const tags = [];\n  const {\n    record\n  } = route;\n  if (record.name != null) {\n    tags.push({\n      label: String(record.name),\n      textColor: 0,\n      backgroundColor: CYAN_400\n    });\n  }\n  if (record.aliasOf) {\n    tags.push({\n      label: 'alias',\n      textColor: 0,\n      backgroundColor: ORANGE_400\n    });\n  }\n  if (route.__vd_match) {\n    tags.push({\n      label: 'matches',\n      textColor: 0,\n      backgroundColor: PINK_500\n    });\n  }\n  if (route.__vd_exactActive) {\n    tags.push({\n      label: 'exact',\n      textColor: 0,\n      backgroundColor: LIME_500\n    });\n  }\n  if (route.__vd_active) {\n    tags.push({\n      label: 'active',\n      textColor: 0,\n      backgroundColor: BLUE_600\n    });\n  }\n  if (record.redirect) {\n    tags.push({\n      label: 'redirect: ' + (typeof record.redirect === 'string' ? record.redirect : 'Object'),\n      textColor: 0xffffff,\n      backgroundColor: DARK\n    });\n  }\n  // add an id to be able to select it. Using the `path` is not possible because\n  // empty path children would collide with their parents\n  let id = String(routeRecordId++);\n  record.__vd_id = id;\n  return {\n    id,\n    label: record.path,\n    tags,\n    // @ts-ignore\n    children: route.children.map(formatRouteRecordForInspector)\n  };\n}\n//  incremental id for route records and inspector state\nlet routeRecordId = 0;\nconst EXTRACT_REGEXP_RE = /^\\/(.*)\\/([a-z]*)$/;\nfunction markRouteRecordActive(route, currentRoute) {\n  // no route will be active if matched is empty\n  // reset the matching state\n  const isExactActive = currentRoute.matched.length && isSameRouteRecord(currentRoute.matched[currentRoute.matched.length - 1], route.record);\n  route.__vd_exactActive = route.__vd_active = isExactActive;\n  if (!isExactActive) {\n    route.__vd_active = currentRoute.matched.some(match => isSameRouteRecord(match, route.record));\n  }\n  route.children.forEach(childRoute => markRouteRecordActive(childRoute, currentRoute));\n}\nfunction resetMatchStateOnRouteRecord(route) {\n  route.__vd_match = false;\n  route.children.forEach(resetMatchStateOnRouteRecord);\n}\nfunction isRouteMatching(route, filter) {\n  const found = String(route.re).match(EXTRACT_REGEXP_RE);\n  route.__vd_match = false;\n  if (!found || found.length < 3) {\n    return false;\n  }\n  // use a regexp without $ at the end to match nested routes better\n  const nonEndingRE = new RegExp(found[1].replace(/\\$$/, ''), found[2]);\n  if (nonEndingRE.test(filter)) {\n    // mark children as matches\n    route.children.forEach(child => isRouteMatching(child, filter));\n    // exception case: `/`\n    if (route.record.path !== '/' || filter === '/') {\n      route.__vd_match = route.re.test(filter);\n      return true;\n    }\n    // hide the / route\n    return false;\n  }\n  const path = route.record.path.toLowerCase();\n  const decodedPath = decode(path);\n  // also allow partial matching on the path\n  if (!filter.startsWith('/') && (decodedPath.includes(filter) || path.includes(filter))) return true;\n  if (decodedPath.startsWith(filter) || path.startsWith(filter)) return true;\n  if (route.record.name && String(route.record.name).includes(filter)) return true;\n  return route.children.some(child => isRouteMatching(child, filter));\n}\nfunction omit(obj, keys) {\n  const ret = {};\n  for (let key in obj) {\n    if (!keys.includes(key)) {\n      // @ts-ignore\n      ret[key] = obj[key];\n    }\n  }\n  return ret;\n}\n\n/**\r\n * Creates a Router instance that can be used by a Vue app.\r\n *\r\n * @param options - {@link RouterOptions}\r\n */\nfunction createRouter(options) {\n  const matcher = createRouterMatcher(options.routes, options);\n  let parseQuery$1 = options.parseQuery || parseQuery;\n  let stringifyQuery$1 = options.stringifyQuery || stringifyQuery;\n  let routerHistory = options.history;\n  const beforeGuards = useCallbacks();\n  const beforeResolveGuards = useCallbacks();\n  const afterGuards = useCallbacks();\n  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);\n  let pendingLocation = START_LOCATION_NORMALIZED;\n  // leave the scrollRestoration if no scrollBehavior is provided\n  if (isBrowser && options.scrollBehavior && 'scrollRestoration' in history) {\n    history.scrollRestoration = 'manual';\n  }\n  const normalizeParams = applyToParams.bind(null, paramValue => '' + paramValue);\n  const encodeParams = applyToParams.bind(null, encodeParam);\n  const decodeParams = applyToParams.bind(null, decode);\n  function addRoute(parentOrRoute, route) {\n    let parent;\n    let record;\n    if (isRouteName(parentOrRoute)) {\n      parent = matcher.getRecordMatcher(parentOrRoute);\n      record = route;\n    } else {\n      record = parentOrRoute;\n    }\n    return matcher.addRoute(record, parent);\n  }\n  function removeRoute(name) {\n    let recordMatcher = matcher.getRecordMatcher(name);\n    if (recordMatcher) {\n      matcher.removeRoute(recordMatcher);\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn(`Cannot remove non-existent route \"${String(name)}\"`);\n    }\n  }\n  function getRoutes() {\n    return matcher.getRoutes().map(routeMatcher => routeMatcher.record);\n  }\n  function hasRoute(name) {\n    return !!matcher.getRecordMatcher(name);\n  }\n  function resolve(rawLocation, currentLocation) {\n    // const objectLocation = routerLocationAsObject(rawLocation)\n    // we create a copy to modify it later\n    currentLocation = assign({}, currentLocation || currentRoute.value);\n    if (typeof rawLocation === 'string') {\n      let locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);\n      let matchedRoute = matcher.resolve({\n        path: locationNormalized.path\n      }, currentLocation);\n      let href = routerHistory.createHref(locationNormalized.fullPath);\n      if (process.env.NODE_ENV !== 'production') {\n        if (href.startsWith('//')) warn(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);else if (!matchedRoute.matched.length) {\n          warn(`No match found for location with path \"${rawLocation}\"`);\n        }\n      }\n      // locationNormalized is always a new object\n      return assign(locationNormalized, matchedRoute, {\n        params: decodeParams(matchedRoute.params),\n        hash: decode(locationNormalized.hash),\n        redirectedFrom: undefined,\n        href\n      });\n    }\n    let matcherLocation;\n    // path could be relative in object as well\n    if ('path' in rawLocation) {\n      if (process.env.NODE_ENV !== 'production' && 'params' in rawLocation && !('name' in rawLocation) && Object.keys(rawLocation.params).length) {\n        warn(`Path \"${rawLocation.path}\" was passed with params but they will be ignored. Use a named route alongside params instead.`);\n      }\n      matcherLocation = assign({}, rawLocation, {\n        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path\n      });\n    } else {\n      // pass encoded values to the matcher so it can produce encoded path and fullPath\n      matcherLocation = assign({}, rawLocation, {\n        params: encodeParams(rawLocation.params)\n      });\n      // current location params are decoded, we need to encode them in case the\n      // matcher merges the params\n      currentLocation.params = encodeParams(currentLocation.params);\n    }\n    let matchedRoute = matcher.resolve(matcherLocation, currentLocation);\n    const hash = rawLocation.hash || '';\n    if (process.env.NODE_ENV !== 'production' && hash && !hash.startsWith('#')) {\n      warn(`A \\`hash\\` should always start with the character \"#\". Replace \"${hash}\" with \"#${hash}\".`);\n    }\n    // decoding them) the matcher might have merged current location params so\n    // we need to run the decoding again\n    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));\n    const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {\n      hash: encodeHash(hash),\n      path: matchedRoute.path\n    }));\n    let href = routerHistory.createHref(fullPath);\n    if (process.env.NODE_ENV !== 'production') {\n      if (href.startsWith('//')) {\n        warn(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);\n      } else if (!matchedRoute.matched.length) {\n        warn(`No match found for location with path \"${'path' in rawLocation ? rawLocation.path : rawLocation}\"`);\n      }\n    }\n    return assign({\n      fullPath,\n      // keep the hash encoded so fullPath is effectively path + encodedQuery +\n      // hash\n      hash,\n      query:\n      // if the user is using a custom query lib like qs, we might have\n      // nested objects, so we keep the query as is, meaning it can contain\n      // numbers at `$route.query`, but at the point, the user will have to\n      // use their own type anyway.\n      // https://github.com/vuejs/vue-router-next/issues/328#issuecomment-649481567\n      stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query\n    }, matchedRoute, {\n      redirectedFrom: undefined,\n      href\n    });\n  }\n  function locationAsObject(to) {\n    return typeof to === 'string' ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);\n  }\n  function checkCanceledNavigation(to, from) {\n    if (pendingLocation !== to) {\n      return createRouterError(8 /* NAVIGATION_CANCELLED */, {\n        from,\n        to\n      });\n    }\n  }\n  function push(to) {\n    return pushWithRedirect(to);\n  }\n  function replace(to) {\n    return push(assign(locationAsObject(to), {\n      replace: true\n    }));\n  }\n  function handleRedirectRecord(to) {\n    const lastMatched = to.matched[to.matched.length - 1];\n    if (lastMatched && lastMatched.redirect) {\n      const {\n        redirect\n      } = lastMatched;\n      let newTargetLocation = typeof redirect === 'function' ? redirect(to) : redirect;\n      if (typeof newTargetLocation === 'string') {\n        newTargetLocation = newTargetLocation.indexOf('?') > -1 || newTargetLocation.indexOf('#') > -1 ? newTargetLocation = locationAsObject(newTargetLocation) : {\n          path: newTargetLocation\n        };\n      }\n      if (process.env.NODE_ENV !== 'production' && !('path' in newTargetLocation) && !('name' in newTargetLocation)) {\n        warn(`Invalid redirect found:\\n${JSON.stringify(newTargetLocation, null, 2)}\\n when navigating to \"${to.fullPath}\". A redirect must contain a name or path. This will break in production.`);\n        throw new Error('Invalid redirect');\n      }\n      return assign({\n        query: to.query,\n        hash: to.hash,\n        params: to.params\n      }, newTargetLocation);\n    }\n  }\n  function pushWithRedirect(to, redirectedFrom) {\n    const targetLocation = pendingLocation = resolve(to);\n    const from = currentRoute.value;\n    const data = to.state;\n    const force = to.force;\n    // to could be a string where `replace` is a function\n    const replace = to.replace === true;\n    const shouldRedirect = handleRedirectRecord(targetLocation);\n    if (shouldRedirect) return pushWithRedirect(assign(locationAsObject(shouldRedirect), {\n      state: data,\n      force,\n      replace\n    }),\n    // keep original redirectedFrom if it exists\n    redirectedFrom || targetLocation);\n    // if it was a redirect we already called `pushWithRedirect` above\n    const toLocation = targetLocation;\n    toLocation.redirectedFrom = redirectedFrom;\n    let failure;\n    if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {\n      failure = createRouterError(16 /* NAVIGATION_DUPLICATED */, {\n        to: toLocation,\n        from\n      });\n      // trigger scroll to allow scrolling to the same anchor\n      handleScroll(from, from,\n      // this is a push, the only way for it to be triggered from a\n      // history.listen is with a redirect, which makes it become a push\n      true,\n      // This cannot be the first navigation because the initial location\n      // cannot be manually navigated to\n      false);\n    }\n    return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch(error => isNavigationFailure(error) ? error :\n    // reject any unknown error\n    triggerError(error)).then(failure => {\n      if (failure) {\n        if (isNavigationFailure(failure, 2 /* NAVIGATION_GUARD_REDIRECT */)) {\n          if (process.env.NODE_ENV !== 'production' &&\n          // we are redirecting to the same location we were already at\n          isSameRouteLocation(stringifyQuery$1, resolve(failure.to), toLocation) &&\n          // and we have done it a couple of times\n          redirectedFrom &&\n          // @ts-ignore\n          (redirectedFrom._count = redirectedFrom._count ?\n          // @ts-ignore\n          redirectedFrom._count + 1 : 1) > 10) {\n            warn(`Detected an infinite redirection in a navigation guard when going from \"${from.fullPath}\" to \"${toLocation.fullPath}\". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`);\n            return Promise.reject(new Error('Infinite redirect in navigation guard'));\n          }\n          return pushWithRedirect(\n          // keep options\n          assign(locationAsObject(failure.to), {\n            state: data,\n            force,\n            replace\n          }),\n          // preserve the original redirectedFrom if any\n          redirectedFrom || toLocation);\n        }\n      } else {\n        // if we fail we don't finalize the navigation\n        failure = finalizeNavigation(toLocation, from, true, replace, data);\n      }\n      triggerAfterEach(toLocation, from, failure);\n      return failure;\n    });\n  }\n  /**\r\n   * Helper to reject and skip all navigation guards if a new navigation happened\r\n   * @param to\r\n   * @param from\r\n   */\n  function checkCanceledNavigationAndReject(to, from) {\n    const error = checkCanceledNavigation(to, from);\n    return error ? Promise.reject(error) : Promise.resolve();\n  }\n  // TODO: refactor the whole before guards by internally using router.beforeEach\n  function navigate(to, from) {\n    let guards;\n    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);\n    // all components here have been resolved once because we are leaving\n    guards = extractComponentsGuards(leavingRecords.reverse(), 'beforeRouteLeave', to, from);\n    // leavingRecords is already reversed\n    for (const record of leavingRecords) {\n      record.leaveGuards.forEach(guard => {\n        guards.push(guardToPromiseFn(guard, to, from));\n      });\n    }\n    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);\n    guards.push(canceledNavigationCheck);\n    // run the queue of per route beforeRouteLeave guards\n    return runGuardQueue(guards).then(() => {\n      // check global guards beforeEach\n      guards = [];\n      for (const guard of beforeGuards.list()) {\n        guards.push(guardToPromiseFn(guard, to, from));\n      }\n      guards.push(canceledNavigationCheck);\n      return runGuardQueue(guards);\n    }).then(() => {\n      // check in components beforeRouteUpdate\n      guards = extractComponentsGuards(updatingRecords, 'beforeRouteUpdate', to, from);\n      for (const record of updatingRecords) {\n        record.updateGuards.forEach(guard => {\n          guards.push(guardToPromiseFn(guard, to, from));\n        });\n      }\n      guards.push(canceledNavigationCheck);\n      // run the queue of per route beforeEnter guards\n      return runGuardQueue(guards);\n    }).then(() => {\n      // check the route beforeEnter\n      guards = [];\n      for (const record of to.matched) {\n        // do not trigger beforeEnter on reused views\n        if (record.beforeEnter && from.matched.indexOf(record) < 0) {\n          if (Array.isArray(record.beforeEnter)) {\n            for (const beforeEnter of record.beforeEnter) guards.push(guardToPromiseFn(beforeEnter, to, from));\n          } else {\n            guards.push(guardToPromiseFn(record.beforeEnter, to, from));\n          }\n        }\n      }\n      guards.push(canceledNavigationCheck);\n      // run the queue of per route beforeEnter guards\n      return runGuardQueue(guards);\n    }).then(() => {\n      // NOTE: at this point to.matched is normalized and does not contain any () => Promise<Component>\n      // clear existing enterCallbacks, these are added by extractComponentsGuards\n      to.matched.forEach(record => record.enterCallbacks = {});\n      // check in-component beforeRouteEnter\n      guards = extractComponentsGuards(enteringRecords, 'beforeRouteEnter', to, from);\n      guards.push(canceledNavigationCheck);\n      // run the queue of per route beforeEnter guards\n      return runGuardQueue(guards);\n    }).then(() => {\n      // check global guards beforeResolve\n      guards = [];\n      for (const guard of beforeResolveGuards.list()) {\n        guards.push(guardToPromiseFn(guard, to, from));\n      }\n      guards.push(canceledNavigationCheck);\n      return runGuardQueue(guards);\n    })\n    // catch any navigation canceled\n    .catch(err => isNavigationFailure(err, 8 /* NAVIGATION_CANCELLED */) ? err : Promise.reject(err));\n  }\n  function triggerAfterEach(to, from, failure) {\n    // navigation is confirmed, call afterGuards\n    // TODO: wrap with error handlers\n    for (const guard of afterGuards.list()) guard(to, from, failure);\n  }\n  /**\r\n   * - Cleans up any navigation guards\r\n   * - Changes the url if necessary\r\n   * - Calls the scrollBehavior\r\n   */\n  function finalizeNavigation(toLocation, from, isPush, replace, data) {\n    // a more recent navigation took place\n    const error = checkCanceledNavigation(toLocation, from);\n    if (error) return error;\n    // only consider as push if it's not the first navigation\n    const isFirstNavigation = from === START_LOCATION_NORMALIZED;\n    const state = !isBrowser ? {} : history.state;\n    // change URL only if the user did a push/replace and if it's not the initial navigation because\n    // it's just reflecting the url\n    if (isPush) {\n      // on the initial navigation, we want to reuse the scroll position from\n      // history state if it exists\n      if (replace || isFirstNavigation) routerHistory.replace(toLocation.fullPath, assign({\n        scroll: isFirstNavigation && state && state.scroll\n      }, data));else routerHistory.push(toLocation.fullPath, data);\n    }\n    // accept current navigation\n    currentRoute.value = toLocation;\n    handleScroll(toLocation, from, isPush, isFirstNavigation);\n    markAsReady();\n  }\n  let removeHistoryListener;\n  // attach listener to history to trigger navigations\n  function setupListeners() {\n    removeHistoryListener = routerHistory.listen((to, _from, info) => {\n      // cannot be a redirect route because it was in history\n      let toLocation = resolve(to);\n      // due to dynamic routing, and to hash history with manual navigation\n      // (manually changing the url or calling history.hash = '#/somewhere'),\n      // there could be a redirect record in history\n      const shouldRedirect = handleRedirectRecord(toLocation);\n      if (shouldRedirect) {\n        pushWithRedirect(assign(shouldRedirect, {\n          replace: true\n        }), toLocation).catch(noop);\n        return;\n      }\n      pendingLocation = toLocation;\n      const from = currentRoute.value;\n      // TODO: should be moved to web history?\n      if (isBrowser) {\n        saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());\n      }\n      navigate(toLocation, from).catch(error => {\n        if (isNavigationFailure(error, 4 /* NAVIGATION_ABORTED */ | 8 /* NAVIGATION_CANCELLED */)) {\n          return error;\n        }\n        if (isNavigationFailure(error, 2 /* NAVIGATION_GUARD_REDIRECT */)) {\n          // Here we could call if (info.delta) routerHistory.go(-info.delta,\n          // false) but this is bug prone as we have no way to wait the\n          // navigation to be finished before calling pushWithRedirect. Using\n          // a setTimeout of 16ms seems to work but there is not guarantee for\n          // it to work on every browser. So Instead we do not restore the\n          // history entry and trigger a new navigation as requested by the\n          // navigation guard.\n          // the error is already handled by router.push we just want to avoid\n          // logging the error\n          pushWithRedirect(error.to, toLocation\n          // avoid an uncaught rejection, let push call triggerError\n          ).catch(noop);\n          // avoid the then branch\n          return Promise.reject();\n        }\n        // do not restore history on unknown direction\n        if (info.delta) routerHistory.go(-info.delta, false);\n        // unrecognized error, transfer to the global handler\n        return triggerError(error);\n      }).then(failure => {\n        failure = failure || finalizeNavigation(\n        // after navigation, all matched components are resolved\n        toLocation, from, false);\n        // revert the navigation\n        if (failure && info.delta) routerHistory.go(-info.delta, false);\n        triggerAfterEach(toLocation, from, failure);\n      }).catch(noop);\n    });\n  }\n  // Initialization and Errors\n  let readyHandlers = useCallbacks();\n  let errorHandlers = useCallbacks();\n  let ready;\n  /**\r\n   * Trigger errorHandlers added via onError and throws the error as well\r\n   * @param error - error to throw\r\n   * @returns the error as a rejected promise\r\n   */\n  function triggerError(error) {\n    markAsReady(error);\n    errorHandlers.list().forEach(handler => handler(error));\n    return Promise.reject(error);\n  }\n  function isReady() {\n    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED) return Promise.resolve();\n    return new Promise((resolve, reject) => {\n      readyHandlers.add([resolve, reject]);\n    });\n  }\n  /**\r\n   * Mark the router as ready, resolving the promised returned by isReady(). Can\r\n   * only be called once, otherwise does nothing.\r\n   * @param err - optional error\r\n   */\n  function markAsReady(err) {\n    if (ready) return;\n    ready = true;\n    setupListeners();\n    readyHandlers.list().forEach(_ref12 => {\n      let [resolve, reject] = _ref12;\n      return err ? reject(err) : resolve();\n    });\n    readyHandlers.reset();\n  }\n  // Scroll behavior\n  function handleScroll(to, from, isPush, isFirstNavigation) {\n    const {\n      scrollBehavior\n    } = options;\n    if (!isBrowser || !scrollBehavior) return Promise.resolve();\n    let scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;\n    return nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then(position => position && scrollToPosition(position)).catch(triggerError);\n  }\n  const go = delta => routerHistory.go(delta);\n  let started;\n  const installedApps = new Set();\n  const router = {\n    currentRoute,\n    addRoute,\n    removeRoute,\n    hasRoute,\n    getRoutes,\n    resolve,\n    options,\n    push,\n    replace,\n    go,\n    back: () => go(-1),\n    forward: () => go(1),\n    beforeEach: beforeGuards.add,\n    beforeResolve: beforeResolveGuards.add,\n    afterEach: afterGuards.add,\n    onError: errorHandlers.add,\n    isReady,\n    install(app) {\n      const router = this;\n      app.component('RouterLink', RouterLink);\n      app.component('RouterView', RouterView);\n      app.config.globalProperties.$router = router;\n      Object.defineProperty(app.config.globalProperties, '$route', {\n        get: () => unref(currentRoute)\n      });\n      // this initial navigation is only necessary on client, on server it doesn't\n      // make sense because it will create an extra unnecessary navigation and could\n      // lead to problems\n      if (isBrowser &&\n      // used for the initial navigation client side to avoid pushing\n      // multiple times when the router is used in multiple apps\n      !started && currentRoute.value === START_LOCATION_NORMALIZED) {\n        // see above\n        started = true;\n        push(routerHistory.location).catch(err => {\n          if (process.env.NODE_ENV !== 'production') warn('Unexpected error when starting the router:', err);\n        });\n      }\n      const reactiveRoute = {};\n      for (let key in START_LOCATION_NORMALIZED) {\n        // @ts-ignore: the key matches\n        reactiveRoute[key] = computed(() => currentRoute.value[key]);\n      }\n      app.provide(routerKey, router);\n      app.provide(routeLocationKey, reactive(reactiveRoute));\n      app.provide(routerViewLocationKey, currentRoute);\n      let unmountApp = app.unmount;\n      installedApps.add(app);\n      app.unmount = function () {\n        installedApps.delete(app);\n        if (installedApps.size < 1) {\n          removeHistoryListener();\n          currentRoute.value = START_LOCATION_NORMALIZED;\n          started = false;\n          ready = false;\n        }\n        unmountApp.call(this, arguments);\n      };\n      if ((process.env.NODE_ENV !== 'production' || __VUE_PROD_DEVTOOLS__) && true) {\n        addDevtools(app, router, matcher);\n      }\n    }\n  };\n  return router;\n}\nfunction runGuardQueue(guards) {\n  return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());\n}\nfunction extractChangingRecords(to, from) {\n  const leavingRecords = [];\n  const updatingRecords = [];\n  const enteringRecords = [];\n  const len = Math.max(from.matched.length, to.matched.length);\n  for (let i = 0; i < len; i++) {\n    const recordFrom = from.matched[i];\n    if (recordFrom) {\n      if (to.matched.indexOf(recordFrom) < 0) leavingRecords.push(recordFrom);else updatingRecords.push(recordFrom);\n    }\n    const recordTo = to.matched[i];\n    if (recordTo) {\n      // the type doesn't matter because we are comparing per reference\n      if (from.matched.indexOf(recordTo) < 0) enteringRecords.push(recordTo);\n    }\n  }\n  return [leavingRecords, updatingRecords, enteringRecords];\n}\n\n/**\r\n * Returns the router instance. Equivalent to using `$router` inside\r\n * templates.\r\n */\nfunction useRouter() {\n  return inject(routerKey);\n}\n/**\r\n * Returns the current route location. Equivalent to using `$route` inside\r\n * templates.\r\n */\nfunction useRoute() {\n  return inject(routeLocationKey);\n}\nexport { NavigationFailureType, RouterLink, RouterView, START_LOCATION_NORMALIZED as START_LOCATION, createMemoryHistory, createRouter, createRouterMatcher, createWebHashHistory, createWebHistory, isNavigationFailure, matchedRouteKey, onBeforeRouteLeave, onBeforeRouteUpdate, parseQuery, routeLocationKey, routerKey, routerViewLocationKey, stringifyQuery, useLink, useRoute, useRouter, viewDepthKey };","map":{"version":3,"names":["getCurrentInstance","inject","onUnmounted","onDeactivated","onActivated","computed","unref","defineComponent","reactive","h","provide","ref","watch","shallowRef","nextTick","hasSymbol","Symbol","toStringTag","PolySymbol","name","process","env","NODE_ENV","matchedRouteKey","viewDepthKey","routerKey","routeLocationKey","routerViewLocationKey","isBrowser","window","isESModule","obj","__esModule","assign","Object","applyToParams","fn","params","newParams","key","value","Array","isArray","map","noop","warn","msg","args","from","arguments","slice","console","apply","concat","TRAILING_SLASH_RE","removeTrailingSlash","path","replace","parseURL","parseQuery","location","currentLocation","query","searchString","hash","searchPos","indexOf","hashPos","length","resolveRelativePath","fullPath","stringifyURL","stringifyQuery","stripBase","pathname","base","toLowerCase","isSameRouteLocation","a","b","aLastIndex","matched","bLastIndex","isSameRouteRecord","isSameRouteLocationParams","aliasOf","keys","isSameRouteLocationParamsValue","isEquivalentArray","every","i","to","startsWith","fromSegments","split","toSegments","position","toPosition","segment","join","NavigationType","NavigationDirection","START","normalizeBase","baseEl","document","querySelector","getAttribute","BEFORE_HASH_RE","createHref","getElementPosition","el","offset","docRect","documentElement","getBoundingClientRect","elRect","behavior","left","top","computeScrollPosition","pageXOffset","pageYOffset","scrollToPosition","scrollToOptions","positionEl","isIdSelector","getElementById","foundEl","err","style","scrollTo","getScrollKey","delta","history","state","scrollPositions","Map","saveScrollPosition","scrollPosition","set","getSavedScrollPosition","scroll","get","delete","createBaseLocation","protocol","host","createCurrentLocation","search","pathFromHash","useHistoryListeners","historyState","listeners","teardowns","pauseState","popStateHandler","fromState","forEach","listener","type","pop","direction","forward","back","unknown","pauseListeners","listen","callback","push","teardown","index","splice","beforeUnloadListener","replaceState","destroy","removeEventListener","addEventListener","buildState","current","replaced","computeScroll","useHistoryStateNavigation","changeLocation","hashIndex","url","error","data","currentState","createWebHistory","historyNavigation","historyListeners","go","triggerListeners","routerHistory","bind","defineProperty","createMemoryHistory","queue","setLocation","info","shouldTrigger","Math","max","min","createWebHashHistory","endsWith","isRouteLocation","route","isRouteName","START_LOCATION_NORMALIZED","undefined","meta","redirectedFrom","NavigationFailureSymbol","NavigationFailureType","ErrorTypeMessages","JSON","stringify","stringifyRoute","createRouterError","Error","isNavigationFailure","propertiesToLog","BASE_PARAM_PATTERN","BASE_PATH_PARSER_OPTIONS","sensitive","strict","start","end","REGEX_CHARS_RE","tokensToParser","segments","extraOptions","options","score","pattern","segmentScores","tokenIndex","token","subSegmentScore","repeatable","optional","regexp","re","RegExp","message","subPattern","parse","match","avoidDuplicatedSlash","param","text","compareScoreArray","diff","comparePathParserScore","aScore","bScore","comp","ROOT_TOKEN","VALID_PARAM_RE","tokenizePath","crash","buffer","previousState","tokens","finalizeSegment","char","customRe","consumeBuffer","addCharToBuffer","test","createRouteRecordMatcher","record","parent","parser","existingKeys","Set","has","add","matcher","children","alias","createRouterMatcher","routes","globalOptions","matchers","matcherMap","mergeOptions","getRecordMatcher","addRoute","originalRecord","isRootAdd","mainNormalizedRecord","normalizeRouteRecord","normalizedRecords","aliases","components","originalMatcher","normalizedRecord","parentPath","connectingSlash","checkMissingParamsInAbsolutePath","checkSameParams","isAliasRecord","removeRoute","insertMatcher","matcherRef","getRoutes","resolve","paramsFromLocation","filter","k","find","m","parentMatcher","unshift","mergeMetaFields","redirect","beforeEnter","props","normalizeRecordProps","instances","leaveGuards","updateGuards","enterCallbacks","default","component","propsObject","reduce","defaults","partialOptions","isSameParam","HASH_RE","AMPERSAND_RE","SLASH_RE","EQUAL_RE","IM_RE","PLUS_RE","ENC_BRACKET_OPEN_RE","ENC_BRACKET_CLOSE_RE","ENC_CARET_RE","ENC_BACKTICK_RE","ENC_CURLY_OPEN_RE","ENC_PIPE_RE","ENC_CURLY_CLOSE_RE","ENC_SPACE_RE","commonEncode","encodeURI","encodeHash","encodeQueryValue","encodeQueryKey","encodePath","encodeParam","decode","decodeURIComponent","hasLeadingIM","searchParams","searchParam","eqPos","currentValue","values","v","normalizeQuery","normalizedQuery","useCallbacks","handlers","handler","reset","list","registerGuard","guard","removeFromList","onBeforeRouteLeave","leaveGuard","activeRecord","onBeforeRouteUpdate","updateGuard","guardToPromiseFn","enterCallbackArray","Promise","reject","next","valid","guardReturn","call","canOnlyBeCalledOnce","guardCall","then","toString","resolvedValue","_called","catch","called","extractComponentsGuards","guardType","guards","rawComponent","String","promise","__asyncLoader","__warnedDefineAsync","isRouteComponent","__vccOpts","componentPromise","resolved","resolvedComponent","useLink","router","currentRoute","activeRecordIndex","routeMatched","currentMatched","findIndex","parentRecordPath","getOriginalPath","isActive","includesParams","isExactActive","navigate","e","guardEvent","href","RouterLinkImpl","required","Boolean","activeClass","exactActiveClass","custom","ariaCurrentValue","setup","slots","attrs","link","elClass","getLinkClass","linkActiveClass","linkExactActiveClass","onClick","class","RouterLink","metaKey","altKey","ctrlKey","shiftKey","defaultPrevented","button","currentTarget","target","preventDefault","outer","inner","innerValue","outerValue","some","propClass","globalClass","defaultClass","RouterViewImpl","inheritAttrs","warnDeprecatedUsage","injectedRoute","routeToDisplay","depth","matchedRouteRef","viewRef","instance","oldInstance","oldName","flush","matchedRoute","ViewComponent","currentName","normalizeSlot","Component","routePropsOption","routeProps","onVnodeUnmounted","vnode","isUnmounted","slot","slotContent","RouterView","parentName","includes","getDevtoolsGlobalHook","getTarget","__VUE_DEVTOOLS_GLOBAL_HOOK__","navigator","global","HOOK_SETUP","setupDevtoolsPlugin","pluginDescriptor","setupFn","hook","emit","__VUE_DEVTOOLS_PLUGINS__","formatRouteLocation","routeLocation","tooltip","copy","omit","_custom","readOnly","display","formatDisplay","routerId","addDevtools","app","id","label","api","on","inspectComponent","payload","ctx","instanceData","editable","refreshRoutesView","notifyComponentUpdate","sendInspectorTree","routerInspectorId","navigationsLayerId","addTimelineLayer","color","onError","addTimelineEvent","layerId","event","logType","time","Date","now","beforeEach","afterEach","failure","status","addInspector","icon","treeFilterPlaceholder","activeRoutesPayload","resetMatchStateOnRouteRecord","isRouteMatching","markRouteRecordActive","rootNodes","formatRouteRecordForInspector","getInspectorTree","inspectorId","getInspectorState","__vd_id","nodeId","formatRouteRecordMatcherForStateInspector","sendInspectorState","modifierForKey","fields","PINK_500","BLUE_600","LIME_500","CYAN_400","ORANGE_400","DARK","tags","textColor","backgroundColor","__vd_match","__vd_exactActive","__vd_active","routeRecordId","EXTRACT_REGEXP_RE","childRoute","found","nonEndingRE","child","decodedPath","ret","createRouter","parseQuery$1","stringifyQuery$1","beforeGuards","beforeResolveGuards","afterGuards","pendingLocation","scrollBehavior","scrollRestoration","normalizeParams","paramValue","encodeParams","decodeParams","parentOrRoute","recordMatcher","routeMatcher","hasRoute","rawLocation","locationNormalized","matcherLocation","locationAsObject","checkCanceledNavigation","pushWithRedirect","handleRedirectRecord","lastMatched","newTargetLocation","targetLocation","force","shouldRedirect","toLocation","handleScroll","triggerError","_count","finalizeNavigation","triggerAfterEach","checkCanceledNavigationAndReject","leavingRecords","updatingRecords","enteringRecords","extractChangingRecords","reverse","canceledNavigationCheck","runGuardQueue","isPush","isFirstNavigation","markAsReady","removeHistoryListener","setupListeners","_from","readyHandlers","errorHandlers","ready","isReady","started","installedApps","beforeResolve","install","config","globalProperties","$router","reactiveRoute","unmountApp","unmount","size","__VUE_PROD_DEVTOOLS__","len","recordFrom","recordTo","useRouter","useRoute","START_LOCATION"],"sources":["/home/davidf/Desktop/SSB/ssb-interface-v2/node_modules/vue-router/dist/vue-router.esm-bundler.js"],"sourcesContent":["/*!\n  * vue-router v4.0.3\n  * (c) 2021 Eduardo San Martin Morote\n  * @license MIT\n  */\nimport { getCurrentInstance, inject, onUnmounted, onDeactivated, onActivated, computed, unref, defineComponent, reactive, h, provide, ref, watch, shallowRef, nextTick } from 'vue';\n\nconst hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\r\nconst PolySymbol = (name) => \r\n// vr = vue router\r\nhasSymbol\r\n    ? Symbol((process.env.NODE_ENV !== 'production') ? '[vue-router]: ' + name : name)\r\n    : ((process.env.NODE_ENV !== 'production') ? '[vue-router]: ' : '_vr_') + name;\r\n// rvlm = Router View Location Matched\r\n/**\r\n * RouteRecord being rendered by the closest ancestor Router View. Used for\r\n * `onBeforeRouteUpdate` and `onBeforeRouteLeave`. rvlm stands for Router View\r\n * Location Matched\r\n *\r\n * @internal\r\n */\r\nconst matchedRouteKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'router view location matched' : 'rvlm');\r\n/**\r\n * Allows overriding the router view depth to control which component in\r\n * `matched` is rendered. rvd stands for Router View Depth\r\n *\r\n * @internal\r\n */\r\nconst viewDepthKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'router view depth' : 'rvd');\r\n/**\r\n * Allows overriding the router instance returned by `useRouter` in tests. r\r\n * stands for router\r\n *\r\n * @internal\r\n */\r\nconst routerKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'router' : 'r');\r\n/**\r\n * Allows overriding the current route returned by `useRoute` in tests. rl\r\n * stands for route location\r\n *\r\n * @internal\r\n */\r\nconst routeLocationKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'route location' : 'rl');\r\n/**\r\n * Allows overriding the current route used by router-view. Internally this is\r\n * used when the `route` prop is passed.\r\n *\r\n * @internal\r\n */\r\nconst routerViewLocationKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'router view location' : 'rvl');\n\nconst isBrowser = typeof window !== 'undefined';\n\nfunction isESModule(obj) {\r\n    return obj.__esModule || (hasSymbol && obj[Symbol.toStringTag] === 'Module');\r\n}\r\nconst assign = Object.assign;\r\nfunction applyToParams(fn, params) {\r\n    const newParams = {};\r\n    for (const key in params) {\r\n        const value = params[key];\r\n        newParams[key] = Array.isArray(value) ? value.map(fn) : fn(value);\r\n    }\r\n    return newParams;\r\n}\r\nlet noop = () => { };\n\nfunction warn(msg) {\r\n    // avoid using ...args as it breaks in older Edge builds\r\n    const args = Array.from(arguments).slice(1);\r\n    console.warn.apply(console, ['[Vue Router warn]: ' + msg].concat(args));\r\n}\n\nconst TRAILING_SLASH_RE = /\\/$/;\r\nconst removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, '');\r\n/**\r\n * Transforms an URI into a normalized history location\r\n *\r\n * @param parseQuery\r\n * @param location - URI to normalize\r\n * @param currentLocation - current absolute location. Allows resolving relative\r\n * paths. Must start with `/`. Defaults to `/`\r\n * @returns a normalized history location\r\n */\r\nfunction parseURL(parseQuery, location, currentLocation = '/') {\r\n    let path, query = {}, searchString = '', hash = '';\r\n    // Could use URL and URLSearchParams but IE 11 doesn't support it\r\n    const searchPos = location.indexOf('?');\r\n    const hashPos = location.indexOf('#', searchPos > -1 ? searchPos : 0);\r\n    if (searchPos > -1) {\r\n        path = location.slice(0, searchPos);\r\n        searchString = location.slice(searchPos + 1, hashPos > -1 ? hashPos : location.length);\r\n        query = parseQuery(searchString);\r\n    }\r\n    if (hashPos > -1) {\r\n        path = path || location.slice(0, hashPos);\r\n        // keep the # character\r\n        hash = location.slice(hashPos, location.length);\r\n    }\r\n    // no search and no query\r\n    path = resolveRelativePath(path != null ? path : location, currentLocation);\r\n    // empty path means a relative query or hash `?foo=f`, `#thing`\r\n    return {\r\n        fullPath: path + (searchString && '?') + searchString + hash,\r\n        path,\r\n        query,\r\n        hash,\r\n    };\r\n}\r\n/**\r\n * Stringifies a URL object\r\n *\r\n * @param stringifyQuery\r\n * @param location\r\n */\r\nfunction stringifyURL(stringifyQuery, location) {\r\n    let query = location.query ? stringifyQuery(location.query) : '';\r\n    return location.path + (query && '?') + query + (location.hash || '');\r\n}\r\n/**\r\n * Strips off the base from the beginning of a location.pathname in a non\r\n * case-sensitive way.\r\n *\r\n * @param pathname - location.pathname\r\n * @param base - base to strip off\r\n */\r\nfunction stripBase(pathname, base) {\r\n    // no base or base is not found at the beginning\r\n    if (!base || pathname.toLowerCase().indexOf(base.toLowerCase()))\r\n        return pathname;\r\n    return pathname.slice(base.length) || '/';\r\n}\r\n/**\r\n * Checks if two RouteLocation are equal. This means that both locations are\r\n * pointing towards the same {@link RouteRecord} and that all `params`, `query`\r\n * parameters and `hash` are the same\r\n *\r\n * @param a - first {@link RouteLocation}\r\n * @param b - second {@link RouteLocation}\r\n */\r\nfunction isSameRouteLocation(stringifyQuery, a, b) {\r\n    let aLastIndex = a.matched.length - 1;\r\n    let bLastIndex = b.matched.length - 1;\r\n    return (aLastIndex > -1 &&\r\n        aLastIndex === bLastIndex &&\r\n        isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) &&\r\n        isSameRouteLocationParams(a.params, b.params) &&\r\n        stringifyQuery(a.query) === stringifyQuery(b.query) &&\r\n        a.hash === b.hash);\r\n}\r\n/**\r\n * Check if two `RouteRecords` are equal. Takes into account aliases: they are\r\n * considered equal to the `RouteRecord` they are aliasing.\r\n *\r\n * @param a - first {@link RouteRecord}\r\n * @param b - second {@link RouteRecord}\r\n */\r\nfunction isSameRouteRecord(a, b) {\r\n    // since the original record has an undefined value for aliasOf\r\n    // but all aliases point to the original record, this will always compare\r\n    // the original record\r\n    return (a.aliasOf || a) === (b.aliasOf || b);\r\n}\r\nfunction isSameRouteLocationParams(a, b) {\r\n    if (Object.keys(a).length !== Object.keys(b).length)\r\n        return false;\r\n    for (let key in a) {\r\n        if (!isSameRouteLocationParamsValue(a[key], b[key]))\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\nfunction isSameRouteLocationParamsValue(a, b) {\r\n    return Array.isArray(a)\r\n        ? isEquivalentArray(a, b)\r\n        : Array.isArray(b)\r\n            ? isEquivalentArray(b, a)\r\n            : a === b;\r\n}\r\n/**\r\n * Check if two arrays are the same or if an array with one single entry is the\r\n * same as another primitive value. Used to check query and parameters\r\n *\r\n * @param a - array of values\r\n * @param b - array of values or a single value\r\n */\r\nfunction isEquivalentArray(a, b) {\r\n    return Array.isArray(b)\r\n        ? a.length === b.length && a.every((value, i) => value === b[i])\r\n        : a.length === 1 && a[0] === b;\r\n}\r\n/**\r\n * Resolves a relative path that starts with `.`.\r\n *\r\n * @param to - path location we are resolving\r\n * @param from - currentLocation.path, should start with `/`\r\n */\r\nfunction resolveRelativePath(to, from) {\r\n    if (to.startsWith('/'))\r\n        return to;\r\n    if ((process.env.NODE_ENV !== 'production') && !from.startsWith('/')) {\r\n        warn(`Cannot resolve a relative location without an absolute path. Trying to resolve \"${to}\" from \"${from}\". It should look like \"/${from}\".`);\r\n        return to;\r\n    }\r\n    if (!to)\r\n        return from;\r\n    const fromSegments = from.split('/');\r\n    const toSegments = to.split('/');\r\n    let position = fromSegments.length - 1;\r\n    let toPosition;\r\n    let segment;\r\n    for (toPosition = 0; toPosition < toSegments.length; toPosition++) {\r\n        segment = toSegments[toPosition];\r\n        // can't go below zero\r\n        if (position === 1 || segment === '.')\r\n            continue;\r\n        if (segment === '..')\r\n            position--;\r\n        // found something that is not relative path\r\n        else\r\n            break;\r\n    }\r\n    return (fromSegments.slice(0, position).join('/') +\r\n        '/' +\r\n        toSegments\r\n            .slice(toPosition - (toPosition === toSegments.length ? 1 : 0))\r\n            .join('/'));\r\n}\n\nvar NavigationType;\r\n(function (NavigationType) {\r\n    NavigationType[\"pop\"] = \"pop\";\r\n    NavigationType[\"push\"] = \"push\";\r\n})(NavigationType || (NavigationType = {}));\r\nvar NavigationDirection;\r\n(function (NavigationDirection) {\r\n    NavigationDirection[\"back\"] = \"back\";\r\n    NavigationDirection[\"forward\"] = \"forward\";\r\n    NavigationDirection[\"unknown\"] = \"\";\r\n})(NavigationDirection || (NavigationDirection = {}));\r\n/**\r\n * Starting location for Histories\r\n */\r\nconst START = '';\r\n// Generic utils\r\n/**\r\n * Normalizes a base by removing any trailing slash and reading the base tag if\r\n * present.\r\n *\r\n * @param base - base to normalize\r\n */\r\nfunction normalizeBase(base) {\r\n    if (!base) {\r\n        if (isBrowser) {\r\n            // respect <base> tag\r\n            const baseEl = document.querySelector('base');\r\n            base = (baseEl && baseEl.getAttribute('href')) || '/';\r\n            // strip full URL origin\r\n            base = base.replace(/^\\w+:\\/\\/[^\\/]+/, '');\r\n        }\r\n        else {\r\n            base = '/';\r\n        }\r\n    }\r\n    // ensure leading slash when it was removed by the regex above avoid leading\r\n    // slash with hash because the file could be read from the disk like file://\r\n    // and the leading slash would cause problems\r\n    if (base[0] !== '/' && base[0] !== '#')\r\n        base = '/' + base;\r\n    // remove the trailing slash so all other method can just do `base + fullPath`\r\n    // to build an href\r\n    return removeTrailingSlash(base);\r\n}\r\n// remove any character before the hash\r\nconst BEFORE_HASH_RE = /^[^#]+#/;\r\nfunction createHref(base, location) {\r\n    return base.replace(BEFORE_HASH_RE, '#') + location;\r\n}\n\nfunction getElementPosition(el, offset) {\r\n    const docRect = document.documentElement.getBoundingClientRect();\r\n    const elRect = el.getBoundingClientRect();\r\n    return {\r\n        behavior: offset.behavior,\r\n        left: elRect.left - docRect.left - (offset.left || 0),\r\n        top: elRect.top - docRect.top - (offset.top || 0),\r\n    };\r\n}\r\nconst computeScrollPosition = () => ({\r\n    left: window.pageXOffset,\r\n    top: window.pageYOffset,\r\n});\r\nfunction scrollToPosition(position) {\r\n    let scrollToOptions;\r\n    if ('el' in position) {\r\n        let positionEl = position.el;\r\n        const isIdSelector = typeof positionEl === 'string' && positionEl.startsWith('#');\r\n        /**\r\n         * `id`s can accept pretty much any characters, including CSS combinators\r\n         * like `>` or `~`. It's still possible to retrieve elements using\r\n         * `document.getElementById('~')` but it needs to be escaped when using\r\n         * `document.querySelector('#\\\\~')` for it to be valid. The only\r\n         * requirements for `id`s are them to be unique on the page and to not be\r\n         * empty (`id=\"\"`). Because of that, when passing an id selector, it should\r\n         * be properly escaped for it to work with `querySelector`. We could check\r\n         * for the id selector to be simple (no CSS combinators `+ >~`) but that\r\n         * would make things inconsistent since they are valid characters for an\r\n         * `id` but would need to be escaped when using `querySelector`, breaking\r\n         * their usage and ending up in no selector returned. Selectors need to be\r\n         * escaped:\r\n         *\r\n         * - `#1-thing` becomes `#\\31 -thing`\r\n         * - `#with~symbols` becomes `#with\\\\~symbols`\r\n         *\r\n         * - More information about  the topic can be found at\r\n         *   https://mathiasbynens.be/notes/html5-id-class.\r\n         * - Practical example: https://mathiasbynens.be/demo/html5-id\r\n         */\r\n        if ((process.env.NODE_ENV !== 'production') && typeof position.el === 'string') {\r\n            if (!isIdSelector || !document.getElementById(position.el.slice(1))) {\r\n                try {\r\n                    let foundEl = document.querySelector(position.el);\r\n                    if (isIdSelector && foundEl) {\r\n                        warn(`The selector \"${position.el}\" should be passed as \"el: document.querySelector('${position.el}')\" because it starts with \"#\".`);\r\n                        // return to avoid other warnings\r\n                        return;\r\n                    }\r\n                }\r\n                catch (err) {\r\n                    warn(`The selector \"${position.el}\" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);\r\n                    // return to avoid other warnings\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        const el = typeof positionEl === 'string'\r\n            ? isIdSelector\r\n                ? document.getElementById(positionEl.slice(1))\r\n                : document.querySelector(positionEl)\r\n            : positionEl;\r\n        if (!el) {\r\n            (process.env.NODE_ENV !== 'production') &&\r\n                warn(`Couldn't find element using selector \"${position.el}\" returned by scrollBehavior.`);\r\n            return;\r\n        }\r\n        scrollToOptions = getElementPosition(el, position);\r\n    }\r\n    else {\r\n        scrollToOptions = position;\r\n    }\r\n    if ('scrollBehavior' in document.documentElement.style)\r\n        window.scrollTo(scrollToOptions);\r\n    else {\r\n        window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);\r\n    }\r\n}\r\nfunction getScrollKey(path, delta) {\r\n    const position = history.state ? history.state.position - delta : -1;\r\n    return position + path;\r\n}\r\nconst scrollPositions = new Map();\r\nfunction saveScrollPosition(key, scrollPosition) {\r\n    scrollPositions.set(key, scrollPosition);\r\n}\r\nfunction getSavedScrollPosition(key) {\r\n    const scroll = scrollPositions.get(key);\r\n    // consume it so it's not used again\r\n    scrollPositions.delete(key);\r\n    return scroll;\r\n}\r\n// TODO: RFC about how to save scroll position\r\n/**\r\n * ScrollBehavior instance used by the router to compute and restore the scroll\r\n * position when navigating.\r\n */\r\n// export interface ScrollHandler<ScrollPositionEntry extends HistoryStateValue, ScrollPosition extends ScrollPositionEntry> {\r\n//   // returns a scroll position that can be saved in history\r\n//   compute(): ScrollPositionEntry\r\n//   // can take an extended ScrollPositionEntry\r\n//   scroll(position: ScrollPosition): void\r\n// }\r\n// export const scrollHandler: ScrollHandler<ScrollPosition> = {\r\n//   compute: computeScroll,\r\n//   scroll: scrollToPosition,\r\n// }\n\nlet createBaseLocation = () => location.protocol + '//' + location.host;\r\n/**\r\n * Creates a normalized history location from a window.location object\r\n * @param location -\r\n */\r\nfunction createCurrentLocation(base, location) {\r\n    const { pathname, search, hash } = location;\r\n    // allows hash based url\r\n    const hashPos = base.indexOf('#');\r\n    if (hashPos > -1) {\r\n        // prepend the starting slash to hash so the url starts with /#\r\n        let pathFromHash = hash.slice(1);\r\n        if (pathFromHash[0] !== '/')\r\n            pathFromHash = '/' + pathFromHash;\r\n        return stripBase(pathFromHash, '');\r\n    }\r\n    const path = stripBase(pathname, base);\r\n    return path + search + hash;\r\n}\r\nfunction useHistoryListeners(base, historyState, currentLocation, replace) {\r\n    let listeners = [];\r\n    let teardowns = [];\r\n    // TODO: should it be a stack? a Dict. Check if the popstate listener\r\n    // can trigger twice\r\n    let pauseState = null;\r\n    const popStateHandler = ({ state, }) => {\r\n        const to = createCurrentLocation(base, location);\r\n        const from = currentLocation.value;\r\n        const fromState = historyState.value;\r\n        let delta = 0;\r\n        if (state) {\r\n            currentLocation.value = to;\r\n            historyState.value = state;\r\n            // ignore the popstate and reset the pauseState\r\n            if (pauseState && pauseState === from) {\r\n                pauseState = null;\r\n                return;\r\n            }\r\n            delta = fromState ? state.position - fromState.position : 0;\r\n        }\r\n        else {\r\n            replace(to);\r\n        }\r\n        // console.log({ deltaFromCurrent })\r\n        // Here we could also revert the navigation by calling history.go(-delta)\r\n        // this listener will have to be adapted to not trigger again and to wait for the url\r\n        // to be updated before triggering the listeners. Some kind of validation function would also\r\n        // need to be passed to the listeners so the navigation can be accepted\r\n        // call all listeners\r\n        listeners.forEach(listener => {\r\n            listener(currentLocation.value, from, {\r\n                delta,\r\n                type: NavigationType.pop,\r\n                direction: delta\r\n                    ? delta > 0\r\n                        ? NavigationDirection.forward\r\n                        : NavigationDirection.back\r\n                    : NavigationDirection.unknown,\r\n            });\r\n        });\r\n    };\r\n    function pauseListeners() {\r\n        pauseState = currentLocation.value;\r\n    }\r\n    function listen(callback) {\r\n        // setup the listener and prepare teardown callbacks\r\n        listeners.push(callback);\r\n        const teardown = () => {\r\n            const index = listeners.indexOf(callback);\r\n            if (index > -1)\r\n                listeners.splice(index, 1);\r\n        };\r\n        teardowns.push(teardown);\r\n        return teardown;\r\n    }\r\n    function beforeUnloadListener() {\r\n        const { history } = window;\r\n        if (!history.state)\r\n            return;\r\n        history.replaceState(assign({}, history.state, { scroll: computeScrollPosition() }), '');\r\n    }\r\n    function destroy() {\r\n        for (const teardown of teardowns)\r\n            teardown();\r\n        teardowns = [];\r\n        window.removeEventListener('popstate', popStateHandler);\r\n        window.removeEventListener('beforeunload', beforeUnloadListener);\r\n    }\r\n    // setup the listeners and prepare teardown callbacks\r\n    window.addEventListener('popstate', popStateHandler);\r\n    window.addEventListener('beforeunload', beforeUnloadListener);\r\n    return {\r\n        pauseListeners,\r\n        listen,\r\n        destroy,\r\n    };\r\n}\r\n/**\r\n * Creates a state object\r\n */\r\nfunction buildState(back, current, forward, replaced = false, computeScroll = false) {\r\n    return {\r\n        back,\r\n        current,\r\n        forward,\r\n        replaced,\r\n        position: window.history.length,\r\n        scroll: computeScroll ? computeScrollPosition() : null,\r\n    };\r\n}\r\nfunction useHistoryStateNavigation(base) {\r\n    const { history, location } = window;\r\n    // private variables\r\n    let currentLocation = {\r\n        value: createCurrentLocation(base, location),\r\n    };\r\n    let historyState = { value: history.state };\r\n    // build current history entry as this is a fresh navigation\r\n    if (!historyState.value) {\r\n        changeLocation(currentLocation.value, {\r\n            back: null,\r\n            current: currentLocation.value,\r\n            forward: null,\r\n            // the length is off by one, we need to decrease it\r\n            position: history.length - 1,\r\n            replaced: true,\r\n            // don't add a scroll as the user may have an anchor and we want\r\n            // scrollBehavior to be triggered without a saved position\r\n            scroll: null,\r\n        }, true);\r\n    }\r\n    function changeLocation(to, state, replace) {\r\n        /**\r\n         * if a base tag is provided and we are on a normal domain, we have to\r\n         * respect the provided `base` attribute because pushState() will use it and\r\n         * potentially erase anything before the `#` like at\r\n         * https://github.com/vuejs/vue-router-next/issues/685 where a base of\r\n         * `/folder/#` but a base of `/` would erase the `/folder/` section. If\r\n         * there is no host, the `<base>` tag makes no sense and if there isn't a\r\n         * base tag we can just use everything after the `#`.\r\n         */\r\n        const hashIndex = base.indexOf('#');\r\n        const url = hashIndex > -1\r\n            ? (location.host && document.querySelector('base')\r\n                ? base\r\n                : base.slice(hashIndex)) + to\r\n            : createBaseLocation() + base + to;\r\n        try {\r\n            // BROWSER QUIRK\r\n            // NOTE: Safari throws a SecurityError when calling this function 100 times in 30 seconds\r\n            history[replace ? 'replaceState' : 'pushState'](state, '', url);\r\n            historyState.value = state;\r\n        }\r\n        catch (err) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                warn('Error with push/replace State', err);\r\n            }\r\n            else {\r\n                console.error(err);\r\n            }\r\n            // Force the navigation, this also resets the call count\r\n            location[replace ? 'replace' : 'assign'](url);\r\n        }\r\n    }\r\n    function replace(to, data) {\r\n        const state = assign({}, history.state, buildState(historyState.value.back, \r\n        // keep back and forward entries but override current position\r\n        to, historyState.value.forward, true), data, { position: historyState.value.position });\r\n        changeLocation(to, state, true);\r\n        currentLocation.value = to;\r\n    }\r\n    function push(to, data) {\r\n        // Add to current entry the information of where we are going\r\n        // as well as saving the current position\r\n        const currentState = assign({}, \r\n        // use current history state to gracefully handle a wrong call to\r\n        // history.replaceState\r\n        // https://github.com/vuejs/vue-router-next/issues/366\r\n        historyState.value, history.state, {\r\n            forward: to,\r\n            scroll: computeScrollPosition(),\r\n        });\r\n        if ((process.env.NODE_ENV !== 'production') && !history.state) {\r\n            warn(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:\\n\\n` +\r\n                `history.replaceState(history.state, '', url)\\n\\n` +\r\n                `You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`);\r\n        }\r\n        changeLocation(currentState.current, currentState, true);\r\n        const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);\r\n        changeLocation(to, state, false);\r\n        currentLocation.value = to;\r\n    }\r\n    return {\r\n        location: currentLocation,\r\n        state: historyState,\r\n        push,\r\n        replace,\r\n    };\r\n}\r\n/**\r\n * Creates an HTML5 history. Most common history for single page applications.\r\n *\r\n * @param base -\r\n */\r\nfunction createWebHistory(base) {\r\n    base = normalizeBase(base);\r\n    const historyNavigation = useHistoryStateNavigation(base);\r\n    const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);\r\n    function go(delta, triggerListeners = true) {\r\n        if (!triggerListeners)\r\n            historyListeners.pauseListeners();\r\n        history.go(delta);\r\n    }\r\n    const routerHistory = assign({\r\n        // it's overridden right after\r\n        location: '',\r\n        base,\r\n        go,\r\n        createHref: createHref.bind(null, base),\r\n    }, historyNavigation, historyListeners);\r\n    Object.defineProperty(routerHistory, 'location', {\r\n        get: () => historyNavigation.location.value,\r\n    });\r\n    Object.defineProperty(routerHistory, 'state', {\r\n        get: () => historyNavigation.state.value,\r\n    });\r\n    return routerHistory;\r\n}\n\n/**\r\n * Creates a in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere.\r\n * It's up to the user to replace that location with the starter location by either calling `router.push` or `router.replace`.\r\n *\r\n * @param base - Base applied to all urls, defaults to '/'\r\n * @returns a history object that can be passed to the router constructor\r\n */\r\nfunction createMemoryHistory(base = '') {\r\n    let listeners = [];\r\n    let queue = [START];\r\n    let position = 0;\r\n    function setLocation(location) {\r\n        position++;\r\n        if (position === queue.length) {\r\n            // we are at the end, we can simply append a new entry\r\n            queue.push(location);\r\n        }\r\n        else {\r\n            // we are in the middle, we remove everything from here in the queue\r\n            queue.splice(position);\r\n            queue.push(location);\r\n        }\r\n    }\r\n    function triggerListeners(to, from, { direction, delta }) {\r\n        const info = {\r\n            direction,\r\n            delta,\r\n            type: NavigationType.pop,\r\n        };\r\n        for (let callback of listeners) {\r\n            callback(to, from, info);\r\n        }\r\n    }\r\n    const routerHistory = {\r\n        // rewritten by Object.defineProperty\r\n        location: START,\r\n        state: {},\r\n        base,\r\n        createHref: createHref.bind(null, base),\r\n        replace(to) {\r\n            // remove current entry and decrement position\r\n            queue.splice(position--, 1);\r\n            setLocation(to);\r\n        },\r\n        push(to, data) {\r\n            setLocation(to);\r\n        },\r\n        listen(callback) {\r\n            listeners.push(callback);\r\n            return () => {\r\n                const index = listeners.indexOf(callback);\r\n                if (index > -1)\r\n                    listeners.splice(index, 1);\r\n            };\r\n        },\r\n        destroy() {\r\n            listeners = [];\r\n        },\r\n        go(delta, shouldTrigger = true) {\r\n            const from = this.location;\r\n            const direction = \r\n            // we are considering delta === 0 going forward, but in abstract mode\r\n            // using 0 for the delta doesn't make sense like it does in html5 where\r\n            // it reloads the page\r\n            delta < 0 ? NavigationDirection.back : NavigationDirection.forward;\r\n            position = Math.max(0, Math.min(position + delta, queue.length - 1));\r\n            if (shouldTrigger) {\r\n                triggerListeners(this.location, from, {\r\n                    direction,\r\n                    delta,\r\n                });\r\n            }\r\n        },\r\n    };\r\n    Object.defineProperty(routerHistory, 'location', {\r\n        get: () => queue[position],\r\n    });\r\n    return routerHistory;\r\n}\n\n/**\r\n * Creates a hash history. Useful for web applications with no host (e.g.\r\n * `file://`) or when configuring a server to handle any URL is not possible.\r\n *\r\n * @param base - optional base to provide. Defaults to `location.pathname +\r\n * location.search` If there is a `<base>` tag in the `head`, its value will be\r\n * ignored in favor of this parameter **but note it affects all the\r\n * history.pushState() calls**, meaning that if you use a `<base>` tag, it's\r\n * `href` value **has to match this parameter** (ignoring anything after the\r\n * `#`).\r\n *\r\n * @example\r\n * ```js\r\n * // at https://example.com/folder\r\n * createWebHashHistory() // gives a url of `https://example.com/folder#`\r\n * createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`\r\n * // if the `#` is provided in the base, it won't be added by `createWebHashHistory`\r\n * createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`\r\n * // you should avoid doing this because it changes the original url and breaks copying urls\r\n * createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`\r\n *\r\n * // at file:///usr/etc/folder/index.html\r\n * // for locations with no `host`, the base is ignored\r\n * createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`\r\n * ```\r\n */\r\nfunction createWebHashHistory(base) {\r\n    // Make sure this implementation is fine in terms of encoding, specially for IE11\r\n    // for `file://`, directly use the pathname and ignore the base\r\n    // location.pathname contains an initial `/` even at the root: `https://example.com`\r\n    base = location.host ? base || location.pathname + location.search : '';\r\n    // allow the user to provide a `#` in the middle: `/base/#/app`\r\n    if (base.indexOf('#') < 0)\r\n        base += '#';\r\n    if ((process.env.NODE_ENV !== 'production') && !base.endsWith('#/') && !base.endsWith('#')) {\r\n        warn(`A hash base must end with a \"#\":\\n\"${base}\" should be \"${base.replace(/#.*$/, '#')}\".`);\r\n    }\r\n    return createWebHistory(base);\r\n}\n\nfunction isRouteLocation(route) {\r\n    return typeof route === 'string' || (route && typeof route === 'object');\r\n}\r\nfunction isRouteName(name) {\r\n    return typeof name === 'string' || typeof name === 'symbol';\r\n}\n\n/**\r\n * Initial route location where the router is. Can be used in navigation guards\r\n * to differentiate the initial navigation.\r\n *\r\n * @example\r\n * ```js\r\n * import { START_LOCATION } from 'vue-router'\r\n *\r\n * router.beforeEach((to, from) => {\r\n *   if (from === START_LOCATION) {\r\n *     // initial navigation\r\n *   }\r\n * })\r\n * ```\r\n */\r\nconst START_LOCATION_NORMALIZED = {\r\n    path: '/',\r\n    name: undefined,\r\n    params: {},\r\n    query: {},\r\n    hash: '',\r\n    fullPath: '/',\r\n    matched: [],\r\n    meta: {},\r\n    redirectedFrom: undefined,\r\n};\n\nconst NavigationFailureSymbol = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'navigation failure' : 'nf');\r\n/**\r\n * Enumeration with all possible types for navigation failures. Can be passed to\r\n * {@link isNavigationFailure} to check for specific failures.\r\n */\r\nvar NavigationFailureType;\r\n(function (NavigationFailureType) {\r\n    /**\r\n     * An aborted navigation is a navigation that failed because a navigation\r\n     * guard returned `false` or called `next(false)`\r\n     */\r\n    NavigationFailureType[NavigationFailureType[\"aborted\"] = 4] = \"aborted\";\r\n    /**\r\n     * A cancelled navigation is a navigation that failed because a more recent\r\n     * navigation finished started (not necessarily finished).\r\n     */\r\n    NavigationFailureType[NavigationFailureType[\"cancelled\"] = 8] = \"cancelled\";\r\n    /**\r\n     * A duplicated navigation is a navigation that failed because it was\r\n     * initiated while already being at the exact same location.\r\n     */\r\n    NavigationFailureType[NavigationFailureType[\"duplicated\"] = 16] = \"duplicated\";\r\n})(NavigationFailureType || (NavigationFailureType = {}));\r\n// DEV only debug messages\r\nconst ErrorTypeMessages = {\r\n    [1 /* MATCHER_NOT_FOUND */]({ location, currentLocation }) {\r\n        return `No match for\\n ${JSON.stringify(location)}${currentLocation\r\n            ? '\\nwhile being at\\n' + JSON.stringify(currentLocation)\r\n            : ''}`;\r\n    },\r\n    [2 /* NAVIGATION_GUARD_REDIRECT */]({ from, to, }) {\r\n        return `Redirected from \"${from.fullPath}\" to \"${stringifyRoute(to)}\" via a navigation guard.`;\r\n    },\r\n    [4 /* NAVIGATION_ABORTED */]({ from, to }) {\r\n        return `Navigation aborted from \"${from.fullPath}\" to \"${to.fullPath}\" via a navigation guard.`;\r\n    },\r\n    [8 /* NAVIGATION_CANCELLED */]({ from, to }) {\r\n        return `Navigation cancelled from \"${from.fullPath}\" to \"${to.fullPath}\" with a new navigation.`;\r\n    },\r\n    [16 /* NAVIGATION_DUPLICATED */]({ from, to }) {\r\n        return `Avoided redundant navigation to current location: \"${from.fullPath}\".`;\r\n    },\r\n};\r\nfunction createRouterError(type, params) {\r\n    if ((process.env.NODE_ENV !== 'production') || !true) {\r\n        return assign(new Error(ErrorTypeMessages[type](params)), {\r\n            type,\r\n            [NavigationFailureSymbol]: true,\r\n        }, params);\r\n    }\r\n    else {\r\n        return assign(new Error(), {\r\n            type,\r\n            [NavigationFailureSymbol]: true,\r\n        }, params);\r\n    }\r\n}\r\nfunction isNavigationFailure(error, type) {\r\n    return (error instanceof Error &&\r\n        NavigationFailureSymbol in error &&\r\n        (type == null || !!(error.type & type)));\r\n}\r\nconst propertiesToLog = ['params', 'query', 'hash'];\r\nfunction stringifyRoute(to) {\r\n    if (typeof to === 'string')\r\n        return to;\r\n    if ('path' in to)\r\n        return to.path;\r\n    const location = {};\r\n    for (const key of propertiesToLog) {\r\n        if (key in to)\r\n            location[key] = to[key];\r\n    }\r\n    return JSON.stringify(location, null, 2);\r\n}\n\n// default pattern for a param: non greedy everything but /\r\nconst BASE_PARAM_PATTERN = '[^/]+?';\r\nconst BASE_PATH_PARSER_OPTIONS = {\r\n    sensitive: false,\r\n    strict: false,\r\n    start: true,\r\n    end: true,\r\n};\r\n// Special Regex characters that must be escaped in static tokens\r\nconst REGEX_CHARS_RE = /[.+*?^${}()[\\]/\\\\]/g;\r\n/**\r\n * Creates a path parser from an array of Segments (a segment is an array of Tokens)\r\n *\r\n * @param segments - array of segments returned by tokenizePath\r\n * @param extraOptions - optional options for the regexp\r\n * @returns a PathParser\r\n */\r\nfunction tokensToParser(segments, extraOptions) {\r\n    const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);\r\n    // the amount of scores is the same as the length of segments except for the root segment \"/\"\r\n    let score = [];\r\n    // the regexp as a string\r\n    let pattern = options.start ? '^' : '';\r\n    // extracted keys\r\n    const keys = [];\r\n    for (const segment of segments) {\r\n        // the root segment needs special treatment\r\n        const segmentScores = segment.length ? [] : [90 /* Root */];\r\n        // allow trailing slash\r\n        if (options.strict && !segment.length)\r\n            pattern += '/';\r\n        for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {\r\n            const token = segment[tokenIndex];\r\n            // resets the score if we are inside a sub segment /:a-other-:b\r\n            let subSegmentScore = 40 /* Segment */ +\r\n                (options.sensitive ? 0.25 /* BonusCaseSensitive */ : 0);\r\n            if (token.type === 0 /* Static */) {\r\n                // prepend the slash if we are starting a new segment\r\n                if (!tokenIndex)\r\n                    pattern += '/';\r\n                pattern += token.value.replace(REGEX_CHARS_RE, '\\\\$&');\r\n                subSegmentScore += 40 /* Static */;\r\n            }\r\n            else if (token.type === 1 /* Param */) {\r\n                const { value, repeatable, optional, regexp } = token;\r\n                keys.push({\r\n                    name: value,\r\n                    repeatable,\r\n                    optional,\r\n                });\r\n                const re = regexp ? regexp : BASE_PARAM_PATTERN;\r\n                // the user provided a custom regexp /:id(\\\\d+)\r\n                if (re !== BASE_PARAM_PATTERN) {\r\n                    subSegmentScore += 10 /* BonusCustomRegExp */;\r\n                    // make sure the regexp is valid before using it\r\n                    try {\r\n                        new RegExp(`(${re})`);\r\n                    }\r\n                    catch (err) {\r\n                        throw new Error(`Invalid custom RegExp for param \"${value}\" (${re}): ` +\r\n                            err.message);\r\n                    }\r\n                }\r\n                // when we repeat we must take care of the repeating leading slash\r\n                let subPattern = repeatable ? `((?:${re})(?:/(?:${re}))*)` : `(${re})`;\r\n                // prepend the slash if we are starting a new segment\r\n                if (!tokenIndex)\r\n                    subPattern = optional ? `(?:/${subPattern})` : '/' + subPattern;\r\n                if (optional)\r\n                    subPattern += '?';\r\n                pattern += subPattern;\r\n                subSegmentScore += 20 /* Dynamic */;\r\n                if (optional)\r\n                    subSegmentScore += -8 /* BonusOptional */;\r\n                if (repeatable)\r\n                    subSegmentScore += -20 /* BonusRepeatable */;\r\n                if (re === '.*')\r\n                    subSegmentScore += -50 /* BonusWildcard */;\r\n            }\r\n            segmentScores.push(subSegmentScore);\r\n        }\r\n        // an empty array like /home/ -> [[{home}], []]\r\n        // if (!segment.length) pattern += '/'\r\n        score.push(segmentScores);\r\n    }\r\n    // only apply the strict bonus to the last score\r\n    if (options.strict && options.end) {\r\n        const i = score.length - 1;\r\n        score[i][score[i].length - 1] += 0.7000000000000001 /* BonusStrict */;\r\n    }\r\n    // TODO: dev only warn double trailing slash\r\n    if (!options.strict)\r\n        pattern += '/?';\r\n    if (options.end)\r\n        pattern += '$';\r\n    // allow paths like /dynamic to only match dynamic or dynamic/... but not dynamic_something_else\r\n    else if (options.strict)\r\n        pattern += '(?:/|$)';\r\n    const re = new RegExp(pattern, options.sensitive ? '' : 'i');\r\n    function parse(path) {\r\n        const match = path.match(re);\r\n        const params = {};\r\n        if (!match)\r\n            return null;\r\n        for (let i = 1; i < match.length; i++) {\r\n            const value = match[i] || '';\r\n            const key = keys[i - 1];\r\n            params[key.name] = value && key.repeatable ? value.split('/') : value;\r\n        }\r\n        return params;\r\n    }\r\n    function stringify(params) {\r\n        let path = '';\r\n        // for optional parameters to allow to be empty\r\n        let avoidDuplicatedSlash = false;\r\n        for (const segment of segments) {\r\n            if (!avoidDuplicatedSlash || !path.endsWith('/'))\r\n                path += '/';\r\n            avoidDuplicatedSlash = false;\r\n            for (const token of segment) {\r\n                if (token.type === 0 /* Static */) {\r\n                    path += token.value;\r\n                }\r\n                else if (token.type === 1 /* Param */) {\r\n                    const { value, repeatable, optional } = token;\r\n                    const param = value in params ? params[value] : '';\r\n                    if (Array.isArray(param) && !repeatable)\r\n                        throw new Error(`Provided param \"${value}\" is an array but it is not repeatable (* or + modifiers)`);\r\n                    const text = Array.isArray(param) ? param.join('/') : param;\r\n                    if (!text) {\r\n                        if (optional) {\r\n                            // remove the last slash as we could be at the end\r\n                            if (path.endsWith('/'))\r\n                                path = path.slice(0, -1);\r\n                            // do not append a slash on the next iteration\r\n                            else\r\n                                avoidDuplicatedSlash = true;\r\n                        }\r\n                        else\r\n                            throw new Error(`Missing required param \"${value}\"`);\r\n                    }\r\n                    path += text;\r\n                }\r\n            }\r\n        }\r\n        return path;\r\n    }\r\n    return {\r\n        re,\r\n        score,\r\n        keys,\r\n        parse,\r\n        stringify,\r\n    };\r\n}\r\n/**\r\n * Compares an array of numbers as used in PathParser.score and returns a\r\n * number. This function can be used to `sort` an array\r\n * @param a - first array of numbers\r\n * @param b - second array of numbers\r\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\r\n * should be sorted first\r\n */\r\nfunction compareScoreArray(a, b) {\r\n    let i = 0;\r\n    while (i < a.length && i < b.length) {\r\n        const diff = b[i] - a[i];\r\n        // only keep going if diff === 0\r\n        if (diff)\r\n            return diff;\r\n        i++;\r\n    }\r\n    // if the last subsegment was Static, the shorter segments should be sorted first\r\n    // otherwise sort the longest segment first\r\n    if (a.length < b.length) {\r\n        return a.length === 1 && a[0] === 40 /* Static */ + 40 /* Segment */\r\n            ? -1\r\n            : 1;\r\n    }\r\n    else if (a.length > b.length) {\r\n        return b.length === 1 && b[0] === 40 /* Static */ + 40 /* Segment */\r\n            ? 1\r\n            : -1;\r\n    }\r\n    return 0;\r\n}\r\n/**\r\n * Compare function that can be used with `sort` to sort an array of PathParser\r\n * @param a - first PathParser\r\n * @param b - second PathParser\r\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\r\n */\r\nfunction comparePathParserScore(a, b) {\r\n    let i = 0;\r\n    const aScore = a.score;\r\n    const bScore = b.score;\r\n    while (i < aScore.length && i < bScore.length) {\r\n        const comp = compareScoreArray(aScore[i], bScore[i]);\r\n        // do not return if both are equal\r\n        if (comp)\r\n            return comp;\r\n        i++;\r\n    }\r\n    // if a and b share the same score entries but b has more, sort b first\r\n    return bScore.length - aScore.length;\r\n    // this is the ternary version\r\n    // return aScore.length < bScore.length\r\n    //   ? 1\r\n    //   : aScore.length > bScore.length\r\n    //   ? -1\r\n    //   : 0\r\n}\n\nconst ROOT_TOKEN = {\r\n    type: 0 /* Static */,\r\n    value: '',\r\n};\r\nconst VALID_PARAM_RE = /[a-zA-Z0-9_]/;\r\n// After some profiling, the cache seems to be unnecessary because tokenizePath\r\n// (the slowest part of adding a route) is very fast\r\n// const tokenCache = new Map<string, Token[][]>()\r\nfunction tokenizePath(path) {\r\n    if (!path)\r\n        return [[]];\r\n    if (path === '/')\r\n        return [[ROOT_TOKEN]];\r\n    if (!path.startsWith('/')) {\r\n        throw new Error((process.env.NODE_ENV !== 'production')\r\n            ? `Route paths should start with a \"/\": \"${path}\" should be \"/${path}\".`\r\n            : `Invalid path \"${path}\"`);\r\n    }\r\n    // if (tokenCache.has(path)) return tokenCache.get(path)!\r\n    function crash(message) {\r\n        throw new Error(`ERR (${state})/\"${buffer}\": ${message}`);\r\n    }\r\n    let state = 0 /* Static */;\r\n    let previousState = state;\r\n    const tokens = [];\r\n    // the segment will always be valid because we get into the initial state\r\n    // with the leading /\r\n    let segment;\r\n    function finalizeSegment() {\r\n        if (segment)\r\n            tokens.push(segment);\r\n        segment = [];\r\n    }\r\n    // index on the path\r\n    let i = 0;\r\n    // char at index\r\n    let char;\r\n    // buffer of the value read\r\n    let buffer = '';\r\n    // custom regexp for a param\r\n    let customRe = '';\r\n    function consumeBuffer() {\r\n        if (!buffer)\r\n            return;\r\n        if (state === 0 /* Static */) {\r\n            segment.push({\r\n                type: 0 /* Static */,\r\n                value: buffer,\r\n            });\r\n        }\r\n        else if (state === 1 /* Param */ ||\r\n            state === 2 /* ParamRegExp */ ||\r\n            state === 3 /* ParamRegExpEnd */) {\r\n            if (segment.length > 1 && (char === '*' || char === '+'))\r\n                crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);\r\n            segment.push({\r\n                type: 1 /* Param */,\r\n                value: buffer,\r\n                regexp: customRe,\r\n                repeatable: char === '*' || char === '+',\r\n                optional: char === '*' || char === '?',\r\n            });\r\n        }\r\n        else {\r\n            crash('Invalid state to consume buffer');\r\n        }\r\n        buffer = '';\r\n    }\r\n    function addCharToBuffer() {\r\n        buffer += char;\r\n    }\r\n    while (i < path.length) {\r\n        char = path[i++];\r\n        if (char === '\\\\' && state !== 2 /* ParamRegExp */) {\r\n            previousState = state;\r\n            state = 4 /* EscapeNext */;\r\n            continue;\r\n        }\r\n        switch (state) {\r\n            case 0 /* Static */:\r\n                if (char === '/') {\r\n                    if (buffer) {\r\n                        consumeBuffer();\r\n                    }\r\n                    finalizeSegment();\r\n                }\r\n                else if (char === ':') {\r\n                    consumeBuffer();\r\n                    state = 1 /* Param */;\r\n                }\r\n                else {\r\n                    addCharToBuffer();\r\n                }\r\n                break;\r\n            case 4 /* EscapeNext */:\r\n                addCharToBuffer();\r\n                state = previousState;\r\n                break;\r\n            case 1 /* Param */:\r\n                if (char === '(') {\r\n                    state = 2 /* ParamRegExp */;\r\n                }\r\n                else if (VALID_PARAM_RE.test(char)) {\r\n                    addCharToBuffer();\r\n                }\r\n                else {\r\n                    consumeBuffer();\r\n                    state = 0 /* Static */;\r\n                    // go back one character if we were not modifying\r\n                    if (char !== '*' && char !== '?' && char !== '+')\r\n                        i--;\r\n                }\r\n                break;\r\n            case 2 /* ParamRegExp */:\r\n                // TODO: is it worth handling nested regexp? like :p(?:prefix_([^/]+)_suffix)\r\n                // it already works by escaping the closing )\r\n                // https://paths.esm.dev/?p=AAMeJbiAwQEcDKbAoAAkP60PG2R6QAvgNaA6AFACM2ABuQBB#\r\n                // is this really something people need since you can also write\r\n                // /prefix_:p()_suffix\r\n                if (char === ')') {\r\n                    // handle the escaped )\r\n                    if (customRe[customRe.length - 1] == '\\\\')\r\n                        customRe = customRe.slice(0, -1) + char;\r\n                    else\r\n                        state = 3 /* ParamRegExpEnd */;\r\n                }\r\n                else {\r\n                    customRe += char;\r\n                }\r\n                break;\r\n            case 3 /* ParamRegExpEnd */:\r\n                // same as finalizing a param\r\n                consumeBuffer();\r\n                state = 0 /* Static */;\r\n                // go back one character if we were not modifying\r\n                if (char !== '*' && char !== '?' && char !== '+')\r\n                    i--;\r\n                customRe = '';\r\n                break;\r\n            default:\r\n                crash('Unknown state');\r\n                break;\r\n        }\r\n    }\r\n    if (state === 2 /* ParamRegExp */)\r\n        crash(`Unfinished custom RegExp for param \"${buffer}\"`);\r\n    consumeBuffer();\r\n    finalizeSegment();\r\n    // tokenCache.set(path, tokens)\r\n    return tokens;\r\n}\n\nfunction createRouteRecordMatcher(record, parent, options) {\r\n    const parser = tokensToParser(tokenizePath(record.path), options);\r\n    // warn against params with the same name\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        const existingKeys = new Set();\r\n        for (const key of parser.keys) {\r\n            if (existingKeys.has(key.name))\r\n                warn(`Found duplicated params with name \"${key.name}\" for path \"${record.path}\". Only the last one will be available on \"$route.params\".`);\r\n            existingKeys.add(key.name);\r\n        }\r\n    }\r\n    const matcher = assign(parser, {\r\n        record,\r\n        parent,\r\n        // these needs to be populated by the parent\r\n        children: [],\r\n        alias: [],\r\n    });\r\n    if (parent) {\r\n        // both are aliases or both are not aliases\r\n        // we don't want to mix them because the order is used when\r\n        // passing originalRecord in Matcher.addRoute\r\n        if (!matcher.record.aliasOf === !parent.record.aliasOf)\r\n            parent.children.push(matcher);\r\n    }\r\n    return matcher;\r\n}\n\n/**\r\n * Creates a Router Matcher.\r\n *\r\n * @internal\r\n * @param routes - array of initial routes\r\n * @param globalOptions - global route options\r\n */\r\nfunction createRouterMatcher(routes, globalOptions) {\r\n    // normalized ordered array of matchers\r\n    const matchers = [];\r\n    const matcherMap = new Map();\r\n    globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);\r\n    function getRecordMatcher(name) {\r\n        return matcherMap.get(name);\r\n    }\r\n    function addRoute(record, parent, originalRecord) {\r\n        // used later on to remove by name\r\n        let isRootAdd = !originalRecord;\r\n        let mainNormalizedRecord = normalizeRouteRecord(record);\r\n        // we might be the child of an alias\r\n        mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;\r\n        const options = mergeOptions(globalOptions, record);\r\n        // generate an array of records to correctly handle aliases\r\n        const normalizedRecords = [\r\n            mainNormalizedRecord,\r\n        ];\r\n        if ('alias' in record) {\r\n            const aliases = typeof record.alias === 'string' ? [record.alias] : record.alias;\r\n            for (const alias of aliases) {\r\n                normalizedRecords.push(assign({}, mainNormalizedRecord, {\r\n                    // this allows us to hold a copy of the `components` option\r\n                    // so that async components cache is hold on the original record\r\n                    components: originalRecord\r\n                        ? originalRecord.record.components\r\n                        : mainNormalizedRecord.components,\r\n                    path: alias,\r\n                    // we might be the child of an alias\r\n                    aliasOf: originalRecord\r\n                        ? originalRecord.record\r\n                        : mainNormalizedRecord,\r\n                }));\r\n            }\r\n        }\r\n        let matcher;\r\n        let originalMatcher;\r\n        for (const normalizedRecord of normalizedRecords) {\r\n            let { path } = normalizedRecord;\r\n            // Build up the path for nested routes if the child isn't an absolute\r\n            // route. Only add the / delimiter if the child path isn't empty and if the\r\n            // parent path doesn't have a trailing slash\r\n            if (parent && path[0] !== '/') {\r\n                let parentPath = parent.record.path;\r\n                let connectingSlash = parentPath[parentPath.length - 1] === '/' ? '' : '/';\r\n                normalizedRecord.path =\r\n                    parent.record.path + (path && connectingSlash + path);\r\n            }\r\n            if ((process.env.NODE_ENV !== 'production') && normalizedRecord.path === '*') {\r\n                throw new Error('Catch all routes (\"*\") must now be defined using a param with a custom regexp.\\n' +\r\n                    'See more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.');\r\n            }\r\n            // create the object before hand so it can be passed to children\r\n            matcher = createRouteRecordMatcher(normalizedRecord, parent, options);\r\n            if ((process.env.NODE_ENV !== 'production') && parent && path[0] === '/')\r\n                checkMissingParamsInAbsolutePath(matcher, parent);\r\n            // if we are an alias we must tell the original record that we exist\r\n            // so we can be removed\r\n            if (originalRecord) {\r\n                originalRecord.alias.push(matcher);\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    checkSameParams(originalRecord, matcher);\r\n                }\r\n            }\r\n            else {\r\n                // otherwise, the first record is the original and others are aliases\r\n                originalMatcher = originalMatcher || matcher;\r\n                if (originalMatcher !== matcher)\r\n                    originalMatcher.alias.push(matcher);\r\n                // remove the route if named and only for the top record (avoid in nested calls)\r\n                // this works because the original record is the first one\r\n                if (isRootAdd && record.name && !isAliasRecord(matcher))\r\n                    removeRoute(record.name);\r\n            }\r\n            if ('children' in mainNormalizedRecord) {\r\n                let children = mainNormalizedRecord.children;\r\n                for (let i = 0; i < children.length; i++) {\r\n                    addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);\r\n                }\r\n            }\r\n            // if there was no original record, then the first one was not an alias and all\r\n            // other alias (if any) need to reference this record when adding children\r\n            originalRecord = originalRecord || matcher;\r\n            // TODO: add normalized records for more flexibility\r\n            // if (parent && isAliasRecord(originalRecord)) {\r\n            //   parent.children.push(originalRecord)\r\n            // }\r\n            insertMatcher(matcher);\r\n        }\r\n        return originalMatcher\r\n            ? () => {\r\n                // since other matchers are aliases, they should be removed by the original matcher\r\n                removeRoute(originalMatcher);\r\n            }\r\n            : noop;\r\n    }\r\n    function removeRoute(matcherRef) {\r\n        if (isRouteName(matcherRef)) {\r\n            const matcher = matcherMap.get(matcherRef);\r\n            if (matcher) {\r\n                matcherMap.delete(matcherRef);\r\n                matchers.splice(matchers.indexOf(matcher), 1);\r\n                matcher.children.forEach(removeRoute);\r\n                matcher.alias.forEach(removeRoute);\r\n            }\r\n        }\r\n        else {\r\n            let index = matchers.indexOf(matcherRef);\r\n            if (index > -1) {\r\n                matchers.splice(index, 1);\r\n                if (matcherRef.record.name)\r\n                    matcherMap.delete(matcherRef.record.name);\r\n                matcherRef.children.forEach(removeRoute);\r\n                matcherRef.alias.forEach(removeRoute);\r\n            }\r\n        }\r\n    }\r\n    function getRoutes() {\r\n        return matchers;\r\n    }\r\n    function insertMatcher(matcher) {\r\n        let i = 0;\r\n        // console.log('i is', { i })\r\n        while (i < matchers.length &&\r\n            comparePathParserScore(matcher, matchers[i]) >= 0)\r\n            i++;\r\n        // console.log('END i is', { i })\r\n        // while (i < matchers.length && matcher.score <= matchers[i].score) i++\r\n        matchers.splice(i, 0, matcher);\r\n        // only add the original record to the name map\r\n        if (matcher.record.name && !isAliasRecord(matcher))\r\n            matcherMap.set(matcher.record.name, matcher);\r\n    }\r\n    function resolve(location, currentLocation) {\r\n        let matcher;\r\n        let params = {};\r\n        let path;\r\n        let name;\r\n        if ('name' in location && location.name) {\r\n            matcher = matcherMap.get(location.name);\r\n            if (!matcher)\r\n                throw createRouterError(1 /* MATCHER_NOT_FOUND */, {\r\n                    location,\r\n                });\r\n            name = matcher.record.name;\r\n            params = assign(\r\n            // paramsFromLocation is a new object\r\n            paramsFromLocation(currentLocation.params, \r\n            // only keep params that exist in the resolved location\r\n            // TODO: only keep optional params coming from a parent record\r\n            matcher.keys.filter(k => !k.optional).map(k => k.name)), location.params);\r\n            // throws if cannot be stringified\r\n            path = matcher.stringify(params);\r\n        }\r\n        else if ('path' in location) {\r\n            // no need to resolve the path with the matcher as it was provided\r\n            // this also allows the user to control the encoding\r\n            path = location.path;\r\n            if ((process.env.NODE_ENV !== 'production') && !path.startsWith('/')) {\r\n                warn(`The Matcher cannot resolve relative paths but received \"${path}\". Unless you directly called \\`matcher.resolve(\"${path}\")\\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-router-next.`);\r\n            }\r\n            matcher = matchers.find(m => m.re.test(path));\r\n            // matcher should have a value after the loop\r\n            if (matcher) {\r\n                // TODO: dev warning of unused params if provided\r\n                // we know the matcher works because we tested the regexp\r\n                params = matcher.parse(path);\r\n                name = matcher.record.name;\r\n            }\r\n            // location is a relative path\r\n        }\r\n        else {\r\n            // match by name or path of current route\r\n            matcher = currentLocation.name\r\n                ? matcherMap.get(currentLocation.name)\r\n                : matchers.find(m => m.re.test(currentLocation.path));\r\n            if (!matcher)\r\n                throw createRouterError(1 /* MATCHER_NOT_FOUND */, {\r\n                    location,\r\n                    currentLocation,\r\n                });\r\n            name = matcher.record.name;\r\n            // since we are navigating to the same location, we don't need to pick the\r\n            // params like when `name` is provided\r\n            params = assign({}, currentLocation.params, location.params);\r\n            path = matcher.stringify(params);\r\n        }\r\n        const matched = [];\r\n        let parentMatcher = matcher;\r\n        while (parentMatcher) {\r\n            // reversed order so parents are at the beginning\r\n            matched.unshift(parentMatcher.record);\r\n            parentMatcher = parentMatcher.parent;\r\n        }\r\n        return {\r\n            name,\r\n            path,\r\n            params,\r\n            matched,\r\n            meta: mergeMetaFields(matched),\r\n        };\r\n    }\r\n    // add initial routes\r\n    routes.forEach(route => addRoute(route));\r\n    return { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher };\r\n}\r\nfunction paramsFromLocation(params, keys) {\r\n    let newParams = {};\r\n    for (let key of keys) {\r\n        if (key in params)\r\n            newParams[key] = params[key];\r\n    }\r\n    return newParams;\r\n}\r\n/**\r\n * Normalizes a RouteRecordRaw. Creates a copy\r\n *\r\n * @param record\r\n * @returns the normalized version\r\n */\r\nfunction normalizeRouteRecord(record) {\r\n    return {\r\n        path: record.path,\r\n        redirect: record.redirect,\r\n        name: record.name,\r\n        meta: record.meta || {},\r\n        aliasOf: undefined,\r\n        beforeEnter: record.beforeEnter,\r\n        props: normalizeRecordProps(record),\r\n        children: record.children || [],\r\n        instances: {},\r\n        leaveGuards: new Set(),\r\n        updateGuards: new Set(),\r\n        enterCallbacks: {},\r\n        components: 'components' in record\r\n            ? record.components || {}\r\n            : { default: record.component },\r\n    };\r\n}\r\n/**\r\n * Normalize the optional `props` in a record to always be an object similar to\r\n * components. Also accept a boolean for components.\r\n * @param record\r\n */\r\nfunction normalizeRecordProps(record) {\r\n    const propsObject = {};\r\n    // props does not exist on redirect records but we can set false directly\r\n    const props = record.props || false;\r\n    if ('component' in record) {\r\n        propsObject.default = props;\r\n    }\r\n    else {\r\n        // NOTE: we could also allow a function to be applied to every component.\r\n        // Would need user feedback for use cases\r\n        for (let name in record.components)\r\n            propsObject[name] = typeof props === 'boolean' ? props : props[name];\r\n    }\r\n    return propsObject;\r\n}\r\n/**\r\n * Checks if a record or any of its parent is an alias\r\n * @param record\r\n */\r\nfunction isAliasRecord(record) {\r\n    while (record) {\r\n        if (record.record.aliasOf)\r\n            return true;\r\n        record = record.parent;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Merge meta fields of an array of records\r\n *\r\n * @param matched - array of matched records\r\n */\r\nfunction mergeMetaFields(matched) {\r\n    return matched.reduce((meta, record) => assign(meta, record.meta), {});\r\n}\r\nfunction mergeOptions(defaults, partialOptions) {\r\n    let options = {};\r\n    for (let key in defaults) {\r\n        options[key] =\r\n            key in partialOptions ? partialOptions[key] : defaults[key];\r\n    }\r\n    return options;\r\n}\r\nfunction isSameParam(a, b) {\r\n    return (a.name === b.name &&\r\n        a.optional === b.optional &&\r\n        a.repeatable === b.repeatable);\r\n}\r\nfunction checkSameParams(a, b) {\r\n    for (let key of a.keys) {\r\n        if (!b.keys.find(isSameParam.bind(null, key)))\r\n            return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" should have the exact same param named \"${key.name}\"`);\r\n    }\r\n    for (let key of b.keys) {\r\n        if (!a.keys.find(isSameParam.bind(null, key)))\r\n            return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" should have the exact same param named \"${key.name}\"`);\r\n    }\r\n}\r\nfunction checkMissingParamsInAbsolutePath(record, parent) {\r\n    for (let key of parent.keys) {\r\n        if (!record.keys.find(isSameParam.bind(null, key)))\r\n            return warn(`Absolute path \"${record.record.path}\" should have the exact same param named \"${key.name}\" as its parent \"${parent.record.path}\".`);\r\n    }\r\n}\n\n/**\r\n * Encoding Rules ␣ = Space Path: ␣ \" < > # ? { } Query: ␣ \" < > # & = Hash: ␣ \"\r\n * < > `\r\n *\r\n * On top of that, the RFC3986 (https://tools.ietf.org/html/rfc3986#section-2.2)\r\n * defines some extra characters to be encoded. Most browsers do not encode them\r\n * in encodeURI https://github.com/whatwg/url/issues/369, so it may be safer to\r\n * also encode `!'()*`. Leaving unencoded only ASCII alphanumeric(`a-zA-Z0-9`)\r\n * plus `-._~`. This extra safety should be applied to query by patching the\r\n * string returned by encodeURIComponent encodeURI also encodes `[\\]^`. `\\`\r\n * should be encoded to avoid ambiguity. Browsers (IE, FF, C) transform a `\\`\r\n * into a `/` if directly typed in. The _backtick_ (`````) should also be\r\n * encoded everywhere because some browsers like FF encode it when directly\r\n * written while others don't. Safari and IE don't encode ``\"<>{}``` in hash.\r\n */\r\n// const EXTRA_RESERVED_RE = /[!'()*]/g\r\n// const encodeReservedReplacer = (c: string) => '%' + c.charCodeAt(0).toString(16)\r\nconst HASH_RE = /#/g; // %23\r\nconst AMPERSAND_RE = /&/g; // %26\r\nconst SLASH_RE = /\\//g; // %2F\r\nconst EQUAL_RE = /=/g; // %3D\r\nconst IM_RE = /\\?/g; // %3F\r\nconst PLUS_RE = /\\+/g; // %2B\r\n/**\r\n * NOTE: It's not clear to me if we should encode the + symbol in queries, it\r\n * seems to be less flexible than not doing so and I can't find out the legacy\r\n * systems requiring this for regular requests like text/html. In the standard,\r\n * the encoding of the plus character is only mentioned for\r\n * application/x-www-form-urlencoded\r\n * (https://url.spec.whatwg.org/#urlencoded-parsing) and most browsers seems lo\r\n * leave the plus character as is in queries. To be more flexible, we allow the\r\n * plus character on the query but it can also be manually encoded by the user.\r\n *\r\n * Resources:\r\n * - https://url.spec.whatwg.org/#urlencoded-parsing\r\n * - https://stackoverflow.com/questions/1634271/url-encoding-the-space-character-or-20\r\n */\r\nconst ENC_BRACKET_OPEN_RE = /%5B/g; // [\r\nconst ENC_BRACKET_CLOSE_RE = /%5D/g; // ]\r\nconst ENC_CARET_RE = /%5E/g; // ^\r\nconst ENC_BACKTICK_RE = /%60/g; // `\r\nconst ENC_CURLY_OPEN_RE = /%7B/g; // {\r\nconst ENC_PIPE_RE = /%7C/g; // |\r\nconst ENC_CURLY_CLOSE_RE = /%7D/g; // }\r\nconst ENC_SPACE_RE = /%20/g; // }\r\n/**\r\n * Encode characters that need to be encoded on the path, search and hash\r\n * sections of the URL.\r\n *\r\n * @internal\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction commonEncode(text) {\r\n    return encodeURI('' + text)\r\n        .replace(ENC_PIPE_RE, '|')\r\n        .replace(ENC_BRACKET_OPEN_RE, '[')\r\n        .replace(ENC_BRACKET_CLOSE_RE, ']');\r\n}\r\n/**\r\n * Encode characters that need to be encoded on the hash section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodeHash(text) {\r\n    return commonEncode(text)\r\n        .replace(ENC_CURLY_OPEN_RE, '{')\r\n        .replace(ENC_CURLY_CLOSE_RE, '}')\r\n        .replace(ENC_CARET_RE, '^');\r\n}\r\n/**\r\n * Encode characters that need to be encoded query values on the query\r\n * section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodeQueryValue(text) {\r\n    return (commonEncode(text)\r\n        // Encode the space as +, encode the + to differentiate it from the space\r\n        .replace(PLUS_RE, '%2B')\r\n        .replace(ENC_SPACE_RE, '+')\r\n        .replace(HASH_RE, '%23')\r\n        .replace(AMPERSAND_RE, '%26')\r\n        .replace(ENC_BACKTICK_RE, '`')\r\n        .replace(ENC_CURLY_OPEN_RE, '{')\r\n        .replace(ENC_CURLY_CLOSE_RE, '}')\r\n        .replace(ENC_CARET_RE, '^'));\r\n}\r\n/**\r\n * Like `encodeQueryValue` but also encodes the `=` character.\r\n *\r\n * @param text - string to encode\r\n */\r\nfunction encodeQueryKey(text) {\r\n    return encodeQueryValue(text).replace(EQUAL_RE, '%3D');\r\n}\r\n/**\r\n * Encode characters that need to be encoded on the path section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodePath(text) {\r\n    return commonEncode(text).replace(HASH_RE, '%23').replace(IM_RE, '%3F');\r\n}\r\n/**\r\n * Encode characters that need to be encoded on the path section of the URL as a\r\n * param. This function encodes everything {@link encodePath} does plus the\r\n * slash (`/`) character.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodeParam(text) {\r\n    return encodePath(text).replace(SLASH_RE, '%2F');\r\n}\r\n/**\r\n * Decode text using `decodeURIComponent`. Returns the original text if it\r\n * fails.\r\n *\r\n * @param text - string to decode\r\n * @returns decoded string\r\n */\r\nfunction decode(text) {\r\n    try {\r\n        return decodeURIComponent('' + text);\r\n    }\r\n    catch (err) {\r\n        (process.env.NODE_ENV !== 'production') && warn(`Error decoding \"${text}\". Using original value`);\r\n    }\r\n    return '' + text;\r\n}\n\n/**\r\n * Transforms a queryString into a {@link LocationQuery} object. Accept both, a\r\n * version with the leading `?` and without Should work as URLSearchParams\r\n\n * @internal\r\n *\r\n * @param search - search string to parse\r\n * @returns a query object\r\n */\r\nfunction parseQuery(search) {\r\n    const query = {};\r\n    // avoid creating an object with an empty key and empty value\r\n    // because of split('&')\r\n    if (search === '' || search === '?')\r\n        return query;\r\n    const hasLeadingIM = search[0] === '?';\r\n    const searchParams = (hasLeadingIM ? search.slice(1) : search).split('&');\r\n    for (let i = 0; i < searchParams.length; ++i) {\r\n        // pre decode the + into space\r\n        const searchParam = searchParams[i].replace(PLUS_RE, ' ');\r\n        // allow the = character\r\n        let eqPos = searchParam.indexOf('=');\r\n        let key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));\r\n        let value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));\r\n        if (key in query) {\r\n            // an extra variable for ts types\r\n            let currentValue = query[key];\r\n            if (!Array.isArray(currentValue)) {\r\n                currentValue = query[key] = [currentValue];\r\n            }\r\n            currentValue.push(value);\r\n        }\r\n        else {\r\n            query[key] = value;\r\n        }\r\n    }\r\n    return query;\r\n}\r\n/**\r\n * Stringifies a {@link LocationQueryRaw} object. Like `URLSearchParams`, it\r\n * doesn't prepend a `?`\r\n *\r\n * @internal\r\n *\r\n * @param query - query object to stringify\r\n * @returns string version of the query without the leading `?`\r\n */\r\nfunction stringifyQuery(query) {\r\n    let search = '';\r\n    for (let key in query) {\r\n        if (search.length)\r\n            search += '&';\r\n        const value = query[key];\r\n        key = encodeQueryKey(key);\r\n        if (value == null) {\r\n            // only null adds the value\r\n            if (value !== undefined)\r\n                search += key;\r\n            continue;\r\n        }\r\n        // keep null values\r\n        let values = Array.isArray(value)\r\n            ? value.map(v => v && encodeQueryValue(v))\r\n            : [value && encodeQueryValue(value)];\r\n        for (let i = 0; i < values.length; i++) {\r\n            // only append & with i > 0\r\n            search += (i ? '&' : '') + key;\r\n            if (values[i] != null)\r\n                search += ('=' + values[i]);\r\n        }\r\n    }\r\n    return search;\r\n}\r\n/**\r\n * Transforms a {@link LocationQueryRaw} into a {@link LocationQuery} by casting\r\n * numbers into strings, removing keys with an undefined value and replacing\r\n * undefined with null in arrays\r\n *\r\n * @param query - query object to normalize\r\n * @returns a normalized query object\r\n */\r\nfunction normalizeQuery(query) {\r\n    const normalizedQuery = {};\r\n    for (let key in query) {\r\n        let value = query[key];\r\n        if (value !== undefined) {\r\n            normalizedQuery[key] = Array.isArray(value)\r\n                ? value.map(v => (v == null ? null : '' + v))\r\n                : value == null\r\n                    ? value\r\n                    : '' + value;\r\n        }\r\n    }\r\n    return normalizedQuery;\r\n}\n\n/**\r\n * Create a list of callbacks that can be reset. Used to create before and after navigation guards list\r\n */\r\nfunction useCallbacks() {\r\n    let handlers = [];\r\n    function add(handler) {\r\n        handlers.push(handler);\r\n        return () => {\r\n            const i = handlers.indexOf(handler);\r\n            if (i > -1)\r\n                handlers.splice(i, 1);\r\n        };\r\n    }\r\n    function reset() {\r\n        handlers = [];\r\n    }\r\n    return {\r\n        add,\r\n        list: () => handlers,\r\n        reset,\r\n    };\r\n}\n\nfunction registerGuard(record, name, guard) {\r\n    const removeFromList = () => {\r\n        record[name].delete(guard);\r\n    };\r\n    onUnmounted(removeFromList);\r\n    onDeactivated(removeFromList);\r\n    onActivated(() => {\r\n        record[name].add(guard);\r\n    });\r\n    record[name].add(guard);\r\n}\r\n/**\r\n * Add a navigation guard that triggers whenever the component for the current\r\n * location is about to be left. Similar to {@link beforeRouteLeave} but can be\r\n * used in any component. The guard is removed when the component is unmounted.\r\n *\r\n * @param leaveGuard - {@link NavigationGuard}\r\n */\r\nfunction onBeforeRouteLeave(leaveGuard) {\r\n    if ((process.env.NODE_ENV !== 'production') && !getCurrentInstance()) {\r\n        warn('getCurrentInstance() returned null. onBeforeRouteLeave() must be called at the top of a setup function');\r\n        return;\r\n    }\r\n    const activeRecord = inject(matchedRouteKey, {}).value;\r\n    if (!activeRecord) {\r\n        (process.env.NODE_ENV !== 'production') &&\r\n            warn('No active route record was found. Are you missing a <router-view> component?');\r\n        return;\r\n    }\r\n    registerGuard(activeRecord, 'leaveGuards', leaveGuard);\r\n}\r\n/**\r\n * Add a navigation guard that triggers whenever the current location is about\r\n * to be updated. Similar to {@link beforeRouteUpdate} but can be used in any\r\n * component. The guard is removed when the component is unmounted.\r\n *\r\n * @param updateGuard - {@link NavigationGuard}\r\n */\r\nfunction onBeforeRouteUpdate(updateGuard) {\r\n    if ((process.env.NODE_ENV !== 'production') && !getCurrentInstance()) {\r\n        warn('getCurrentInstance() returned null. onBeforeRouteUpdate() must be called at the top of a setup function');\r\n        return;\r\n    }\r\n    const activeRecord = inject(matchedRouteKey, {}).value;\r\n    if (!activeRecord) {\r\n        (process.env.NODE_ENV !== 'production') &&\r\n            warn('No active route record was found. Are you missing a <router-view> component?');\r\n        return;\r\n    }\r\n    registerGuard(activeRecord, 'updateGuards', updateGuard);\r\n}\r\nfunction guardToPromiseFn(guard, to, from, record, name) {\r\n    // keep a reference to the enterCallbackArray to prevent pushing callbacks if a new navigation took place\r\n    const enterCallbackArray = record &&\r\n        // name is defined if record is because of the function overload\r\n        (record.enterCallbacks[name] = record.enterCallbacks[name] || []);\r\n    return () => new Promise((resolve, reject) => {\r\n        const next = (valid) => {\r\n            if (valid === false)\r\n                reject(createRouterError(4 /* NAVIGATION_ABORTED */, {\r\n                    from,\r\n                    to,\r\n                }));\r\n            else if (valid instanceof Error) {\r\n                reject(valid);\r\n            }\r\n            else if (isRouteLocation(valid)) {\r\n                reject(createRouterError(2 /* NAVIGATION_GUARD_REDIRECT */, {\r\n                    from: to,\r\n                    to: valid,\r\n                }));\r\n            }\r\n            else {\r\n                if (enterCallbackArray &&\r\n                    // since enterCallbackArray is truthy, both record and name also are\r\n                    record.enterCallbacks[name] === enterCallbackArray &&\r\n                    typeof valid === 'function')\r\n                    enterCallbackArray.push(valid);\r\n                resolve();\r\n            }\r\n        };\r\n        // wrapping with Promise.resolve allows it to work with both async and sync guards\r\n        const guardReturn = guard.call(record && record.instances[name], to, from, (process.env.NODE_ENV !== 'production') ? canOnlyBeCalledOnce(next, to, from) : next);\r\n        let guardCall = Promise.resolve(guardReturn);\r\n        if (guard.length < 3)\r\n            guardCall = guardCall.then(next);\r\n        if ((process.env.NODE_ENV !== 'production') && guard.length > 2) {\r\n            const message = `The \"next\" callback was never called inside of ${guard.name ? '\"' + guard.name + '\"' : ''}:\\n${guard.toString()}\\n. If you are returning a value instead of calling \"next\", make sure to remove the \"next\" parameter from your function.`;\r\n            if (typeof guardReturn === 'object' && 'then' in guardReturn) {\r\n                guardCall = guardCall.then(resolvedValue => {\r\n                    // @ts-ignore: _called is added at canOnlyBeCalledOnce\r\n                    if (!next._called) {\r\n                        warn(message);\r\n                        return Promise.reject(new Error('Invalid navigation guard'));\r\n                    }\r\n                    return resolvedValue;\r\n                });\r\n                // TODO: test me!\r\n            }\r\n            else if (guardReturn !== undefined) {\r\n                // @ts-ignore: _called is added at canOnlyBeCalledOnce\r\n                if (!next._called) {\r\n                    warn(message);\r\n                    reject(new Error('Invalid navigation guard'));\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        guardCall.catch(err => reject(err));\r\n    });\r\n}\r\nfunction canOnlyBeCalledOnce(next, to, from) {\r\n    let called = 0;\r\n    return function () {\r\n        if (called++ === 1)\r\n            warn(`The \"next\" callback was called more than once in one navigation guard when going from \"${from.fullPath}\" to \"${to.fullPath}\". It should be called exactly one time in each navigation guard. This will fail in production.`);\r\n        // @ts-ignore: we put it in the original one because it's easier to check\r\n        next._called = true;\r\n        if (called === 1)\r\n            next.apply(null, arguments);\r\n    };\r\n}\r\nfunction extractComponentsGuards(matched, guardType, to, from) {\r\n    const guards = [];\r\n    for (const record of matched) {\r\n        for (const name in record.components) {\r\n            let rawComponent = record.components[name];\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                if (!rawComponent ||\r\n                    (typeof rawComponent !== 'object' &&\r\n                        typeof rawComponent !== 'function')) {\r\n                    warn(`Component \"${name}\" in record with path \"${record.path}\" is not` +\r\n                        ` a valid component. Received \"${String(rawComponent)}\".`);\r\n                    // throw to ensure we stop here but warn to ensure the message isn't\r\n                    // missed by the user\r\n                    throw new Error('Invalid route component');\r\n                }\r\n                else if ('then' in rawComponent) {\r\n                    // warn if user wrote import('/component.vue') instead of () =>\r\n                    // import('./component.vue')\r\n                    warn(`Component \"${name}\" in record with path \"${record.path}\" is a ` +\r\n                        `Promise instead of a function that returns a Promise. Did you ` +\r\n                        `write \"import('./MyPage.vue')\" instead of ` +\r\n                        `\"() => import('./MyPage.vue')\" ? This will break in ` +\r\n                        `production if not fixed.`);\r\n                    let promise = rawComponent;\r\n                    rawComponent = () => promise;\r\n                }\r\n                else if (rawComponent.__asyncLoader &&\r\n                    // warn only once per component\r\n                    !rawComponent.__warnedDefineAsync) {\r\n                    rawComponent.__warnedDefineAsync = true;\r\n                    warn(`Component \"${name}\" in record with path \"${record.path}\" is defined ` +\r\n                        `using \"defineAsyncComponent()\". ` +\r\n                        `Write \"() => import('./MyPage.vue')\" instead of ` +\r\n                        `\"defineAsyncComponent(() => import('./MyPage.vue'))\".`);\r\n                }\r\n            }\r\n            // skip update and leave guards if the route component is not mounted\r\n            if (guardType !== 'beforeRouteEnter' && !record.instances[name])\r\n                continue;\r\n            if (isRouteComponent(rawComponent)) {\r\n                // __vccOpts is added by vue-class-component and contain the regular options\r\n                let options = rawComponent.__vccOpts || rawComponent;\r\n                const guard = options[guardType];\r\n                guard && guards.push(guardToPromiseFn(guard, to, from, record, name));\r\n            }\r\n            else {\r\n                // start requesting the chunk already\r\n                let componentPromise = rawComponent();\r\n                if ((process.env.NODE_ENV !== 'production') && !('catch' in componentPromise)) {\r\n                    warn(`Component \"${name}\" in record with path \"${record.path}\" is a function that does not return a Promise. If you were passing a functional component, make sure to add a \"displayName\" to the component. This will break in production if not fixed.`);\r\n                    componentPromise = Promise.resolve(componentPromise);\r\n                }\r\n                else {\r\n                    // display the error if any\r\n                    componentPromise = componentPromise.catch((process.env.NODE_ENV !== 'production') ? err => err && warn(err) : console.error);\r\n                }\r\n                guards.push(() => componentPromise.then(resolved => {\r\n                    if (!resolved)\r\n                        return Promise.reject(new Error(`Couldn't resolve component \"${name}\" at \"${record.path}\"`));\r\n                    const resolvedComponent = isESModule(resolved)\r\n                        ? resolved.default\r\n                        : resolved;\r\n                    // replace the function with the resolved component\r\n                    record.components[name] = resolvedComponent;\r\n                    // @ts-ignore: the options types are not propagated to Component\r\n                    const guard = resolvedComponent[guardType];\r\n                    return guard && guardToPromiseFn(guard, to, from, record, name)();\r\n                }));\r\n            }\r\n        }\r\n    }\r\n    return guards;\r\n}\r\n/**\r\n * Allows differentiating lazy components from functional components and vue-class-component\r\n * @param component\r\n */\r\nfunction isRouteComponent(component) {\r\n    return (typeof component === 'object' ||\r\n        'displayName' in component ||\r\n        'props' in component ||\r\n        '__vccOpts' in component);\r\n}\n\n// TODO: we could allow currentRoute as a prop to expose `isActive` and\r\n// `isExactActive` behavior should go through an RFC\r\nfunction useLink(props) {\r\n    const router = inject(routerKey);\r\n    const currentRoute = inject(routeLocationKey);\r\n    const route = computed(() => router.resolve(unref(props.to)));\r\n    const activeRecordIndex = computed(() => {\r\n        let { matched } = route.value;\r\n        let { length } = matched;\r\n        const routeMatched = matched[length - 1];\r\n        let currentMatched = currentRoute.matched;\r\n        if (!routeMatched || !currentMatched.length)\r\n            return -1;\r\n        let index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));\r\n        if (index > -1)\r\n            return index;\r\n        // possible parent record\r\n        let parentRecordPath = getOriginalPath(matched[length - 2]);\r\n        return (\r\n        // we are dealing with nested routes\r\n        length > 1 &&\r\n            // if the parent and matched route have the same path, this link is\r\n            // referring to the empty child. Or we currently are on a different\r\n            // child of the same parent\r\n            getOriginalPath(routeMatched) === parentRecordPath &&\r\n            // avoid comparing the child with its parent\r\n            currentMatched[currentMatched.length - 1].path !== parentRecordPath\r\n            ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2]))\r\n            : index);\r\n    });\r\n    const isActive = computed(() => activeRecordIndex.value > -1 &&\r\n        includesParams(currentRoute.params, route.value.params));\r\n    const isExactActive = computed(() => activeRecordIndex.value > -1 &&\r\n        activeRecordIndex.value === currentRoute.matched.length - 1 &&\r\n        isSameRouteLocationParams(currentRoute.params, route.value.params));\r\n    function navigate(e = {}) {\r\n        if (guardEvent(e))\r\n            return router[unref(props.replace) ? 'replace' : 'push'](unref(props.to));\r\n        return Promise.resolve();\r\n    }\r\n    return {\r\n        route,\r\n        href: computed(() => route.value.href),\r\n        isActive,\r\n        isExactActive,\r\n        navigate,\r\n    };\r\n}\r\nconst RouterLinkImpl = /*#__PURE__*/ defineComponent({\r\n    name: 'RouterLink',\r\n    props: {\r\n        to: {\r\n            type: [String, Object],\r\n            required: true,\r\n        },\r\n        replace: Boolean,\r\n        activeClass: String,\r\n        // inactiveClass: String,\r\n        exactActiveClass: String,\r\n        custom: Boolean,\r\n        ariaCurrentValue: {\r\n            type: String,\r\n            default: 'page',\r\n        },\r\n    },\r\n    setup(props, { slots, attrs }) {\r\n        const link = reactive(useLink(props));\r\n        const { options } = inject(routerKey);\r\n        const elClass = computed(() => ({\r\n            [getLinkClass(props.activeClass, options.linkActiveClass, 'router-link-active')]: link.isActive,\r\n            // [getLinkClass(\r\n            //   props.inactiveClass,\r\n            //   options.linkInactiveClass,\r\n            //   'router-link-inactive'\r\n            // )]: !link.isExactActive,\r\n            [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, 'router-link-exact-active')]: link.isExactActive,\r\n        }));\r\n        return () => {\r\n            const children = slots.default && slots.default(link);\r\n            return props.custom\r\n                ? children\r\n                : h('a', assign({\r\n                    'aria-current': link.isExactActive\r\n                        ? props.ariaCurrentValue\r\n                        : null,\r\n                    onClick: link.navigate,\r\n                    href: link.href,\r\n                }, attrs, {\r\n                    class: elClass.value,\r\n                }), children);\r\n        };\r\n    },\r\n});\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\n/**\r\n * Component to render a link that triggers a navigation on click.\r\n */\r\nconst RouterLink = RouterLinkImpl;\r\nfunction guardEvent(e) {\r\n    // don't redirect with control keys\r\n    if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\r\n        return;\r\n    // don't redirect when preventDefault called\r\n    if (e.defaultPrevented)\r\n        return;\r\n    // don't redirect on right click\r\n    if (e.button !== undefined && e.button !== 0)\r\n        return;\r\n    // don't redirect if `target=\"_blank\"`\r\n    // @ts-ignore getAttribute does exist\r\n    if (e.currentTarget && e.currentTarget.getAttribute) {\r\n        // @ts-ignore getAttribute exists\r\n        const target = e.currentTarget.getAttribute('target');\r\n        if (/\\b_blank\\b/i.test(target))\r\n            return;\r\n    }\r\n    // this may be a Weex event which doesn't have this method\r\n    if (e.preventDefault)\r\n        e.preventDefault();\r\n    return true;\r\n}\r\nfunction includesParams(outer, inner) {\r\n    for (let key in inner) {\r\n        let innerValue = inner[key];\r\n        let outerValue = outer[key];\r\n        if (typeof innerValue === 'string') {\r\n            if (innerValue !== outerValue)\r\n                return false;\r\n        }\r\n        else {\r\n            if (!Array.isArray(outerValue) ||\r\n                outerValue.length !== innerValue.length ||\r\n                innerValue.some((value, i) => value !== outerValue[i]))\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Get the original path value of a record by following its aliasOf\r\n * @param record\r\n */\r\nfunction getOriginalPath(record) {\r\n    return record ? (record.aliasOf ? record.aliasOf.path : record.path) : '';\r\n}\r\n/**\r\n * Utility class to get the active class based on defaults.\r\n * @param propClass\r\n * @param globalClass\r\n * @param defaultClass\r\n */\r\nconst getLinkClass = (propClass, globalClass, defaultClass) => propClass != null\r\n    ? propClass\r\n    : globalClass != null\r\n        ? globalClass\r\n        : defaultClass;\n\nconst RouterViewImpl = /*#__PURE__*/ defineComponent({\r\n    name: 'RouterView',\r\n    // #674 we manually inherit them\r\n    inheritAttrs: false,\r\n    props: {\r\n        name: {\r\n            type: String,\r\n            default: 'default',\r\n        },\r\n        route: Object,\r\n    },\r\n    setup(props, { attrs, slots }) {\r\n        (process.env.NODE_ENV !== 'production') && warnDeprecatedUsage();\r\n        const injectedRoute = inject(routerViewLocationKey);\r\n        const routeToDisplay = computed(() => props.route || injectedRoute.value);\r\n        const depth = inject(viewDepthKey, 0);\r\n        const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth]);\r\n        provide(viewDepthKey, depth + 1);\r\n        provide(matchedRouteKey, matchedRouteRef);\r\n        provide(routerViewLocationKey, routeToDisplay);\r\n        const viewRef = ref();\r\n        // watch at the same time the component instance, the route record we are\r\n        // rendering, and the name\r\n        watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {\r\n            // copy reused instances\r\n            if (to) {\r\n                // this will update the instance for new instances as well as reused\r\n                // instances when navigating to a new route\r\n                to.instances[name] = instance;\r\n                // the component instance is reused for a different route or name so\r\n                // we copy any saved update or leave guards\r\n                if (from && from !== to && instance && instance === oldInstance) {\r\n                    to.leaveGuards = from.leaveGuards;\r\n                    to.updateGuards = from.updateGuards;\r\n                }\r\n            }\r\n            // trigger beforeRouteEnter next callbacks\r\n            if (instance &&\r\n                to &&\r\n                // if there is no instance but to and from are the same this might be\r\n                // the first visit\r\n                (!from || !isSameRouteRecord(to, from) || !oldInstance)) {\r\n                (to.enterCallbacks[name] || []).forEach(callback => callback(instance));\r\n            }\r\n        }, { flush: 'post' });\r\n        return () => {\r\n            const route = routeToDisplay.value;\r\n            const matchedRoute = matchedRouteRef.value;\r\n            const ViewComponent = matchedRoute && matchedRoute.components[props.name];\r\n            // we need the value at the time we render because when we unmount, we\r\n            // navigated to a different location so the value is different\r\n            const currentName = props.name;\r\n            if (!ViewComponent) {\r\n                return normalizeSlot(slots.default, { Component: ViewComponent, route });\r\n            }\r\n            // props from route configuration\r\n            const routePropsOption = matchedRoute.props[props.name];\r\n            const routeProps = routePropsOption\r\n                ? routePropsOption === true\r\n                    ? route.params\r\n                    : typeof routePropsOption === 'function'\r\n                        ? routePropsOption(route)\r\n                        : routePropsOption\r\n                : null;\r\n            const onVnodeUnmounted = vnode => {\r\n                // remove the instance reference to prevent leak\r\n                if (vnode.component.isUnmounted) {\r\n                    matchedRoute.instances[currentName] = null;\r\n                }\r\n            };\r\n            const component = h(ViewComponent, assign({}, routeProps, attrs, {\r\n                onVnodeUnmounted,\r\n                ref: viewRef,\r\n            }));\r\n            return (\r\n            // pass the vnode to the slot as a prop.\r\n            // h and <component :is=\"...\"> both accept vnodes\r\n            normalizeSlot(slots.default, { Component: component, route }) ||\r\n                component);\r\n        };\r\n    },\r\n});\r\nfunction normalizeSlot(slot, data) {\r\n    if (!slot)\r\n        return null;\r\n    const slotContent = slot(data);\r\n    return slotContent.length === 1 ? slotContent[0] : slotContent;\r\n}\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\n/**\r\n * Component to display the current route the user is at.\r\n */\r\nconst RouterView = RouterViewImpl;\r\n// warn against deprecated usage with <transition> & <keep-alive>\r\n// due to functional component being no longer eager in Vue 3\r\nfunction warnDeprecatedUsage() {\r\n    const instance = getCurrentInstance();\r\n    const parentName = instance.parent && instance.parent.type.name;\r\n    if (parentName &&\r\n        (parentName === 'KeepAlive' || parentName.includes('Transition'))) {\r\n        const comp = parentName === 'KeepAlive' ? 'keep-alive' : 'transition';\r\n        warn(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.\\n` +\r\n            `Use slot props instead:\\n\\n` +\r\n            `<router-view v-slot=\"{ Component }\">\\n` +\r\n            `  <${comp}>\\n` +\r\n            `    <component :is=\"Component\" />\\n` +\r\n            `  </${comp}>\\n` +\r\n            `</router-view>`);\r\n    }\r\n}\n\nfunction getDevtoolsGlobalHook() {\n    return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;\n}\nfunction getTarget() {\n    // @ts-ignore\n    return typeof navigator !== 'undefined'\n        ? window\n        : typeof global !== 'undefined'\n            ? global\n            : {};\n}\n\nconst HOOK_SETUP = 'devtools-plugin:setup';\n\nfunction setupDevtoolsPlugin(pluginDescriptor, setupFn) {\n    const hook = getDevtoolsGlobalHook();\n    if (hook) {\n        hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);\n    }\n    else {\n        const target = getTarget();\n        const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];\n        list.push({\n            pluginDescriptor,\n            setupFn\n        });\n    }\n}\n\nfunction formatRouteLocation(routeLocation, tooltip) {\r\n    const copy = assign({}, routeLocation, {\r\n        // remove variables that can contain vue instances\r\n        matched: routeLocation.matched.map(matched => omit(matched, ['instances', 'children', 'aliasOf'])),\r\n    });\r\n    return {\r\n        _custom: {\r\n            type: null,\r\n            readOnly: true,\r\n            display: routeLocation.fullPath,\r\n            tooltip,\r\n            value: copy,\r\n        },\r\n    };\r\n}\r\nfunction formatDisplay(display) {\r\n    return {\r\n        _custom: {\r\n            display,\r\n        },\r\n    };\r\n}\r\n// to support multiple router instances\r\nlet routerId = 0;\r\nfunction addDevtools(app, router, matcher) {\r\n    // Take over router.beforeEach and afterEach\r\n    // increment to support multiple router instances\r\n    const id = routerId++;\r\n    setupDevtoolsPlugin({\r\n        id: 'Router' + id ? ' ' + id : '',\r\n        label: 'Router devtools',\r\n        app,\r\n    }, api => {\r\n        api.on.inspectComponent((payload, ctx) => {\r\n            if (payload.instanceData) {\r\n                payload.instanceData.state.push({\r\n                    type: 'Routing',\r\n                    key: '$route',\r\n                    editable: false,\r\n                    value: formatRouteLocation(router.currentRoute.value, 'Current Route'),\r\n                });\r\n            }\r\n        });\r\n        watch(router.currentRoute, () => {\r\n            // refresh active state\r\n            refreshRoutesView();\r\n            // @ts-ignore\r\n            api.notifyComponentUpdate();\r\n            api.sendInspectorTree(routerInspectorId);\r\n        });\r\n        const navigationsLayerId = 'router:navigations:' + id;\r\n        api.addTimelineLayer({\r\n            id: navigationsLayerId,\r\n            label: `Router${id ? ' ' + id : ''} Navigations`,\r\n            color: 0x40a8c4,\r\n        });\r\n        // const errorsLayerId = 'router:errors'\r\n        // api.addTimelineLayer({\r\n        //   id: errorsLayerId,\r\n        //   label: 'Router Errors',\r\n        //   color: 0xea5455,\r\n        // })\r\n        router.onError(error => {\r\n            api.addTimelineEvent({\r\n                layerId: navigationsLayerId,\r\n                event: {\r\n                    // @ts-ignore\r\n                    logType: 'error',\r\n                    time: Date.now(),\r\n                    data: { error },\r\n                },\r\n            });\r\n        });\r\n        router.beforeEach((to, from) => {\r\n            const data = {\r\n                guard: formatDisplay('beforeEach'),\r\n                from: formatRouteLocation(from, 'Current Location during this navigation'),\r\n                to: formatRouteLocation(to, 'Target location'),\r\n            };\r\n            api.addTimelineEvent({\r\n                layerId: navigationsLayerId,\r\n                event: {\r\n                    time: Date.now(),\r\n                    meta: {},\r\n                    data,\r\n                },\r\n            });\r\n        });\r\n        router.afterEach((to, from, failure) => {\r\n            const data = {\r\n                guard: formatDisplay('afterEach'),\r\n            };\r\n            if (failure) {\r\n                data.failure = {\r\n                    _custom: {\r\n                        type: Error,\r\n                        readOnly: true,\r\n                        display: failure ? failure.message : '',\r\n                        tooltip: 'Navigation Failure',\r\n                        value: failure,\r\n                    },\r\n                };\r\n                data.status = formatDisplay('❌');\r\n            }\r\n            else {\r\n                data.status = formatDisplay('✅');\r\n            }\r\n            // we set here to have the right order\r\n            data.from = formatRouteLocation(from, 'Current Location during this navigation');\r\n            data.to = formatRouteLocation(to, 'Target location');\r\n            api.addTimelineEvent({\r\n                layerId: navigationsLayerId,\r\n                event: {\r\n                    time: Date.now(),\r\n                    data,\r\n                    // @ts-ignore\r\n                    logType: failure ? 'warning' : 'default',\r\n                    meta: {},\r\n                },\r\n            });\r\n        });\r\n        /**\r\n         * Inspector of Existing routes\r\n         */\r\n        const routerInspectorId = 'router-inspector:' + id;\r\n        api.addInspector({\r\n            id: routerInspectorId,\r\n            label: 'Routes' + (id ? ' ' + id : ''),\r\n            icon: 'book',\r\n            treeFilterPlaceholder: 'Search routes',\r\n        });\r\n        function refreshRoutesView() {\r\n            // the routes view isn't active\r\n            if (!activeRoutesPayload)\r\n                return;\r\n            const payload = activeRoutesPayload;\r\n            // children routes will appear as nested\r\n            let routes = matcher.getRoutes().filter(route => !route.parent);\r\n            // reset match state to false\r\n            routes.forEach(resetMatchStateOnRouteRecord);\r\n            // apply a match state if there is a payload\r\n            if (payload.filter) {\r\n                routes = routes.filter(route => \r\n                // save matches state based on the payload\r\n                isRouteMatching(route, payload.filter.toLowerCase()));\r\n            }\r\n            // mark active routes\r\n            routes.forEach(route => markRouteRecordActive(route, router.currentRoute.value));\r\n            payload.rootNodes = routes.map(formatRouteRecordForInspector);\r\n        }\r\n        let activeRoutesPayload;\r\n        api.on.getInspectorTree(payload => {\r\n            activeRoutesPayload = payload;\r\n            if (payload.app === app && payload.inspectorId === routerInspectorId) {\r\n                refreshRoutesView();\r\n            }\r\n        });\r\n        /**\r\n         * Display information about the currently selected route record\r\n         */\r\n        api.on.getInspectorState(payload => {\r\n            if (payload.app === app && payload.inspectorId === routerInspectorId) {\r\n                const routes = matcher.getRoutes();\r\n                const route = routes.find(route => route.record.__vd_id === payload.nodeId);\r\n                if (route) {\r\n                    payload.state = {\r\n                        options: formatRouteRecordMatcherForStateInspector(route),\r\n                    };\r\n                }\r\n            }\r\n        });\r\n        api.sendInspectorTree(routerInspectorId);\r\n        api.sendInspectorState(routerInspectorId);\r\n    });\r\n}\r\nfunction modifierForKey(key) {\r\n    if (key.optional) {\r\n        return key.repeatable ? '*' : '?';\r\n    }\r\n    else {\r\n        return key.repeatable ? '+' : '';\r\n    }\r\n}\r\nfunction formatRouteRecordMatcherForStateInspector(route) {\r\n    const { record } = route;\r\n    const fields = [\r\n        { editable: false, key: 'path', value: record.path },\r\n    ];\r\n    if (record.name != null) {\r\n        fields.push({\r\n            editable: false,\r\n            key: 'name',\r\n            value: record.name,\r\n        });\r\n    }\r\n    fields.push({ editable: false, key: 'regexp', value: route.re });\r\n    if (route.keys.length) {\r\n        fields.push({\r\n            editable: false,\r\n            key: 'keys',\r\n            value: {\r\n                _custom: {\r\n                    type: null,\r\n                    readOnly: true,\r\n                    display: route.keys\r\n                        .map(key => `${key.name}${modifierForKey(key)}`)\r\n                        .join(' '),\r\n                    tooltip: 'Param keys',\r\n                    value: route.keys,\r\n                },\r\n            },\r\n        });\r\n    }\r\n    if (record.redirect != null) {\r\n        fields.push({\r\n            editable: false,\r\n            key: 'redirect',\r\n            value: record.redirect,\r\n        });\r\n    }\r\n    if (route.alias.length) {\r\n        fields.push({\r\n            editable: false,\r\n            key: 'aliases',\r\n            value: route.alias.map(alias => alias.record.path),\r\n        });\r\n    }\r\n    fields.push({\r\n        key: 'score',\r\n        editable: false,\r\n        value: {\r\n            _custom: {\r\n                type: null,\r\n                readOnly: true,\r\n                display: route.score.map(score => score.join(', ')).join(' | '),\r\n                tooltip: 'Score used to sort routes',\r\n                value: route.score,\r\n            },\r\n        },\r\n    });\r\n    return fields;\r\n}\r\n/**\r\n * Extracted from tailwind palette\r\n */\r\nconst PINK_500 = 0xec4899;\r\nconst BLUE_600 = 0x2563eb;\r\nconst LIME_500 = 0x84cc16;\r\nconst CYAN_400 = 0x22d3ee;\r\nconst ORANGE_400 = 0xfb923c;\r\n// const GRAY_100 = 0xf4f4f5\r\nconst DARK = 0x666666;\r\nfunction formatRouteRecordForInspector(route) {\r\n    const tags = [];\r\n    const { record } = route;\r\n    if (record.name != null) {\r\n        tags.push({\r\n            label: String(record.name),\r\n            textColor: 0,\r\n            backgroundColor: CYAN_400,\r\n        });\r\n    }\r\n    if (record.aliasOf) {\r\n        tags.push({\r\n            label: 'alias',\r\n            textColor: 0,\r\n            backgroundColor: ORANGE_400,\r\n        });\r\n    }\r\n    if (route.__vd_match) {\r\n        tags.push({\r\n            label: 'matches',\r\n            textColor: 0,\r\n            backgroundColor: PINK_500,\r\n        });\r\n    }\r\n    if (route.__vd_exactActive) {\r\n        tags.push({\r\n            label: 'exact',\r\n            textColor: 0,\r\n            backgroundColor: LIME_500,\r\n        });\r\n    }\r\n    if (route.__vd_active) {\r\n        tags.push({\r\n            label: 'active',\r\n            textColor: 0,\r\n            backgroundColor: BLUE_600,\r\n        });\r\n    }\r\n    if (record.redirect) {\r\n        tags.push({\r\n            label: 'redirect: ' +\r\n                (typeof record.redirect === 'string' ? record.redirect : 'Object'),\r\n            textColor: 0xffffff,\r\n            backgroundColor: DARK,\r\n        });\r\n    }\r\n    // add an id to be able to select it. Using the `path` is not possible because\r\n    // empty path children would collide with their parents\r\n    let id = String(routeRecordId++);\r\n    record.__vd_id = id;\r\n    return {\r\n        id,\r\n        label: record.path,\r\n        tags,\r\n        // @ts-ignore\r\n        children: route.children.map(formatRouteRecordForInspector),\r\n    };\r\n}\r\n//  incremental id for route records and inspector state\r\nlet routeRecordId = 0;\r\nconst EXTRACT_REGEXP_RE = /^\\/(.*)\\/([a-z]*)$/;\r\nfunction markRouteRecordActive(route, currentRoute) {\r\n    // no route will be active if matched is empty\r\n    // reset the matching state\r\n    const isExactActive = currentRoute.matched.length &&\r\n        isSameRouteRecord(currentRoute.matched[currentRoute.matched.length - 1], route.record);\r\n    route.__vd_exactActive = route.__vd_active = isExactActive;\r\n    if (!isExactActive) {\r\n        route.__vd_active = currentRoute.matched.some(match => isSameRouteRecord(match, route.record));\r\n    }\r\n    route.children.forEach(childRoute => markRouteRecordActive(childRoute, currentRoute));\r\n}\r\nfunction resetMatchStateOnRouteRecord(route) {\r\n    route.__vd_match = false;\r\n    route.children.forEach(resetMatchStateOnRouteRecord);\r\n}\r\nfunction isRouteMatching(route, filter) {\r\n    const found = String(route.re).match(EXTRACT_REGEXP_RE);\r\n    route.__vd_match = false;\r\n    if (!found || found.length < 3) {\r\n        return false;\r\n    }\r\n    // use a regexp without $ at the end to match nested routes better\r\n    const nonEndingRE = new RegExp(found[1].replace(/\\$$/, ''), found[2]);\r\n    if (nonEndingRE.test(filter)) {\r\n        // mark children as matches\r\n        route.children.forEach(child => isRouteMatching(child, filter));\r\n        // exception case: `/`\r\n        if (route.record.path !== '/' || filter === '/') {\r\n            route.__vd_match = route.re.test(filter);\r\n            return true;\r\n        }\r\n        // hide the / route\r\n        return false;\r\n    }\r\n    const path = route.record.path.toLowerCase();\r\n    const decodedPath = decode(path);\r\n    // also allow partial matching on the path\r\n    if (!filter.startsWith('/') &&\r\n        (decodedPath.includes(filter) || path.includes(filter)))\r\n        return true;\r\n    if (decodedPath.startsWith(filter) || path.startsWith(filter))\r\n        return true;\r\n    if (route.record.name && String(route.record.name).includes(filter))\r\n        return true;\r\n    return route.children.some(child => isRouteMatching(child, filter));\r\n}\r\nfunction omit(obj, keys) {\r\n    const ret = {};\r\n    for (let key in obj) {\r\n        if (!keys.includes(key)) {\r\n            // @ts-ignore\r\n            ret[key] = obj[key];\r\n        }\r\n    }\r\n    return ret;\r\n}\n\n/**\r\n * Creates a Router instance that can be used by a Vue app.\r\n *\r\n * @param options - {@link RouterOptions}\r\n */\r\nfunction createRouter(options) {\r\n    const matcher = createRouterMatcher(options.routes, options);\r\n    let parseQuery$1 = options.parseQuery || parseQuery;\r\n    let stringifyQuery$1 = options.stringifyQuery || stringifyQuery;\r\n    let routerHistory = options.history;\r\n    const beforeGuards = useCallbacks();\r\n    const beforeResolveGuards = useCallbacks();\r\n    const afterGuards = useCallbacks();\r\n    const currentRoute = shallowRef(START_LOCATION_NORMALIZED);\r\n    let pendingLocation = START_LOCATION_NORMALIZED;\r\n    // leave the scrollRestoration if no scrollBehavior is provided\r\n    if (isBrowser && options.scrollBehavior && 'scrollRestoration' in history) {\r\n        history.scrollRestoration = 'manual';\r\n    }\r\n    const normalizeParams = applyToParams.bind(null, paramValue => '' + paramValue);\r\n    const encodeParams = applyToParams.bind(null, encodeParam);\r\n    const decodeParams = applyToParams.bind(null, decode);\r\n    function addRoute(parentOrRoute, route) {\r\n        let parent;\r\n        let record;\r\n        if (isRouteName(parentOrRoute)) {\r\n            parent = matcher.getRecordMatcher(parentOrRoute);\r\n            record = route;\r\n        }\r\n        else {\r\n            record = parentOrRoute;\r\n        }\r\n        return matcher.addRoute(record, parent);\r\n    }\r\n    function removeRoute(name) {\r\n        let recordMatcher = matcher.getRecordMatcher(name);\r\n        if (recordMatcher) {\r\n            matcher.removeRoute(recordMatcher);\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production')) {\r\n            warn(`Cannot remove non-existent route \"${String(name)}\"`);\r\n        }\r\n    }\r\n    function getRoutes() {\r\n        return matcher.getRoutes().map(routeMatcher => routeMatcher.record);\r\n    }\r\n    function hasRoute(name) {\r\n        return !!matcher.getRecordMatcher(name);\r\n    }\r\n    function resolve(rawLocation, currentLocation) {\r\n        // const objectLocation = routerLocationAsObject(rawLocation)\r\n        // we create a copy to modify it later\r\n        currentLocation = assign({}, currentLocation || currentRoute.value);\r\n        if (typeof rawLocation === 'string') {\r\n            let locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);\r\n            let matchedRoute = matcher.resolve({ path: locationNormalized.path }, currentLocation);\r\n            let href = routerHistory.createHref(locationNormalized.fullPath);\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                if (href.startsWith('//'))\r\n                    warn(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);\r\n                else if (!matchedRoute.matched.length) {\r\n                    warn(`No match found for location with path \"${rawLocation}\"`);\r\n                }\r\n            }\r\n            // locationNormalized is always a new object\r\n            return assign(locationNormalized, matchedRoute, {\r\n                params: decodeParams(matchedRoute.params),\r\n                hash: decode(locationNormalized.hash),\r\n                redirectedFrom: undefined,\r\n                href,\r\n            });\r\n        }\r\n        let matcherLocation;\r\n        // path could be relative in object as well\r\n        if ('path' in rawLocation) {\r\n            if ((process.env.NODE_ENV !== 'production') &&\r\n                'params' in rawLocation &&\r\n                !('name' in rawLocation) &&\r\n                Object.keys(rawLocation.params).length) {\r\n                warn(`Path \"${rawLocation.path}\" was passed with params but they will be ignored. Use a named route alongside params instead.`);\r\n            }\r\n            matcherLocation = assign({}, rawLocation, {\r\n                path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path,\r\n            });\r\n        }\r\n        else {\r\n            // pass encoded values to the matcher so it can produce encoded path and fullPath\r\n            matcherLocation = assign({}, rawLocation, {\r\n                params: encodeParams(rawLocation.params),\r\n            });\r\n            // current location params are decoded, we need to encode them in case the\r\n            // matcher merges the params\r\n            currentLocation.params = encodeParams(currentLocation.params);\r\n        }\r\n        let matchedRoute = matcher.resolve(matcherLocation, currentLocation);\r\n        const hash = rawLocation.hash || '';\r\n        if ((process.env.NODE_ENV !== 'production') && hash && !hash.startsWith('#')) {\r\n            warn(`A \\`hash\\` should always start with the character \"#\". Replace \"${hash}\" with \"#${hash}\".`);\r\n        }\r\n        // decoding them) the matcher might have merged current location params so\r\n        // we need to run the decoding again\r\n        matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));\r\n        const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {\r\n            hash: encodeHash(hash),\r\n            path: matchedRoute.path,\r\n        }));\r\n        let href = routerHistory.createHref(fullPath);\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            if (href.startsWith('//')) {\r\n                warn(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);\r\n            }\r\n            else if (!matchedRoute.matched.length) {\r\n                warn(`No match found for location with path \"${'path' in rawLocation ? rawLocation.path : rawLocation}\"`);\r\n            }\r\n        }\r\n        return assign({\r\n            fullPath,\r\n            // keep the hash encoded so fullPath is effectively path + encodedQuery +\r\n            // hash\r\n            hash,\r\n            query: \r\n            // if the user is using a custom query lib like qs, we might have\r\n            // nested objects, so we keep the query as is, meaning it can contain\r\n            // numbers at `$route.query`, but at the point, the user will have to\r\n            // use their own type anyway.\r\n            // https://github.com/vuejs/vue-router-next/issues/328#issuecomment-649481567\r\n            stringifyQuery$1 === stringifyQuery\r\n                ? normalizeQuery(rawLocation.query)\r\n                : rawLocation.query,\r\n        }, matchedRoute, {\r\n            redirectedFrom: undefined,\r\n            href,\r\n        });\r\n    }\r\n    function locationAsObject(to) {\r\n        return typeof to === 'string'\r\n            ? parseURL(parseQuery$1, to, currentRoute.value.path)\r\n            : assign({}, to);\r\n    }\r\n    function checkCanceledNavigation(to, from) {\r\n        if (pendingLocation !== to) {\r\n            return createRouterError(8 /* NAVIGATION_CANCELLED */, {\r\n                from,\r\n                to,\r\n            });\r\n        }\r\n    }\r\n    function push(to) {\r\n        return pushWithRedirect(to);\r\n    }\r\n    function replace(to) {\r\n        return push(assign(locationAsObject(to), { replace: true }));\r\n    }\r\n    function handleRedirectRecord(to) {\r\n        const lastMatched = to.matched[to.matched.length - 1];\r\n        if (lastMatched && lastMatched.redirect) {\r\n            const { redirect } = lastMatched;\r\n            let newTargetLocation = typeof redirect === 'function' ? redirect(to) : redirect;\r\n            if (typeof newTargetLocation === 'string') {\r\n                newTargetLocation =\r\n                    newTargetLocation.indexOf('?') > -1 ||\r\n                        newTargetLocation.indexOf('#') > -1\r\n                        ? (newTargetLocation = locationAsObject(newTargetLocation))\r\n                        : { path: newTargetLocation };\r\n            }\r\n            if ((process.env.NODE_ENV !== 'production') &&\r\n                !('path' in newTargetLocation) &&\r\n                !('name' in newTargetLocation)) {\r\n                warn(`Invalid redirect found:\\n${JSON.stringify(newTargetLocation, null, 2)}\\n when navigating to \"${to.fullPath}\". A redirect must contain a name or path. This will break in production.`);\r\n                throw new Error('Invalid redirect');\r\n            }\r\n            return assign({\r\n                query: to.query,\r\n                hash: to.hash,\r\n                params: to.params,\r\n            }, newTargetLocation);\r\n        }\r\n    }\r\n    function pushWithRedirect(to, redirectedFrom) {\r\n        const targetLocation = (pendingLocation = resolve(to));\r\n        const from = currentRoute.value;\r\n        const data = to.state;\r\n        const force = to.force;\r\n        // to could be a string where `replace` is a function\r\n        const replace = to.replace === true;\r\n        const shouldRedirect = handleRedirectRecord(targetLocation);\r\n        if (shouldRedirect)\r\n            return pushWithRedirect(assign(locationAsObject(shouldRedirect), {\r\n                state: data,\r\n                force,\r\n                replace,\r\n            }), \r\n            // keep original redirectedFrom if it exists\r\n            redirectedFrom || targetLocation);\r\n        // if it was a redirect we already called `pushWithRedirect` above\r\n        const toLocation = targetLocation;\r\n        toLocation.redirectedFrom = redirectedFrom;\r\n        let failure;\r\n        if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {\r\n            failure = createRouterError(16 /* NAVIGATION_DUPLICATED */, { to: toLocation, from });\r\n            // trigger scroll to allow scrolling to the same anchor\r\n            handleScroll(from, from, \r\n            // this is a push, the only way for it to be triggered from a\r\n            // history.listen is with a redirect, which makes it become a push\r\n            true, \r\n            // This cannot be the first navigation because the initial location\r\n            // cannot be manually navigated to\r\n            false);\r\n        }\r\n        return (failure ? Promise.resolve(failure) : navigate(toLocation, from))\r\n            .catch((error) => isNavigationFailure(error)\r\n            ? error\r\n            : // reject any unknown error\r\n                triggerError(error))\r\n            .then((failure) => {\r\n            if (failure) {\r\n                if (isNavigationFailure(failure, 2 /* NAVIGATION_GUARD_REDIRECT */)) {\r\n                    if ((process.env.NODE_ENV !== 'production') &&\r\n                        // we are redirecting to the same location we were already at\r\n                        isSameRouteLocation(stringifyQuery$1, resolve(failure.to), toLocation) &&\r\n                        // and we have done it a couple of times\r\n                        redirectedFrom &&\r\n                        // @ts-ignore\r\n                        (redirectedFrom._count = redirectedFrom._count\r\n                            ? // @ts-ignore\r\n                                redirectedFrom._count + 1\r\n                            : 1) > 10) {\r\n                        warn(`Detected an infinite redirection in a navigation guard when going from \"${from.fullPath}\" to \"${toLocation.fullPath}\". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`);\r\n                        return Promise.reject(new Error('Infinite redirect in navigation guard'));\r\n                    }\r\n                    return pushWithRedirect(\r\n                    // keep options\r\n                    assign(locationAsObject(failure.to), {\r\n                        state: data,\r\n                        force,\r\n                        replace,\r\n                    }), \r\n                    // preserve the original redirectedFrom if any\r\n                    redirectedFrom || toLocation);\r\n                }\r\n            }\r\n            else {\r\n                // if we fail we don't finalize the navigation\r\n                failure = finalizeNavigation(toLocation, from, true, replace, data);\r\n            }\r\n            triggerAfterEach(toLocation, from, failure);\r\n            return failure;\r\n        });\r\n    }\r\n    /**\r\n     * Helper to reject and skip all navigation guards if a new navigation happened\r\n     * @param to\r\n     * @param from\r\n     */\r\n    function checkCanceledNavigationAndReject(to, from) {\r\n        const error = checkCanceledNavigation(to, from);\r\n        return error ? Promise.reject(error) : Promise.resolve();\r\n    }\r\n    // TODO: refactor the whole before guards by internally using router.beforeEach\r\n    function navigate(to, from) {\r\n        let guards;\r\n        const [leavingRecords, updatingRecords, enteringRecords,] = extractChangingRecords(to, from);\r\n        // all components here have been resolved once because we are leaving\r\n        guards = extractComponentsGuards(leavingRecords.reverse(), 'beforeRouteLeave', to, from);\r\n        // leavingRecords is already reversed\r\n        for (const record of leavingRecords) {\r\n            record.leaveGuards.forEach(guard => {\r\n                guards.push(guardToPromiseFn(guard, to, from));\r\n            });\r\n        }\r\n        const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);\r\n        guards.push(canceledNavigationCheck);\r\n        // run the queue of per route beforeRouteLeave guards\r\n        return (runGuardQueue(guards)\r\n            .then(() => {\r\n            // check global guards beforeEach\r\n            guards = [];\r\n            for (const guard of beforeGuards.list()) {\r\n                guards.push(guardToPromiseFn(guard, to, from));\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // check in components beforeRouteUpdate\r\n            guards = extractComponentsGuards(updatingRecords, 'beforeRouteUpdate', to, from);\r\n            for (const record of updatingRecords) {\r\n                record.updateGuards.forEach(guard => {\r\n                    guards.push(guardToPromiseFn(guard, to, from));\r\n                });\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            // run the queue of per route beforeEnter guards\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // check the route beforeEnter\r\n            guards = [];\r\n            for (const record of to.matched) {\r\n                // do not trigger beforeEnter on reused views\r\n                if (record.beforeEnter && from.matched.indexOf(record) < 0) {\r\n                    if (Array.isArray(record.beforeEnter)) {\r\n                        for (const beforeEnter of record.beforeEnter)\r\n                            guards.push(guardToPromiseFn(beforeEnter, to, from));\r\n                    }\r\n                    else {\r\n                        guards.push(guardToPromiseFn(record.beforeEnter, to, from));\r\n                    }\r\n                }\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            // run the queue of per route beforeEnter guards\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // NOTE: at this point to.matched is normalized and does not contain any () => Promise<Component>\r\n            // clear existing enterCallbacks, these are added by extractComponentsGuards\r\n            to.matched.forEach(record => (record.enterCallbacks = {}));\r\n            // check in-component beforeRouteEnter\r\n            guards = extractComponentsGuards(enteringRecords, 'beforeRouteEnter', to, from);\r\n            guards.push(canceledNavigationCheck);\r\n            // run the queue of per route beforeEnter guards\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // check global guards beforeResolve\r\n            guards = [];\r\n            for (const guard of beforeResolveGuards.list()) {\r\n                guards.push(guardToPromiseFn(guard, to, from));\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            return runGuardQueue(guards);\r\n        })\r\n            // catch any navigation canceled\r\n            .catch(err => isNavigationFailure(err, 8 /* NAVIGATION_CANCELLED */)\r\n            ? err\r\n            : Promise.reject(err)));\r\n    }\r\n    function triggerAfterEach(to, from, failure) {\r\n        // navigation is confirmed, call afterGuards\r\n        // TODO: wrap with error handlers\r\n        for (const guard of afterGuards.list())\r\n            guard(to, from, failure);\r\n    }\r\n    /**\r\n     * - Cleans up any navigation guards\r\n     * - Changes the url if necessary\r\n     * - Calls the scrollBehavior\r\n     */\r\n    function finalizeNavigation(toLocation, from, isPush, replace, data) {\r\n        // a more recent navigation took place\r\n        const error = checkCanceledNavigation(toLocation, from);\r\n        if (error)\r\n            return error;\r\n        // only consider as push if it's not the first navigation\r\n        const isFirstNavigation = from === START_LOCATION_NORMALIZED;\r\n        const state = !isBrowser ? {} : history.state;\r\n        // change URL only if the user did a push/replace and if it's not the initial navigation because\r\n        // it's just reflecting the url\r\n        if (isPush) {\r\n            // on the initial navigation, we want to reuse the scroll position from\r\n            // history state if it exists\r\n            if (replace || isFirstNavigation)\r\n                routerHistory.replace(toLocation.fullPath, assign({\r\n                    scroll: isFirstNavigation && state && state.scroll,\r\n                }, data));\r\n            else\r\n                routerHistory.push(toLocation.fullPath, data);\r\n        }\r\n        // accept current navigation\r\n        currentRoute.value = toLocation;\r\n        handleScroll(toLocation, from, isPush, isFirstNavigation);\r\n        markAsReady();\r\n    }\r\n    let removeHistoryListener;\r\n    // attach listener to history to trigger navigations\r\n    function setupListeners() {\r\n        removeHistoryListener = routerHistory.listen((to, _from, info) => {\r\n            // cannot be a redirect route because it was in history\r\n            let toLocation = resolve(to);\r\n            // due to dynamic routing, and to hash history with manual navigation\r\n            // (manually changing the url or calling history.hash = '#/somewhere'),\r\n            // there could be a redirect record in history\r\n            const shouldRedirect = handleRedirectRecord(toLocation);\r\n            if (shouldRedirect) {\r\n                pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);\r\n                return;\r\n            }\r\n            pendingLocation = toLocation;\r\n            const from = currentRoute.value;\r\n            // TODO: should be moved to web history?\r\n            if (isBrowser) {\r\n                saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());\r\n            }\r\n            navigate(toLocation, from)\r\n                .catch((error) => {\r\n                if (isNavigationFailure(error, 4 /* NAVIGATION_ABORTED */ | 8 /* NAVIGATION_CANCELLED */)) {\r\n                    return error;\r\n                }\r\n                if (isNavigationFailure(error, 2 /* NAVIGATION_GUARD_REDIRECT */)) {\r\n                    // Here we could call if (info.delta) routerHistory.go(-info.delta,\r\n                    // false) but this is bug prone as we have no way to wait the\r\n                    // navigation to be finished before calling pushWithRedirect. Using\r\n                    // a setTimeout of 16ms seems to work but there is not guarantee for\r\n                    // it to work on every browser. So Instead we do not restore the\r\n                    // history entry and trigger a new navigation as requested by the\r\n                    // navigation guard.\r\n                    // the error is already handled by router.push we just want to avoid\r\n                    // logging the error\r\n                    pushWithRedirect(error.to, toLocation\r\n                    // avoid an uncaught rejection, let push call triggerError\r\n                    ).catch(noop);\r\n                    // avoid the then branch\r\n                    return Promise.reject();\r\n                }\r\n                // do not restore history on unknown direction\r\n                if (info.delta)\r\n                    routerHistory.go(-info.delta, false);\r\n                // unrecognized error, transfer to the global handler\r\n                return triggerError(error);\r\n            })\r\n                .then((failure) => {\r\n                failure =\r\n                    failure ||\r\n                        finalizeNavigation(\r\n                        // after navigation, all matched components are resolved\r\n                        toLocation, from, false);\r\n                // revert the navigation\r\n                if (failure && info.delta)\r\n                    routerHistory.go(-info.delta, false);\r\n                triggerAfterEach(toLocation, from, failure);\r\n            })\r\n                .catch(noop);\r\n        });\r\n    }\r\n    // Initialization and Errors\r\n    let readyHandlers = useCallbacks();\r\n    let errorHandlers = useCallbacks();\r\n    let ready;\r\n    /**\r\n     * Trigger errorHandlers added via onError and throws the error as well\r\n     * @param error - error to throw\r\n     * @returns the error as a rejected promise\r\n     */\r\n    function triggerError(error) {\r\n        markAsReady(error);\r\n        errorHandlers.list().forEach(handler => handler(error));\r\n        return Promise.reject(error);\r\n    }\r\n    function isReady() {\r\n        if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)\r\n            return Promise.resolve();\r\n        return new Promise((resolve, reject) => {\r\n            readyHandlers.add([resolve, reject]);\r\n        });\r\n    }\r\n    /**\r\n     * Mark the router as ready, resolving the promised returned by isReady(). Can\r\n     * only be called once, otherwise does nothing.\r\n     * @param err - optional error\r\n     */\r\n    function markAsReady(err) {\r\n        if (ready)\r\n            return;\r\n        ready = true;\r\n        setupListeners();\r\n        readyHandlers\r\n            .list()\r\n            .forEach(([resolve, reject]) => (err ? reject(err) : resolve()));\r\n        readyHandlers.reset();\r\n    }\r\n    // Scroll behavior\r\n    function handleScroll(to, from, isPush, isFirstNavigation) {\r\n        const { scrollBehavior } = options;\r\n        if (!isBrowser || !scrollBehavior)\r\n            return Promise.resolve();\r\n        let scrollPosition = (!isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0))) ||\r\n            ((isFirstNavigation || !isPush) &&\r\n                history.state &&\r\n                history.state.scroll) ||\r\n            null;\r\n        return nextTick()\r\n            .then(() => scrollBehavior(to, from, scrollPosition))\r\n            .then(position => position && scrollToPosition(position))\r\n            .catch(triggerError);\r\n    }\r\n    const go = (delta) => routerHistory.go(delta);\r\n    let started;\r\n    const installedApps = new Set();\r\n    const router = {\r\n        currentRoute,\r\n        addRoute,\r\n        removeRoute,\r\n        hasRoute,\r\n        getRoutes,\r\n        resolve,\r\n        options,\r\n        push,\r\n        replace,\r\n        go,\r\n        back: () => go(-1),\r\n        forward: () => go(1),\r\n        beforeEach: beforeGuards.add,\r\n        beforeResolve: beforeResolveGuards.add,\r\n        afterEach: afterGuards.add,\r\n        onError: errorHandlers.add,\r\n        isReady,\r\n        install(app) {\r\n            const router = this;\r\n            app.component('RouterLink', RouterLink);\r\n            app.component('RouterView', RouterView);\r\n            app.config.globalProperties.$router = router;\r\n            Object.defineProperty(app.config.globalProperties, '$route', {\r\n                get: () => unref(currentRoute),\r\n            });\r\n            // this initial navigation is only necessary on client, on server it doesn't\r\n            // make sense because it will create an extra unnecessary navigation and could\r\n            // lead to problems\r\n            if (isBrowser &&\r\n                // used for the initial navigation client side to avoid pushing\r\n                // multiple times when the router is used in multiple apps\r\n                !started &&\r\n                currentRoute.value === START_LOCATION_NORMALIZED) {\r\n                // see above\r\n                started = true;\r\n                push(routerHistory.location).catch(err => {\r\n                    if ((process.env.NODE_ENV !== 'production'))\r\n                        warn('Unexpected error when starting the router:', err);\r\n                });\r\n            }\r\n            const reactiveRoute = {};\r\n            for (let key in START_LOCATION_NORMALIZED) {\r\n                // @ts-ignore: the key matches\r\n                reactiveRoute[key] = computed(() => currentRoute.value[key]);\r\n            }\r\n            app.provide(routerKey, router);\r\n            app.provide(routeLocationKey, reactive(reactiveRoute));\r\n            app.provide(routerViewLocationKey, currentRoute);\r\n            let unmountApp = app.unmount;\r\n            installedApps.add(app);\r\n            app.unmount = function () {\r\n                installedApps.delete(app);\r\n                if (installedApps.size < 1) {\r\n                    removeHistoryListener();\r\n                    currentRoute.value = START_LOCATION_NORMALIZED;\r\n                    started = false;\r\n                    ready = false;\r\n                }\r\n                unmountApp.call(this, arguments);\r\n            };\r\n            if (((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) && true) {\r\n                addDevtools(app, router, matcher);\r\n            }\r\n        },\r\n    };\r\n    return router;\r\n}\r\nfunction runGuardQueue(guards) {\r\n    return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());\r\n}\r\nfunction extractChangingRecords(to, from) {\r\n    const leavingRecords = [];\r\n    const updatingRecords = [];\r\n    const enteringRecords = [];\r\n    const len = Math.max(from.matched.length, to.matched.length);\r\n    for (let i = 0; i < len; i++) {\r\n        const recordFrom = from.matched[i];\r\n        if (recordFrom) {\r\n            if (to.matched.indexOf(recordFrom) < 0)\r\n                leavingRecords.push(recordFrom);\r\n            else\r\n                updatingRecords.push(recordFrom);\r\n        }\r\n        const recordTo = to.matched[i];\r\n        if (recordTo) {\r\n            // the type doesn't matter because we are comparing per reference\r\n            if (from.matched.indexOf(recordTo) < 0)\r\n                enteringRecords.push(recordTo);\r\n        }\r\n    }\r\n    return [leavingRecords, updatingRecords, enteringRecords];\r\n}\n\n/**\r\n * Returns the router instance. Equivalent to using `$router` inside\r\n * templates.\r\n */\r\nfunction useRouter() {\r\n    return inject(routerKey);\r\n}\r\n/**\r\n * Returns the current route location. Equivalent to using `$route` inside\r\n * templates.\r\n */\r\nfunction useRoute() {\r\n    return inject(routeLocationKey);\r\n}\n\nexport { NavigationFailureType, RouterLink, RouterView, START_LOCATION_NORMALIZED as START_LOCATION, createMemoryHistory, createRouter, createRouterMatcher, createWebHashHistory, createWebHistory, isNavigationFailure, matchedRouteKey, onBeforeRouteLeave, onBeforeRouteUpdate, parseQuery, routeLocationKey, routerKey, routerViewLocationKey, stringifyQuery, useLink, useRoute, useRouter, viewDepthKey };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}