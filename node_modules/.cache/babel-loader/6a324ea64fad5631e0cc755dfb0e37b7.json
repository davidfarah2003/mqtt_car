{"ast":null,"code":"import _classPrivateFieldInitSpec from \"/home/davidf/Desktop/SSB/ssb-interface-v2/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classStaticPrivateMethodGet from \"/home/davidf/Desktop/SSB/ssb-interface-v2/node_modules/@babel/runtime/helpers/esm/classStaticPrivateMethodGet.js\";\nimport _classPrivateFieldGet from \"/home/davidf/Desktop/SSB/ssb-interface-v2/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport _classPrivateFieldSet from \"/home/davidf/Desktop/SSB/ssb-interface-v2/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nimport mqtt from \"precompiled-mqtt\";\nvar _mqttClientPromise = /*#__PURE__*/new WeakMap();\nvar _subscribedTopics = /*#__PURE__*/new WeakMap();\nvar _previouslySubscribedTopics = /*#__PURE__*/new WeakMap();\nexport default class MqttUtils {\n  constructor(mqttClientPromise, messageCallback) {\n    _classPrivateFieldInitSpec(this, _mqttClientPromise, {\n      writable: true,\n      value: null\n    });\n    _classPrivateFieldInitSpec(this, _subscribedTopics, {\n      writable: true,\n      value: new Set()\n    });\n    _classPrivateFieldInitSpec(this, _previouslySubscribedTopics, {\n      writable: true,\n      value: new Set()\n    });\n    if (!mqttClientPromise) throw new Error(\"No mqttClientPromise was provided\");else _classPrivateFieldSet(this, _mqttClientPromise, mqttClientPromise);\n    this.on(\"message\", messageCallback);\n  }\n  on(eventName, callbackFunction) {\n    _classPrivateFieldGet(this, _mqttClientPromise).then(client => {\n      client.on(eventName, callbackFunction);\n    });\n  }\n  connected() {\n    return _classPrivateFieldGet(this, _mqttClientPromise).then(client => {\n      client.connected;\n    });\n  }\n\n  /**\n   * Unsubscribe from all the topics in #subscribedTopics\n   */\n  unsubscribeAll() {\n    _classPrivateFieldSet(this, _previouslySubscribedTopics, new Set(_classPrivateFieldGet(this, _subscribedTopics)));\n    this.unsubscribeFrom(Array.from(_classPrivateFieldGet(this, _subscribedTopics)));\n  }\n\n  /**\n   * Subscribe to all the topics in #previouslySubscribedTopics\n   */\n  resubscribeAll() {\n    this.subscribeTo(Array.from(_classPrivateFieldGet(this, _previouslySubscribedTopics)));\n  }\n\n  /**\n   * Subscribe to topics\n   * @param topics Array of topics to subscribe to (not ref)\n   */\n  subscribeTo(topics) {\n    console.log(\"subscribed to \" + topics);\n    topics.forEach(topic => _classPrivateFieldGet(this, _subscribedTopics).add(topic));\n    _classPrivateFieldGet(this, _mqttClientPromise).then(client => {\n      client.subscribe(topics);\n    });\n  }\n\n  /**\n   * Subscribe from topics\n   * @param topics Array of topics to subscribe from (not ref)\n   */\n  unsubscribeFrom(topics) {\n    console.log(\"subscribed from \" + topics);\n    topics.forEach(topic => _classPrivateFieldGet(this, _subscribedTopics).delete(topic));\n    _classPrivateFieldGet(this, _mqttClientPromise).then(client => {\n      client.unsubscribe(topics);\n    });\n  }\n  getSubscribedTopicsSet() {\n    return _classPrivateFieldGet(this, _subscribedTopics);\n  }\n\n  //---------------------------------------------STATIC METHODS-----------------------------------------------\n  /**\n   * Asynchronous method that returns a promise, from which we can obtain the mqtt client if resolved.\n   * We use the MQTT.js library to communicate with broker through websockets (Not TCP - that's why I used precompiled-mqtt)\n   * @returns client\n   */\n  static async getMqttClient() {\n    const clientId = \"SSB_interface\";\n    const host = 'ws://34.65.125.98:9001';\n    //const host = 'ws://localhost:9001'\n\n    const options = {\n      keepalive: 60,\n      clientId: clientId,\n      protocolId: 'MQTT',\n      protocolVersion: 4,\n      clean: true,\n      reconnectPeriod: 1000,\n      connectTimeout: 30 * 1000,\n      will: {\n        topic: 'WillMsg',\n        payload: 'Connection Closed abnormally..!',\n        qos: 0,\n        retain: false\n      }\n    };\n    const client = await _classStaticPrivateMethodGet(this, MqttUtils, _getClient).call(this, host, options);\n    client.on('error', err => {\n      console.log('Connection error: ', err);\n    });\n    client.on('reconnect', () => {\n      console.log('Reconnecting...');\n    });\n    client.on('connect', () => {\n      console.log(`Connected to broker: ${host}`);\n    });\n    client.on('offline', function () {\n      console.log('Client Offline');\n    });\n    return client;\n  }\n\n  /**\n   * Return Client as a promise (for using async and await) so that the code waits for a response\n   * @param host broker ip address and port\n   * @param options options applied to client\n   * @returns {Promise<mqtt.MqttClient | String>}\n   */\n\n  /**\n   * Method that extracts data from receivedData using the structure convention, then updates the values in dataObject\n   * @param receivedData raw json received from mqtt broker\n   * @param dataObject javascript json-like object reference to update (ref)\n   */\n  static updateDataFromJSON(receivedData, dataObject) {\n    if (dataObject) {\n      const parsed = JSON.parse(receivedData);\n      let component_name = \"\";\n      let message_name = \"\";\n      let field_name = \"\";\n      try {\n        component_name = parsed[\"component_name\"];\n        message_name = parsed[\"group_name\"];\n        parsed[\"fields\"].forEach(sensor => {\n          field_name = sensor[\"field_name\"];\n          if (sensor[\"field_name\"] === undefined) {\n            throw new Error(\"Received JSON is not well formatted\");\n          }\n          dataObject.value[component_name][message_name][field_name][0] = sensor[\"value\"];\n        });\n      } catch (err) {\n        console.log(err);\n      }\n    }\n  }\n}\nfunction _getClient(host, options) {\n  return new Promise((resolve, reject) => {\n    const client = mqtt.connect(host, options);\n    if (client) {\n      resolve(client);\n    } else reject(\"Client connection couldn't be established \");\n  });\n}","map":{"version":3,"names":["mqtt","MqttUtils","constructor","mqttClientPromise","messageCallback","Set","Error","on","eventName","callbackFunction","then","client","connected","unsubscribeAll","unsubscribeFrom","Array","from","resubscribeAll","subscribeTo","topics","console","log","forEach","topic","add","subscribe","delete","unsubscribe","getSubscribedTopicsSet","getMqttClient","clientId","host","options","keepalive","protocolId","protocolVersion","clean","reconnectPeriod","connectTimeout","will","payload","qos","retain","err","updateDataFromJSON","receivedData","dataObject","parsed","JSON","parse","component_name","message_name","field_name","sensor","undefined","value","Promise","resolve","reject","connect"],"sources":["/home/davidf/Desktop/SSB/ssb-interface-v2/src/composables/mqttUtils.mjs"],"sourcesContent":["import mqtt from \"precompiled-mqtt\";\n\nexport default class MqttUtils {\n    #mqttClientPromise = null\n    #subscribedTopics = new Set()\n    #previouslySubscribedTopics = new Set()\n\n    constructor(mqttClientPromise, messageCallback) {\n        if (!mqttClientPromise) throw new Error(\"No mqttClientPromise was provided\")\n        else this.#mqttClientPromise = mqttClientPromise\n\n        this.on(\"message\", messageCallback)\n    }\n\n    on(eventName, callbackFunction) {\n        this.#mqttClientPromise.then((client) => {\n            client.on(eventName, callbackFunction)\n        })\n    }\n\n    connected() {\n        return this.#mqttClientPromise.then((client) => {client.connected})\n    }\n\n    /**\n     * Unsubscribe from all the topics in #subscribedTopics\n     */\n    unsubscribeAll() {\n        this.#previouslySubscribedTopics = new Set(this.#subscribedTopics)\n        this.unsubscribeFrom(Array.from(this.#subscribedTopics))\n    }\n\n    /**\n     * Subscribe to all the topics in #previouslySubscribedTopics\n     */\n    resubscribeAll() {\n        this.subscribeTo(Array.from(this.#previouslySubscribedTopics))\n    }\n\n    /**\n     * Subscribe to topics\n     * @param topics Array of topics to subscribe to (not ref)\n     */\n    subscribeTo(topics){\n        console.log(\"subscribed to \" + topics)\n        topics.forEach(topic => this.#subscribedTopics.add(topic))\n        this.#mqttClientPromise.then((client) => {client.subscribe(topics)})\n    }\n\n    /**\n     * Subscribe from topics\n     * @param topics Array of topics to subscribe from (not ref)\n     */\n    unsubscribeFrom(topics){\n        console.log(\"subscribed from \" + topics)\n        topics.forEach(topic => this.#subscribedTopics.delete(topic))\n        this.#mqttClientPromise.then((client) => { client.unsubscribe(topics) })\n    }\n\n    getSubscribedTopicsSet(){\n        return this.#subscribedTopics\n    }\n\n//---------------------------------------------STATIC METHODS-----------------------------------------------\n    /**\n     * Asynchronous method that returns a promise, from which we can obtain the mqtt client if resolved.\n     * We use the MQTT.js library to communicate with broker through websockets (Not TCP - that's why I used precompiled-mqtt)\n     * @returns client\n     */\n    static async getMqttClient(){\n        const clientId = \"SSB_interface\"\n        const host = 'ws://34.65.125.98:9001'\n        //const host = 'ws://localhost:9001'\n\n        const options = {\n            keepalive: 60,\n            clientId: clientId,\n            protocolId: 'MQTT',\n            protocolVersion: 4,\n            clean: true,\n            reconnectPeriod: 1000,\n            connectTimeout: 30 * 1000,\n            will: {\n                topic: 'WillMsg',\n                payload: 'Connection Closed abnormally..!',\n                qos: 0,\n                retain: false\n            },\n        }\n\n        const client = await this.#getClient(host, options)\n\n        client.on('error', (err) => {\n            console.log('Connection error: ', err)\n        })\n        client.on('reconnect', () => {\n            console.log('Reconnecting...')\n        })\n        client.on('connect', () => {\n            console.log(`Connected to broker: ${host}`)\n        })\n\n        client.on('offline', function () {\n            console.log('Client Offline')\n        })\n\n        return client;\n    }\n\n    /**\n     * Return Client as a promise (for using async and await) so that the code waits for a response\n     * @param host broker ip address and port\n     * @param options options applied to client\n     * @returns {Promise<mqtt.MqttClient | String>}\n     */\n    static #getClient(host, options){\n        return new Promise((resolve, reject) => {\n            const client = mqtt.connect(host, options)\n\n            if(client){resolve(client)}\n            else reject(\"Client connection couldn't be established \")\n        })\n    }\n\n    /**\n     * Method that extracts data from receivedData using the structure convention, then updates the values in dataObject\n     * @param receivedData raw json received from mqtt broker\n     * @param dataObject javascript json-like object reference to update (ref)\n     */\n    static updateDataFromJSON(receivedData, dataObject) {\n        if (dataObject) {\n            const parsed = JSON.parse(receivedData)\n            let component_name = \"\"\n            let message_name = \"\"\n            let field_name = \"\"\n\n            try {\n                component_name = parsed[\"component_name\"]\n                message_name = parsed[\"group_name\"]\n\n                parsed[\"fields\"].forEach((sensor) => {\n                    field_name = sensor[\"field_name\"]\n\n                    if(sensor[\"field_name\"] === undefined) {throw new Error(\"Received JSON is not well formatted\")}\n                    dataObject.value[component_name][message_name][field_name][0] = sensor[\"value\"]\n                })\n            }\n            catch (err) {\n                console.log(err)\n            }\n        }\n    }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}