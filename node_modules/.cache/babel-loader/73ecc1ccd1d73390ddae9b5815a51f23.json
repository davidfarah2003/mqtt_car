{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { computed, inject, onActivated, onDeactivated, onMounted, onUnmounted, provide, ref, watch } from \"vue\";\nimport mqttUtils from \"@/composables/mqttUtils.mjs\";\nimport configUtils from \"@/composables/configUtils.mjs\";\nexport default {\n  props: ['subscribedTopics', 'mqttCallback'],\n  emits: ['dataObject'],\n  setup: function (props, _ref) {\n    let {\n      emit\n    } = _ref;\n    let connected = ref(false); //Boolean value that indicates if the client is connected to the broker\n    let dataObject = ref({}); //Object containing all our actual data, gets updated depending on subscribed topics\n    let subscribedTopics = ref([]); //Array containing the subscribed topics for this component\n    let dataIsPresent = ref(false);\n\n    /**\n     * Watch changes to the data and update them for the parent component\n     */\n    watch(dataObject, () => {\n      emit(\"dataObject\", dataObject);\n    });\n    let isActive = ref(false); //indicate if the Home component is isActive\n\n    //Use the configuration fetched from the api to build the dataObject\n    inject('apiClient').getConfig(\"CAN_out_config\").then(outConfig => {\n      let configUtil = new configUtils(outConfig);\n      dataObject.value = configUtil.getDataObject();\n      dataIsPresent.value = true;\n    });\n\n    //Use the mqtt client to create an mqttUtil instance, and update our data automatically with a callback\n    const MqttCallback = (topic, message) => {\n      mqttUtils.updateDataFromJSON(message, dataObject);\n    };\n    let mqttUtil = new mqttUtils(inject('mqttClient'), MqttCallback);\n    watch(subscribedTopics, () => {\n      if (isActive.value) {\n        console.log(\"subscribed to \" + subscribedTopics);\n        mqttUtil.subscribeTo(props.subscribedTopics);\n      }\n    });\n\n    /**\n     * Subscribe to the required topics if not already done\n     * @param requiredValues array of required values containing path Strings\n     */\n    const subscribeFromFields = requiredValues => {\n      let fieldPathArray = [];\n      Object.entries(requiredValues).forEach(_ref2 => {\n        let [, fieldPath] = _ref2;\n        fieldPathArray = fieldPath.split(\"/\");\n        subscribedTopics.value.push(`${fieldPathArray[0]}/${fieldPathArray[1]}`);\n      });\n    };\n\n    /**\n     * Update the data of a module based on their required values\n     * @param requiredValues array of required values containing path Strings\n     * @param childData The data object of the module. follows the same convention\n     */\n    const updateChildData = (requiredValues, childData) => {\n      let fieldPathArray = [];\n      Object.entries(requiredValues).forEach(_ref3 => {\n        let [fieldName, fieldPath] = _ref3;\n        fieldPathArray = fieldPath.split(\"/\");\n        childData.value[fieldName] = dataObject.value[fieldPathArray[0]][fieldPathArray[1]][fieldPathArray[2]];\n      });\n    };\n\n    /**\n     * Return true if a child module can request an update, false otherwise\n     * We use dataIsPresent instead of the dataObject because it could be partially written (not null but not ready)\n     * @type {ComputedRef<boolean>}\n     */\n    const canUpdateChildData = computed(() => {\n      return dataIsPresent.value && isActive.value;\n    });\n    onActivated(() => {\n      isActive.value = true;\n      mqttUtil.subscribeTo(props.subscribedTopics);\n    });\n    onDeactivated(() => {\n      isActive.value = false;\n      mqttUtil.resetClient();\n    });\n\n    /**\n     * Add listeners to update the connected status\n     */\n    function addConnectedListeners() {\n      console.log(\"update vars\");\n      //Update connected status correctly\n      if (mqttUtil.connected()) connected.value = true;\n      mqttUtil.on('connect', () => connected.value = true);\n      mqttUtil.on('disconnect', () => connected.value = false);\n      mqttUtil.on('reconnect', () => connected.value = false);\n    }\n    addConnectedListeners();\n    return {\n      dataObject,\n      connected,\n      subscribeFromFields,\n      updateChildData,\n      canUpdateChildData,\n      subscribedTopics\n    };\n  }\n};","map":{"version":3,"mappings":"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","names":["computed","inject","onActivated","onDeactivated","onMounted","onUnmounted","provide","ref","watch","mqttUtils","configUtils","props","emits","setup","emit","connected","dataObject","subscribedTopics","dataIsPresent","isActive","getConfig","then","outConfig","configUtil","value","getDataObject","MqttCallback","topic","message","updateDataFromJSON","mqttUtil","console","log","subscribeTo","subscribeFromFields","requiredValues","fieldPathArray","Object","entries","forEach","fieldPath","split","push","updateChildData","childData","fieldName","canUpdateChildData","resetClient","addConnectedListeners","on"],"sourceRoot":"","sources":["/home/davidf/Desktop/SSB/ssb-interface-v2/src/views/ConnectedView.vue"],"sourcesContent":["<template>\n  <section class=\"app-main\">\n    <slot :connected=\"connected\"\n          :dataObject=\"dataObject\"\n          :subscribedTopics=\"subscribedTopics\"\n          :subscribeFromFields=\"subscribeFromFields\"\n          :updateChildData=\"updateChildData\"\n          :canUpdateChildData=\"canUpdateChildData\"\n    />\n  </section>\n</template>\n\n<script>\n\nimport {computed, inject, onActivated, onDeactivated, onMounted, onUnmounted, provide, ref, watch} from \"vue\";\nimport mqttUtils from \"@/composables/mqttUtils.mjs\";\nimport configUtils from \"@/composables/configUtils.mjs\";\n\nexport default {\n  props: ['subscribedTopics', 'mqttCallback'],\n  emits: ['dataObject'],\n\n  setup: function (props, { emit }) {\n    let connected = ref(false); //Boolean value that indicates if the client is connected to the broker\n    let dataObject = ref({})  //Object containing all our actual data, gets updated depending on subscribed topics\n    let subscribedTopics = ref([]); //Array containing the subscribed topics for this component\n    let dataIsPresent = ref(false)\n\n    /**\n     * Watch changes to the data and update them for the parent component\n     */\n    watch(dataObject, ()=>{\n      emit(\"dataObject\", dataObject)\n    })\n\n    let isActive = ref(false);  //indicate if the Home component is isActive\n\n    //Use the configuration fetched from the api to build the dataObject\n    inject('apiClient').getConfig(\"CAN_out_config\").then((outConfig)=> {\n      let configUtil = new configUtils(outConfig)\n      dataObject.value = configUtil.getDataObject()\n      dataIsPresent.value = true\n    })\n\n    //Use the mqtt client to create an mqttUtil instance, and update our data automatically with a callback\n    const MqttCallback = (topic, message) => {\n      mqttUtils.updateDataFromJSON(message, dataObject)\n    }\n    let mqttUtil = new mqttUtils(inject('mqttClient'), MqttCallback)\n\n    watch(subscribedTopics, ()=>{\n      if (isActive.value) {\n        console.log(\"subscribed to \" + subscribedTopics)\n        mqttUtil.subscribeTo(props.subscribedTopics)\n      }\n    })\n\n    /**\n     * Subscribe to the required topics if not already done\n     * @param requiredValues array of required values containing path Strings\n     */\n    const subscribeFromFields = (requiredValues) => {\n      let fieldPathArray = []\n      Object.entries(requiredValues).forEach(([, fieldPath])=>{\n        fieldPathArray = fieldPath.split(\"/\")\n        subscribedTopics.value.push(`${fieldPathArray[0]}/${fieldPathArray[1]}`)\n      })\n    }\n\n    /**\n     * Update the data of a module based on their required values\n     * @param requiredValues array of required values containing path Strings\n     * @param childData The data object of the module. follows the same convention\n     */\n    const updateChildData = (requiredValues, childData) => {\n      let fieldPathArray = []\n\n      Object.entries(requiredValues).forEach(([fieldName, fieldPath]) => {\n        fieldPathArray = fieldPath.split(\"/\")\n        childData.value[fieldName] = dataObject.value[fieldPathArray[0]][fieldPathArray[1]][fieldPathArray[2]]\n      })\n    }\n\n    /**\n     * Return true if a child module can request an update, false otherwise\n     * We use dataIsPresent instead of the dataObject because it could be partially written (not null but not ready)\n     * @type {ComputedRef<boolean>}\n     */\n    const canUpdateChildData = computed(()=>{\n      return (dataIsPresent.value && isActive.value)\n    })\n\n    onActivated(()=> {\n      isActive.value = true\n      mqttUtil.subscribeTo(props.subscribedTopics)\n    })\n\n    onDeactivated(()=> {\n      isActive.value = false\n      mqttUtil.resetClient()\n    })\n\n    /**\n     * Add listeners to update the connected status\n     */\n    function addConnectedListeners(){\n      console.log(\"update vars\")\n      //Update connected status correctly\n      if(mqttUtil.connected()) connected.value = true\n      mqttUtil.on('connect', () => connected.value = true)\n      mqttUtil.on('disconnect', () => connected.value = false)\n      mqttUtil.on('reconnect', () => connected.value = false)\n    }\n    addConnectedListeners()\n\n\n    return {dataObject, connected, subscribeFromFields, updateChildData, canUpdateChildData, subscribedTopics}\n  }\n}\n\n</script>\n\n<style scoped>\n\n</style>\n"]},"metadata":{},"sourceType":"module"}