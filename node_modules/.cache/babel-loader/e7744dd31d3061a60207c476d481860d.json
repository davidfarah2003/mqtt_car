{"ast":null,"code":"import _classPrivateFieldInitSpec from \"/home/davidf/Desktop/SSB/ssb-interface-v2/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classStaticPrivateMethodGet from \"/home/davidf/Desktop/SSB/ssb-interface-v2/node_modules/@babel/runtime/helpers/esm/classStaticPrivateMethodGet.js\";\nimport _classPrivateFieldGet from \"/home/davidf/Desktop/SSB/ssb-interface-v2/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport _classPrivateFieldSet from \"/home/davidf/Desktop/SSB/ssb-interface-v2/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nimport mqtt from \"precompiled-mqtt\";\nvar _mqttClientPromise = /*#__PURE__*/new WeakMap();\nvar _subscribedTopics = /*#__PURE__*/new WeakMap();\nexport default class MqttUtils {\n  constructor(mqttClientPromise, messageCallback) {\n    _classPrivateFieldInitSpec(this, _mqttClientPromise, {\n      writable: true,\n      value: null\n    });\n    _classPrivateFieldInitSpec(this, _subscribedTopics, {\n      writable: true,\n      value: new Set()\n    });\n    if (!mqttClientPromise) throw new Error(\"No mqttClientPromise was provided\");else _classPrivateFieldSet(this, _mqttClientPromise, mqttClientPromise);\n    this.on(\"message\", messageCallback);\n  }\n  on(eventName, callbackFunction) {\n    _classPrivateFieldGet(this, _mqttClientPromise).then(client => {\n      client.on(eventName, callbackFunction);\n    });\n  }\n  connected() {\n    return _classPrivateFieldGet(this, _mqttClientPromise).then(client => {\n      client.connected;\n    });\n  }\n\n  /**\n   * Cleanup the mqtt client when unmounting\n   */\n  resetClient() {\n    this.unsubscribeFrom(Array.from(_classPrivateFieldGet(this, _subscribedTopics)));\n  }\n\n  /**\n   * Subscribe to the topics indicated in the subscribedTopics array\n   */\n  subscribeTo(topics) {\n    topics.forEach(topic => _classPrivateFieldGet(this, _subscribedTopics).add(topic));\n    _classPrivateFieldGet(this, _mqttClientPromise).then(client => {\n      client.subscribe(topics);\n    });\n  }\n\n  /**\n   * Unsubscribe from the topics indicated in the subscribedTopics array\n   */\n  unsubscribeFrom(topics) {\n    topics.forEach(topic => _classPrivateFieldGet(this, _subscribedTopics).delete(topic));\n    _classPrivateFieldGet(this, _mqttClientPromise).then(client => {\n      client.unsubscribe(topics);\n    });\n  }\n\n  //---------------------------------------------STATIC METHODS-----------------------------------------------\n  /**\n   * Asynchronous method that returns a promise, from which we can obtain the mqtt client if resolved.\n   * We use the MQTT.js library to communicate with broker through websockets (Not TCP - that's why I used precompiled-mqtt)\n   * @returns client\n   */\n  static async getMqttClient() {\n    const clientId = \"SSB_interface\";\n    const host = 'ws://34.65.125.98:9001';\n    //const host = 'ws://localhost:9001'\n\n    const options = {\n      keepalive: 60,\n      clientId: clientId,\n      protocolId: 'MQTT',\n      protocolVersion: 4,\n      clean: true,\n      reconnectPeriod: 1000,\n      connectTimeout: 30 * 1000,\n      will: {\n        topic: 'WillMsg',\n        payload: 'Connection Closed abnormally..!',\n        qos: 0,\n        retain: false\n      }\n    };\n    const client = await _classStaticPrivateMethodGet(this, MqttUtils, _getClient).call(this, host, options);\n    client.on('error', err => {\n      console.log('Connection error: ', err);\n    });\n    client.on('reconnect', () => {\n      console.log('Reconnecting...');\n    });\n    client.on('connect', () => {\n      console.log(`Connected to broker: ${host}`);\n    });\n    client.on('offline', function () {\n      console.log('Client Offline');\n    });\n    return client;\n  }\n\n  /**\n   * Return Client as a promise (for using async and await) so that the code waits for a response\n   * @param host broker ip address and port\n   * @param options options applied to client\n   * @returns {Promise<mqtt.MqttClient | String>}\n   */\n\n  /**\n   * Method that extracts data from receivedData using the structure convention, then updates the values in dataObject\n   * @param receivedData raw json received from mqtt broker\n   * @param dataObject javascript json-like object reference to update (ref)\n   */\n  static updateDataFromJSON(receivedData, dataObject) {\n    if (dataObject) {\n      const parsed = JSON.parse(receivedData);\n      let component_name = \"\";\n      let message_name = \"\";\n      let field_name = \"\";\n      try {\n        component_name = parsed[\"component_name\"];\n        message_name = parsed[\"group_name\"];\n        parsed[\"fields\"].forEach(sensor => {\n          field_name = sensor[\"field_name\"];\n          if (sensor[\"field_name\"] === undefined) {\n            throw new Error(\"Received JSON is not well formatted\");\n          }\n          dataObject.value[component_name][message_name][field_name] = sensor[\"value\"];\n        });\n      } catch (err) {\n        console.log(err);\n      }\n    }\n  }\n}\nfunction _getClient(host, options) {\n  return new Promise((resolve, reject) => {\n    const client = mqtt.connect(host, options);\n    if (client) {\n      resolve(client);\n    } else reject(\"Client connection couldn't be established \");\n  });\n}","map":{"version":3,"names":["mqtt","MqttUtils","constructor","mqttClientPromise","messageCallback","Set","Error","on","eventName","callbackFunction","then","client","connected","resetClient","unsubscribeFrom","Array","from","subscribeTo","topics","forEach","topic","add","subscribe","delete","unsubscribe","getMqttClient","clientId","host","options","keepalive","protocolId","protocolVersion","clean","reconnectPeriod","connectTimeout","will","payload","qos","retain","err","console","log","updateDataFromJSON","receivedData","dataObject","parsed","JSON","parse","component_name","message_name","field_name","sensor","undefined","value","Promise","resolve","reject","connect"],"sources":["/home/davidf/Desktop/SSB/ssb-interface-v2/src/composables/mqttUtils.mjs"],"sourcesContent":["import mqtt from \"precompiled-mqtt\";\n\nexport default class MqttUtils {\n    #mqttClientPromise = null\n    #subscribedTopics = new Set()\n\n    constructor(mqttClientPromise, messageCallback) {\n        if (!mqttClientPromise) throw new Error(\"No mqttClientPromise was provided\")\n        else this.#mqttClientPromise = mqttClientPromise\n\n        this.on(\"message\", messageCallback)\n    }\n\n    on(eventName, callbackFunction) {\n        this.#mqttClientPromise.then((client) => {\n            client.on(eventName, callbackFunction)\n        })\n    }\n\n    connected() {\n        return this.#mqttClientPromise.then((client) => {client.connected})\n    }\n\n    /**\n     * Cleanup the mqtt client when unmounting\n     */\n    resetClient() {\n        this.unsubscribeFrom(Array.from(this.#subscribedTopics))\n    }\n\n    /**\n     * Subscribe to the topics indicated in the subscribedTopics array\n     */\n    subscribeTo(topics){\n        topics.forEach(topic => this.#subscribedTopics.add(topic))\n        this.#mqttClientPromise.then((client) => {client.subscribe(topics)})\n    }\n\n    /**\n     * Unsubscribe from the topics indicated in the subscribedTopics array\n     */\n    unsubscribeFrom(topics){\n        topics.forEach(topic => this.#subscribedTopics.delete(topic))\n        this.#mqttClientPromise.then((client) => { client.unsubscribe(topics) })\n    }\n\n//---------------------------------------------STATIC METHODS-----------------------------------------------\n    /**\n     * Asynchronous method that returns a promise, from which we can obtain the mqtt client if resolved.\n     * We use the MQTT.js library to communicate with broker through websockets (Not TCP - that's why I used precompiled-mqtt)\n     * @returns client\n     */\n    static async getMqttClient(){\n        const clientId = \"SSB_interface\"\n        const host = 'ws://34.65.125.98:9001'\n        //const host = 'ws://localhost:9001'\n\n        const options = {\n            keepalive: 60,\n            clientId: clientId,\n            protocolId: 'MQTT',\n            protocolVersion: 4,\n            clean: true,\n            reconnectPeriod: 1000,\n            connectTimeout: 30 * 1000,\n            will: {\n                topic: 'WillMsg',\n                payload: 'Connection Closed abnormally..!',\n                qos: 0,\n                retain: false\n            },\n        }\n\n        const client = await this.#getClient(host, options)\n\n        client.on('error', (err) => {\n            console.log('Connection error: ', err)\n        })\n        client.on('reconnect', () => {\n            console.log('Reconnecting...')\n        })\n        client.on('connect', () => {\n            console.log(`Connected to broker: ${host}`)\n        })\n\n        client.on('offline', function () {\n            console.log('Client Offline')\n        })\n\n        return client;\n    }\n\n    /**\n     * Return Client as a promise (for using async and await) so that the code waits for a response\n     * @param host broker ip address and port\n     * @param options options applied to client\n     * @returns {Promise<mqtt.MqttClient | String>}\n     */\n    static #getClient(host, options){\n        return new Promise((resolve, reject) => {\n            const client = mqtt.connect(host, options)\n\n            if(client){resolve(client)}\n            else reject(\"Client connection couldn't be established \")\n        })\n    }\n\n    /**\n     * Method that extracts data from receivedData using the structure convention, then updates the values in dataObject\n     * @param receivedData raw json received from mqtt broker\n     * @param dataObject javascript json-like object reference to update (ref)\n     */\n    static updateDataFromJSON(receivedData, dataObject) {\n        if (dataObject) {\n            const parsed = JSON.parse(receivedData)\n            let component_name = \"\"\n            let message_name = \"\"\n            let field_name = \"\"\n\n            try {\n                component_name = parsed[\"component_name\"]\n                message_name = parsed[\"group_name\"]\n\n                parsed[\"fields\"].forEach((sensor) => {\n                    field_name = sensor[\"field_name\"]\n\n                    if(sensor[\"field_name\"] === undefined) {throw new Error(\"Received JSON is not well formatted\")}\n                    dataObject.value[component_name][message_name][field_name] = sensor[\"value\"]\n                })\n            }\n            catch (err) {\n                console.log(err)\n            }\n        }\n    }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}