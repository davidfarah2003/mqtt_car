{"ast":null,"code":"import { renderSlot as _renderSlot, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = {\n  class: \"app-main\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"section\", _hoisted_1, [_renderSlot(_ctx.$slots, \"default\", {\n    connected: _ctx.connected,\n    dataObject: _ctx.dataObject\n  })]);\n}","map":{"version":3,"mappings":";;EACWA,KAAK,EAAC;AAAU;;uBAAzBC,oBAIU,WAJVC,UAIU,GAHRC,YAEEC;IAFKC,SAAS,EAAED,cAAS;IACpBE,UAAU,EAAEF","names":["class","_createElementBlock","_hoisted_1","_renderSlot","_ctx","connected","dataObject"],"sourceRoot":"","sources":["/home/davidf/Desktop/SSB/ssb-interface-v2/src/views/ConnectedView.vue"],"sourcesContent":["<template>\n  <section class=\"app-main\">\n    <slot :connected=\"connected\"\n          :dataObject=\"dataObject\"\n    />\n  </section>\n</template>\n\n<script>\n\nimport {inject, onActivated, onDeactivated, onMounted, onUnmounted, provide, ref, watch} from \"vue\";\nimport mqttUtils from \"@/composables/mqttUtils.mjs\";\nimport configUtils from \"@/composables/configUtils.mjs\";\n\nexport default {\n  props: ['subscribedTopics', 'mqttCallback'],\n  emits: ['dataObject'],\n\n  setup: function (props, { emit }) {\n    let connected = ref(false); //Boolean value that indicates if the client is connected to the broker\n    let dataObject = ref({})  //Object containing all our actual data, gets updated depending on subscribed topics\n\n    /**\n     * Watch changes to the data and update them for the parent component\n     */\n    watch(dataObject, ()=>{\n      emit(\"dataObject\", dataObject)\n    })\n\n    let mounted = false;  //indicate if the Home component is mounted\n\n    //Use the configuration fetched from the api to build the dataObject\n    inject('apiClient').getConfig(\"CAN_out_config\").then((outConfig)=> {\n      let configUtil = new configUtils(outConfig)\n      dataObject.value = configUtil.getDataObject()\n    })\n\n    //Use the mqtt client to create an mqttUtil instance, and update our data automatically with a callback\n    const MqttCallback = (topic, message) => {\n      mqttUtils.updateDataFromJSON(message, dataObject)\n    }\n    let mqttUtil = new mqttUtils(inject('mqttClient'), MqttCallback)\n\n    watch(props.subscribedTopics, ()=>{\n      console.log(\"subscribed to \" + props.subscribedTopics)\n      mqttUtil.subscribeTo(props.subscribedTopics)\n\n      //this is not working for some reason\n      if (mounted) {\n        console.log(\"subscribed to \" + props.subscribedTopics)\n        mqttUtil.subscribeTo(props.subscribedTopics)\n      }\n    })\n\n    onActivated(()=> {\n      mounted = true\n      console.log(props.subscribedTopics.value)\n      mqttUtil.subscribeTo(props.subscribedTopics)\n    })\n\n    onDeactivated(()=> {\n      mounted = false\n      mqttUtil.resetClient()\n    })\n\n    /**\n     * Add listeners to update the connected status\n     */\n    function addConnectedListeners(){\n      console.log(\"update vars\")\n      //Update connected status correctly\n      if(mqttUtil.connected()) connected.value = true\n      mqttUtil.on('connect', () => connected.value = true)\n      mqttUtil.on('disconnect', () => connected.value = false)\n      mqttUtil.on('reconnect', () => connected.value = false)\n    }\n    addConnectedListeners()\n\n\n    return {dataObject, connected}\n  }\n}\n\n</script>\n\n<style scoped>\n\n</style>\n"]},"metadata":{},"sourceType":"module"}