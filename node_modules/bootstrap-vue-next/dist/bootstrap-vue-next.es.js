var Tn = Object.defineProperty;
var Vn = (e, t, a) => t in e ? Tn(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a;
var be = (e, t, a) => (Vn(e, typeof t != "symbol" ? t + "" : t, a), a);
import { shallowRef as al, watchEffect as Ze, readonly as Ht, unref as s, ref as K, isRef as tt, watch as ce, getCurrentScope as An, onScopeDispose as On, getCurrentInstance as ll, onMounted as ke, nextTick as Ie, computed as i, reactive as Ne, inject as He, onBeforeUnmount as ta, toRef as o, onActivated as aa, defineComponent as I, provide as at, openBlock as f, createElementBlock as h, normalizeClass as L, renderSlot as B, createBlock as N, resolveDynamicComponent as Z, withCtx as M, createElementVNode as j, withDirectives as Ge, createTextVNode as ee, toDisplayString as W, createVNode as ve, Transition as nl, normalizeProps as Be, guardReactiveProps as _e, useSlots as Se, createCommentVNode as X, mergeProps as Q, resolveComponent as ol, withModifiers as Xe, Fragment as ie, normalizeStyle as Fe, renderList as me, withKeys as yt, vShow as la, isReactive as xn, onUnmounted as Pn, h as le, useAttrs as sl, vModelCheckbox as In, vModelRadio as Fn, vModelSelect as En, Teleport as rl, createSlots as il } from "vue";
import { Collapse as Ln, Popover as Mt, Tooltip as Lt, Dropdown as zn } from "bootstrap";
const Nn = (e) => typeof e == "boolean" || e === "" || e === "true" || e === "false", ul = (e) => typeof e == "boolean" ? e : e === "" ? !0 : e === "true";
class De {
  constructor(t, a = {}) {
    be(this, "cancelable", !0);
    be(this, "componentId", null);
    be(this, "_defaultPrevented", !1);
    be(this, "eventType", "");
    be(this, "nativeEvent", null);
    be(this, "_preventDefault");
    be(this, "relatedTarget", null);
    be(this, "target", null);
    if (!t)
      throw new TypeError(
        `Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`
      );
    Object.assign(this, De.Defaults, a, { eventType: t }), this._preventDefault = function() {
      this.cancelable && (this.defaultPrevented = !0);
    };
  }
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  set defaultPrevented(t) {
    this._defaultPrevented = t;
  }
  get preventDefault() {
    return this._preventDefault;
  }
  set preventDefault(t) {
    this._preventDefault = t;
  }
  static get Defaults() {
    return {
      cancelable: !0,
      componentId: null,
      eventType: "",
      nativeEvent: null,
      relatedTarget: null,
      target: null
    };
  }
}
class na extends De {
  constructor(a, l = {}) {
    super(a, l);
    be(this, "trigger", null);
    Object.assign(this, De.Defaults, l, { eventType: a });
  }
  static get Defaults() {
    return {
      ...super.Defaults,
      trigger: null
    };
  }
}
class dl extends De {
  constructor(a, l) {
    super(a, l);
    be(this, "from");
    be(this, "to");
    be(this, "direction");
    Object.assign(this, De.Defaults, l, { eventType: a });
    const { from: n, direction: r, to: d } = l;
    this.from = n, this.to = d, this.direction = r;
  }
  static get Defaults() {
    return {
      ...super.Defaults
    };
  }
}
const Rt = (e) => e !== null && typeof e == "object", cl = (e) => /^[0-9]*\.?[0-9]+$/.test(String(e)), Dn = (e) => Object.prototype.toString.call(e) === "[object Object]", ze = (e) => e === null, fl = /_/g, vl = /([a-z])([A-Z])/g, Hn = /(\s|^)(\w)/g, Mn = /(\s|^)(\w)/, pt = /\s+/, Rn = /^#/, jn = /^#[A-Za-z]+[\w\-:.]*$/, qn = /-u-.+/, Bt = (e, t = 2) => typeof e == "string" ? e : e == null ? "" : Array.isArray(e) || Dn(e) && e.toString === Object.prototype.toString ? JSON.stringify(e, null, t) : String(e), va = (e) => e.replace(fl, " ").replace(vl, (t, a, l) => `${a} ${l}`).replace(Mn, (t, a, l) => a + l.toUpperCase()), ma = (e) => e.replace(fl, " ").replace(vl, (t, a, l) => `${a} ${l}`).replace(Hn, (t, a, l) => a + l.toUpperCase()), Gn = (e) => {
  const t = e.trim();
  return t.charAt(0).toUpperCase() + t.slice(1);
}, zt = (e) => `\\${e}`, Un = (e) => {
  const t = Bt(e), { length: a } = t, l = t.charCodeAt(0);
  return t.split("").reduce((n, r, d) => {
    const c = t.charCodeAt(d);
    return c === 0 ? `${n}\uFFFD` : c === 127 || c >= 1 && c <= 31 || d === 0 && c >= 48 && c <= 57 || d === 1 && c >= 48 && c <= 57 && l === 45 ? n + zt(`${c.toString(16)} `) : d === 0 && c === 45 && a === 1 ? n + zt(r) : c >= 128 || c === 45 || c === 95 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 ? n + r : n + zt(r);
  }, "");
}, ml = typeof window < "u", pl = typeof document < "u", Wn = typeof Element < "u", bl = typeof navigator < "u", Tt = ml && pl && bl, Ke = ml ? window : {}, Vt = pl ? document : {}, gl = bl ? navigator : {}, hl = (gl.userAgent || "").toLowerCase();
hl.indexOf("jsdom") > 0;
/msie|trident/.test(hl);
(() => {
  let e = !1;
  if (Tt)
    try {
      const t = {
        get passive() {
          return e = !0, e;
        }
      };
      Ke.addEventListener("test", t, t), Ke.removeEventListener("test", t, t);
    } catch {
      e = !1;
    }
  return e;
})();
Tt && ("ontouchstart" in Vt.documentElement || gl.maxTouchPoints > 0);
Tt && Boolean(Ke.PointerEvent || Ke.MSPointerEvent);
Tt && "IntersectionObserver" in Ke && "IntersectionObserverEntry" in Ke && "intersectionRatio" in Ke.IntersectionObserverEntry.prototype;
const oa = typeof window < "u", Kn = typeof document < "u", Xn = typeof navigator < "u", yl = oa && Kn && Xn, pa = oa ? window : {}, Jn = (() => {
  let e = !1;
  if (yl)
    try {
      const t = {
        get passive() {
          e = !0;
        }
      };
      pa.addEventListener("test", t, t), pa.removeEventListener("test", t, t);
    } catch {
      e = !1;
    }
  return e;
})(), Oe = Wn ? Element.prototype : void 0, Qn = (Oe == null ? void 0 : Oe.matches) || (Oe == null ? void 0 : Oe.msMatchesSelector) || (Oe == null ? void 0 : Oe.webkitMatchesSelector), Le = (e) => !!(e && e.nodeType === Node.ELEMENT_NODE), Yn = (e) => Le(e) ? e.getBoundingClientRect() : null, Zn = (e = []) => {
  const { activeElement: t } = document;
  return t && !e.some((a) => a === t) ? t : null;
}, eo = (e) => Le(e) && e === Zn(), to = (e, t = {}) => {
  try {
    e.focus(t);
  } catch (a) {
    console.error(a);
  }
  return eo(e);
}, ao = (e, t) => t && Le(e) && e.getAttribute(t) || null, lo = (e) => {
  if (ao(e, "display") === "none")
    return !1;
  const t = Yn(e);
  return !!(t && t.height > 0 && t.width > 0);
}, we = (e) => {
  var t;
  return ((t = e == null ? void 0 : e()) != null ? t : []).length === 0;
}, Bl = (e, t) => (Le(t) ? t : Vt).querySelector(e) || null, no = (e, t) => Array.from([(Le(t) ? t : Vt).querySelectorAll(e)]), sa = (e, t) => t && Le(e) ? e.getAttribute(t) : null, oo = (e) => Vt.getElementById(/^#/.test(e) ? e.slice(1) : e) || null, so = (e, t, a) => {
  t && Le(e) && e.setAttribute(t, a);
}, ro = (e, t) => {
  t && Le(e) && e.removeAttribute(t);
}, io = (e, t) => Bt(e).toLowerCase() === Bt(t).toLowerCase(), ft = oa ? window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || ((e) => setTimeout(e, 16)) : (e) => setTimeout(e, 0), $l = (e, t) => Le(e) ? Qn.call(e, t) : !1, uo = (Oe == null ? void 0 : Oe.closest) || function(e) {
  let t = this;
  if (!t)
    return null;
  do {
    if ($l(t, e))
      return t;
    t = t.parentElement || t.parentNode;
  } while (t !== null && t.nodeType === Node.ELEMENT_NODE);
  return null;
}, ba = (e, t, a = !1) => {
  if (!Le(t))
    return null;
  const l = uo.call(t, e);
  return a ? l : l === t ? null : l;
}, At = (e, t, a) => t.concat(["sm", "md", "lg", "xl", "xxl"]).reduce((l, n) => (l[e ? `${e}${n.charAt(0).toUpperCase() + n.slice(1)}` : n] = a, l), /* @__PURE__ */ Object.create(null)), kl = (e, t, a, l = a) => Object.keys(t).reduce((n, r) => (e[r] && n.push(
  [l, r.replace(a, ""), e[r]].filter((d) => d && typeof d != "boolean").join("-").toLowerCase()
), n), []), Re = (e = "") => `__BVID__${Math.random().toString().slice(2, 8)}___BV_${e}__`, it = (e) => !!(e.href || e.to), Nt = (e) => !!e && typeof e == "object" && e.constructor === Object, jt = (e, t, a = !0) => {
  const l = e instanceof Date && typeof e.getMonth == "function" ? new Date(e.getTime()) : Object.assign({}, e);
  return Nt(e) && Nt(t) && Object.keys(t).forEach((n) => {
    Nt(t[n]) ? n in e ? l[n] = jt(e[n], t[n], a) : Object.assign(l, { [n]: t[n] }) : Array.isArray(t[n]) && Array.isArray(e[n]) ? Object.assign(l, {
      [n]: a ? e[n].concat(
        t[n].filter((r) => !e[n].includes(r))
      ) : t[n]
    }) : Object.assign(l, { [n]: t[n] });
  }), l;
}, Pe = (e, t = {}, a = {}) => {
  const l = [e];
  let n;
  for (let r = 0; r < l.length && !n; r++) {
    const d = l[r];
    n = a[d];
  }
  return n && typeof n == "function" ? n(t) : n;
}, je = (e, t = NaN) => Number.isInteger(e) ? e : t, ot = (e, t = NaN) => {
  const a = Number.parseInt(e, 10);
  return Number.isNaN(a) ? t : a;
}, rt = (e, t = NaN) => {
  const a = Number.parseFloat(e.toString());
  return Number.isNaN(a) ? t : a;
}, Ot = (e, t) => Object.keys(e).filter((a) => !t.includes(a)).reduce((a, l) => ({ ...a, [l]: e[l] }), {}), $t = (e) => Array.isArray(e) ? e.map((t) => $t(t)) : e instanceof Date ? new Date(e.getTime()) : e && typeof e == "object" ? Object.getOwnPropertyNames(e).reduce((t, a) => {
  var l;
  return Object.defineProperty(t, a, (l = Object.getOwnPropertyDescriptor(e, a)) != null ? l : {}), t[a] = $t(e[a]), t;
}, Object.create(Object.getPrototypeOf(e))) : e, qt = (e) => new Promise((t) => t($t(e))), ga = (e, t) => t + (e ? Gn(e) : ""), ra = (e, t) => (Array.isArray(t) ? t.slice() : Object.keys(t)).reduce(
  (a, l) => (a[l] = e[l], a),
  {}
), xt = (e, t) => e === !0 || e === "true" || e === "" ? "true" : e === "grammar" || e === "spelling" ? e : t === !1 ? "true" : e === !1 || e === "false" ? "false" : void 0, Sl = Symbol(), Cl = Symbol(), wl = Symbol(), _l = Symbol(), Tl = Symbol(), Vl = Symbol(), Al = Symbol();
var co = Object.defineProperty, fo = Object.defineProperties, vo = Object.getOwnPropertyDescriptors, ha = Object.getOwnPropertySymbols, mo = Object.prototype.hasOwnProperty, po = Object.prototype.propertyIsEnumerable, ya = (e, t, a) => t in e ? co(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a, bo = (e, t) => {
  for (var a in t || (t = {}))
    mo.call(t, a) && ya(e, a, t[a]);
  if (ha)
    for (var a of ha(t))
      po.call(t, a) && ya(e, a, t[a]);
  return e;
}, go = (e, t) => fo(e, vo(t));
function Ol(e, t) {
  var a;
  const l = al();
  return Ze(() => {
    l.value = e();
  }, go(bo({}, t), {
    flush: (a = t == null ? void 0 : t.flush) != null ? a : "sync"
  })), Ht(l);
}
var Ba;
const kt = typeof window < "u", xl = (e) => typeof e == "function", ho = (e) => typeof e == "string", yo = () => {
};
kt && ((Ba = window == null ? void 0 : window.navigator) == null ? void 0 : Ba.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function We(e) {
  return typeof e == "function" ? e() : s(e);
}
function Bo(e, t) {
  function a(...l) {
    return new Promise((n, r) => {
      Promise.resolve(e(() => t.apply(this, l), { fn: t, thisArg: this, args: l })).then(n).catch(r);
    });
  }
  return a;
}
const Pl = (e) => e();
function $o(e = Pl) {
  const t = K(!0);
  function a() {
    t.value = !1;
  }
  function l() {
    t.value = !0;
  }
  return { isActive: t, pause: a, resume: l, eventFilter: (...r) => {
    t.value && e(...r);
  } };
}
function ko(e) {
  return e;
}
function St(e) {
  return An() ? (On(e), !0) : !1;
}
function So(e) {
  return typeof e == "function" ? i(e) : K(e);
}
function Il(e, t = !0) {
  ll() ? ke(e) : t ? e() : Ie(e);
}
function Fl(e, t = 1e3, a = {}) {
  const {
    immediate: l = !0,
    immediateCallback: n = !1
  } = a;
  let r = null;
  const d = K(!1);
  function c() {
    r && (clearInterval(r), r = null);
  }
  function v() {
    d.value = !1, c();
  }
  function m() {
    s(t) <= 0 || (d.value = !0, n && e(), c(), r = setInterval(e, We(t)));
  }
  if (l && kt && m(), tt(t) || xl(t)) {
    const S = ce(t, () => {
      d.value && kt && m();
    });
    St(S);
  }
  return St(v), {
    isActive: d,
    pause: v,
    resume: m
  };
}
var $a = Object.getOwnPropertySymbols, Co = Object.prototype.hasOwnProperty, wo = Object.prototype.propertyIsEnumerable, _o = (e, t) => {
  var a = {};
  for (var l in e)
    Co.call(e, l) && t.indexOf(l) < 0 && (a[l] = e[l]);
  if (e != null && $a)
    for (var l of $a(e))
      t.indexOf(l) < 0 && wo.call(e, l) && (a[l] = e[l]);
  return a;
};
function To(e, t, a = {}) {
  const l = a, {
    eventFilter: n = Pl
  } = l, r = _o(l, [
    "eventFilter"
  ]);
  return ce(e, Bo(n, t), r);
}
var Vo = Object.defineProperty, Ao = Object.defineProperties, Oo = Object.getOwnPropertyDescriptors, Ct = Object.getOwnPropertySymbols, El = Object.prototype.hasOwnProperty, Ll = Object.prototype.propertyIsEnumerable, ka = (e, t, a) => t in e ? Vo(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a, xo = (e, t) => {
  for (var a in t || (t = {}))
    El.call(t, a) && ka(e, a, t[a]);
  if (Ct)
    for (var a of Ct(t))
      Ll.call(t, a) && ka(e, a, t[a]);
  return e;
}, Po = (e, t) => Ao(e, Oo(t)), Io = (e, t) => {
  var a = {};
  for (var l in e)
    El.call(e, l) && t.indexOf(l) < 0 && (a[l] = e[l]);
  if (e != null && Ct)
    for (var l of Ct(e))
      t.indexOf(l) < 0 && Ll.call(e, l) && (a[l] = e[l]);
  return a;
};
function Fo(e, t, a = {}) {
  const l = a, {
    eventFilter: n
  } = l, r = Io(l, [
    "eventFilter"
  ]), { eventFilter: d, pause: c, resume: v, isActive: m } = $o(n);
  return { stop: To(e, t, Po(xo({}, r), {
    eventFilter: d
  })), pause: c, resume: v, isActive: m };
}
function Eo(e) {
  var t;
  const a = We(e);
  return (t = a == null ? void 0 : a.$el) != null ? t : a;
}
const ut = kt ? window : void 0;
function Lo(...e) {
  let t, a, l, n;
  if (ho(e[0]) || Array.isArray(e[0]) ? ([a, l, n] = e, t = ut) : [t, a, l, n] = e, !t)
    return yo;
  Array.isArray(a) || (a = [a]), Array.isArray(l) || (l = [l]);
  const r = [], d = () => {
    r.forEach((S) => S()), r.length = 0;
  }, c = (S, p, b) => (S.addEventListener(p, b, n), () => S.removeEventListener(p, b, n)), v = ce(() => Eo(t), (S) => {
    d(), S && r.push(...a.flatMap((p) => l.map((b) => c(S, p, b))));
  }, { immediate: !0, flush: "post" }), m = () => {
    v(), d();
  };
  return St(m), m;
}
function zo(e, t = !1) {
  const a = K(), l = () => a.value = Boolean(e());
  return l(), Il(l, t), a;
}
function No(e, t = {}) {
  const { window: a = ut } = t, l = zo(() => a && "matchMedia" in a && typeof a.matchMedia == "function");
  let n;
  const r = K(!1), d = () => {
    !n || ("removeEventListener" in n ? n.removeEventListener("change", c) : n.removeListener(c));
  }, c = () => {
    !l.value || (d(), n = a.matchMedia(So(e).value), r.value = n.matches, "addEventListener" in n ? n.addEventListener("change", c) : n.addListener(c));
  };
  return Ze(c), St(() => d()), r;
}
const Gt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Ut = "__vueuse_ssr_handlers__";
Gt[Ut] = Gt[Ut] || {};
const Do = Gt[Ut];
function zl(e, t) {
  return Do[e] || t;
}
function Ho(e) {
  return e == null ? "any" : e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof Date ? "date" : typeof e == "boolean" ? "boolean" : typeof e == "string" ? "string" : typeof e == "object" ? "object" : Number.isNaN(e) ? "any" : "number";
}
var Mo = Object.defineProperty, Sa = Object.getOwnPropertySymbols, Ro = Object.prototype.hasOwnProperty, jo = Object.prototype.propertyIsEnumerable, Ca = (e, t, a) => t in e ? Mo(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a, wa = (e, t) => {
  for (var a in t || (t = {}))
    Ro.call(t, a) && Ca(e, a, t[a]);
  if (Sa)
    for (var a of Sa(t))
      jo.call(t, a) && Ca(e, a, t[a]);
  return e;
};
const qo = {
  boolean: {
    read: (e) => e === "true",
    write: (e) => String(e)
  },
  object: {
    read: (e) => JSON.parse(e),
    write: (e) => JSON.stringify(e)
  },
  number: {
    read: (e) => Number.parseFloat(e),
    write: (e) => String(e)
  },
  any: {
    read: (e) => e,
    write: (e) => String(e)
  },
  string: {
    read: (e) => e,
    write: (e) => String(e)
  },
  map: {
    read: (e) => new Map(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e.entries()))
  },
  set: {
    read: (e) => new Set(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e))
  },
  date: {
    read: (e) => new Date(e),
    write: (e) => e.toISOString()
  }
};
function Go(e, t, a, l = {}) {
  var n;
  const {
    flush: r = "pre",
    deep: d = !0,
    listenToStorageChanges: c = !0,
    writeDefaults: v = !0,
    mergeDefaults: m = !1,
    shallow: S,
    window: p = ut,
    eventFilter: b,
    onError: A = (x) => {
      console.error(x);
    }
  } = l, w = (S ? al : K)(t);
  if (!a)
    try {
      a = zl("getDefaultStorage", () => {
        var x;
        return (x = ut) == null ? void 0 : x.localStorage;
      })();
    } catch (x) {
      A(x);
    }
  if (!a)
    return w;
  const y = We(t), k = Ho(y), g = (n = l.serializer) != null ? n : qo[k], { pause: $, resume: F } = Fo(w, () => P(w.value), { flush: r, deep: d, eventFilter: b });
  return p && c && Lo(p, "storage", _), _(), w;
  function P(x) {
    try {
      if (x == null)
        a.removeItem(e);
      else {
        const V = g.write(x), C = a.getItem(e);
        C !== V && (a.setItem(e, V), p && (p == null || p.dispatchEvent(new StorageEvent("storage", {
          key: e,
          oldValue: C,
          newValue: V,
          storageArea: a
        }))));
      }
    } catch (V) {
      A(V);
    }
  }
  function O(x) {
    const V = x ? x.newValue : a.getItem(e);
    if (V == null)
      return v && y !== null && a.setItem(e, g.write(y)), y;
    if (!x && m) {
      const C = g.read(V);
      return xl(m) ? m(C, y) : k === "object" && !Array.isArray(C) ? wa(wa({}, y), C) : C;
    } else
      return typeof V != "string" ? V : g.read(V);
  }
  function _(x) {
    if (!(x && x.storageArea !== a)) {
      if (x && x.key == null) {
        w.value = y;
        return;
      }
      if (!(x && x.key !== e)) {
        $();
        try {
          w.value = O(x);
        } catch (V) {
          A(V);
        } finally {
          x ? Ie(F) : F();
        }
      }
    }
  }
}
function Uo(e) {
  return No("(prefers-color-scheme: dark)", e);
}
var Wo = Object.defineProperty, _a = Object.getOwnPropertySymbols, Ko = Object.prototype.hasOwnProperty, Xo = Object.prototype.propertyIsEnumerable, Ta = (e, t, a) => t in e ? Wo(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a, Jo = (e, t) => {
  for (var a in t || (t = {}))
    Ko.call(t, a) && Ta(e, a, t[a]);
  if (_a)
    for (var a of _a(t))
      Xo.call(t, a) && Ta(e, a, t[a]);
  return e;
};
function Qo(e = {}) {
  const {
    selector: t = "html",
    attribute: a = "class",
    initialValue: l = "auto",
    window: n = ut,
    storage: r,
    storageKey: d = "vueuse-color-scheme",
    listenToStorageChanges: c = !0,
    storageRef: v,
    emitAuto: m
  } = e, S = Jo({
    auto: "",
    light: "light",
    dark: "dark"
  }, e.modes || {}), p = Uo({ window: n }), b = i(() => p.value ? "dark" : "light"), A = v || (d == null ? K(l) : Go(d, l, r, { window: n, listenToStorageChanges: c })), w = i({
    get() {
      return A.value === "auto" && !m ? b.value : A.value;
    },
    set($) {
      A.value = $;
    }
  }), y = zl("updateHTMLAttrs", ($, F, P) => {
    const O = n == null ? void 0 : n.document.querySelector($);
    if (!!O)
      if (F === "class") {
        const _ = P.split(/\s/g);
        Object.values(S).flatMap((x) => (x || "").split(/\s/g)).filter(Boolean).forEach((x) => {
          _.includes(x) ? O.classList.add(x) : O.classList.remove(x);
        });
      } else
        O.setAttribute(F, P);
  });
  function k($) {
    var F;
    const P = $ === "auto" ? b.value : $;
    y(t, a, (F = S[P]) != null ? F : P);
  }
  function g($) {
    e.onChanged ? e.onChanged($, k) : k($);
  }
  return ce(w, g, { flush: "post", immediate: !0 }), m && ce(b, () => g(w.value), { flush: "post" }), Il(() => g(w.value)), w;
}
var Va;
(function(e) {
  e.UP = "UP", e.RIGHT = "RIGHT", e.DOWN = "DOWN", e.LEFT = "LEFT", e.NONE = "NONE";
})(Va || (Va = {}));
var Yo = Object.defineProperty, Aa = Object.getOwnPropertySymbols, Zo = Object.prototype.hasOwnProperty, es = Object.prototype.propertyIsEnumerable, Oa = (e, t, a) => t in e ? Yo(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a, ts = (e, t) => {
  for (var a in t || (t = {}))
    Zo.call(t, a) && Oa(e, a, t[a]);
  if (Aa)
    for (var a of Aa(t))
      es.call(t, a) && Oa(e, a, t[a]);
  return e;
};
const as = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
ts({
  linear: ko
}, as);
const dt = (e) => Ol(() => e.value ? `justify-content-${e.value}` : "");
function u(e) {
  return Ol(
    () => e.value === void 0 || e.value === null ? e.value : ul(e.value)
  );
}
const Nl = {
  items: Ne([]),
  reset() {
    this.items = Ne([]);
  }
}, ls = (e) => {
  e.provide(wl, Nl);
}, Dl = () => {
  var e;
  return (e = He(wl)) != null ? e : Nl;
}, qe = (e, t, a) => {
  ke(() => {
    var l;
    (l = e == null ? void 0 : e.value) == null || l.addEventListener(t, a);
  }), ta(() => {
    var l;
    (l = e == null ? void 0 : e.value) == null || l.removeEventListener(t, a);
  });
}, Hl = (e) => i(() => ({
  "form-check": e.plain === !1 && e.button === !1,
  "form-check-inline": e.inline === !0,
  "form-switch": e.switch === !0,
  [`form-control-${e.size}`]: e.size !== void 0 && e.size !== "md"
})), Ml = (e) => i(() => ({
  "form-check-input": e.plain === !1 && e.button === !1,
  "is-valid": e.state === !0,
  "is-invalid": e.state === !1,
  "btn-check": e.button === !0
})), Rl = (e) => i(() => ({
  "form-check-label": e.plain === !1 && e.button === !1,
  btn: e.button === !0,
  [`btn-${e.buttonVariant}`]: e.button === !0 && e.buttonVariant !== void 0,
  [`btn-${e.size}`]: e.button && e.size && e.size !== "md"
})), jl = (e) => i(() => ({
  "aria-invalid": xt(e.ariaInvalid, e.state),
  "aria-required": e.required === !0 ? !0 : void 0
})), ql = (e) => i(() => ({
  "was-validated": e.validated === !0,
  "btn-group": e.buttons === !0 && e.stacked === !1,
  "btn-group-vertical": e.stacked === !0,
  [`btn-group-${e.size}`]: e.size !== void 0
})), wt = (e, t, a) => e.reduce(
  (l, n) => n.type.toString() === "Symbol(Fragment)" ? l.concat(n.children) : l.concat([n]),
  []
).filter((l) => l.type.__name === t || l.type.name === t).map((l) => {
  const n = (l.children.default ? l.children.default() : []).find(
    (r) => r.type.toString() === "Symbol(Text)"
  );
  return {
    props: {
      disabled: a,
      ...l.props
    },
    text: n ? n.children : ""
  };
}), Gl = (e, t) => typeof e == "string" ? {
  props: {
    value: e,
    disabled: t.disabled
  },
  text: e
} : {
  props: {
    value: e[t.valueField],
    disabled: t.disabled || e[t.disabledField],
    ...e.props
  },
  text: e[t.textField],
  html: e[t.htmlField]
}, Ul = (e, t, a, l, n) => ({
  ...e,
  props: {
    "button-variant": a.buttonVariant,
    form: a.form,
    name: l.value,
    id: `${n.value}_option_${t}`,
    button: a.buttons,
    state: a.state,
    plain: a.plain,
    size: a.size,
    inline: !a.stacked,
    required: a.required,
    ...e.props
  }
}), $e = (e, t) => i(() => (e == null ? void 0 : e.value) || Re(t)), Wl = {
  ariaInvalid: {
    type: [Boolean, String],
    default: void 0
  },
  autocomplete: { type: String, required: !1 },
  autofocus: { type: Boolean, default: !1 },
  disabled: { type: Boolean, default: !1 },
  form: { type: String, required: !1 },
  formatter: { type: Function, required: !1 },
  id: { type: String, required: !1 },
  lazy: { type: Boolean, default: !1 },
  lazyFormatter: { type: Boolean, default: !1 },
  list: { type: String, required: !1 },
  modelValue: { type: [String, Number], default: "" },
  name: { type: String, required: !1 },
  number: { type: Boolean, default: !1 },
  placeholder: { type: String, required: !1 },
  plaintext: { type: Boolean, default: !1 },
  readonly: { type: Boolean, default: !1 },
  required: { type: Boolean, default: !1 },
  size: { type: String, required: !1 },
  state: { type: Boolean, default: null },
  trim: { type: Boolean, default: !1 }
}, Kl = (e, t) => {
  const a = K();
  let l = null, n = !0;
  const r = $e(o(e, "id"), "input"), d = (y, k, g = !1) => (y = String(y), typeof e.formatter == "function" && (!e.lazyFormatter || g) ? (n = !1, e.formatter(y, k)) : y), c = (y) => e.trim ? y.trim() : e.number ? Number.parseFloat(y) : y, v = () => {
    var y;
    e.autofocus && ((y = a.value) == null || y.focus());
  };
  ke(() => {
    a.value && (a.value.value = e.modelValue), Ie(() => {
      v();
    });
  }), aa(() => {
    Ie(() => {
    });
  });
  const m = i(
    () => {
      var y;
      return xt(e.ariaInvalid, (y = e.state) != null ? y : void 0);
    }
  ), S = (y) => {
    const { value: k } = y.target, g = d(k, y);
    if (g === !1 || y.defaultPrevented) {
      y.preventDefault();
      return;
    }
    if (e.lazy)
      return;
    const $ = c(g);
    e.modelValue !== $ && (l = k, t("update:modelValue", $)), t("input", g);
  }, p = (y) => {
    const { value: k } = y.target, g = d(k, y);
    if (g === !1 || y.defaultPrevented) {
      y.preventDefault();
      return;
    }
    if (!e.lazy)
      return;
    l = k, t("update:modelValue", g);
    const $ = c(g);
    e.modelValue !== $ && t("change", g);
  }, b = (y) => {
    if (t("blur", y), !e.lazy && !e.lazyFormatter)
      return;
    const { value: k } = y.target, g = d(k, y, !0);
    l = k, t("update:modelValue", g);
  }, A = () => {
    var y;
    e.disabled || (y = a.value) == null || y.focus();
  }, w = () => {
    var y;
    e.disabled || (y = a.value) == null || y.blur();
  };
  return ce(
    () => e.modelValue,
    (y) => {
      !a.value || (a.value.value = l && n ? l : y, l = null, n = !0);
    }
  ), {
    input: a,
    computedId: r,
    computedAriaInvalid: m,
    onInput: S,
    onChange: p,
    onBlur: b,
    focus: A,
    blur: w
  };
}, Ye = (e, t) => {
  if (!e)
    return e;
  if (t in e)
    return e[t];
  const a = t.split(".");
  return Ye(e[a[0]], a.splice(1).join("."));
}, Dt = (e, t = null, a, l) => {
  if (Object.prototype.toString.call(e) === "[object Object]") {
    const n = Ye(e, l.valueField), r = Ye(e, l.textField), d = Ye(e, l.htmlField), c = Ye(e, l.disabledField), v = e[l.optionsField] || null;
    return v !== null ? {
      label: String(Ye(e, l.labelField) || r),
      options: ia(v, a, l)
    } : {
      value: typeof n > "u" ? t || r : n,
      text: String(typeof r > "u" ? t : r),
      html: d,
      disabled: Boolean(c)
    };
  }
  return {
    value: t || e,
    text: String(e),
    disabled: !1
  };
}, ia = (e, t, a) => Array.isArray(e) ? e.map((l) => Dt(l, null, t, a)) : Object.prototype.toString.call(e) === "[object Object]" ? (console.warn(
  `[BootstrapVue warn]: ${t} - Setting prop "options" to an object is deprecated. Use the array format instead.`
), Object.keys(e).map((l) => {
  const n = e[l];
  switch (typeof n) {
    case "object":
      return Dt(n.text, String(n.value), t, a);
    default:
      return Dt(n, String(l), t, a);
  }
})) : [], ns = (e = !1, t = {}) => {
  var n, r;
  const a = "data-bs-theme", l = "body";
  return Qo({
    attribute: a,
    selector: l,
    storageKey: e ? `${(n = t.attribute) != null ? n : a}-${(r = t.selector) != null ? r : l}` : null,
    ...t
  });
}, os = ["id"], ss = /* @__PURE__ */ I({
  __name: "BAccordion",
  props: {
    flush: { default: !1 },
    free: { default: !1 },
    id: null
  },
  setup(e) {
    const t = e, a = $e(o(t, "id"), "accordion"), l = u(o(t, "flush")), n = u(o(t, "free")), r = i(() => ({
      "accordion-flush": l.value
    }));
    return n.value || at(Al, a.value), (d, c) => (f(), h("div", {
      id: s(a),
      class: L(["accordion", s(r)])
    }, [
      B(d.$slots, "default")
    ], 10, os));
  }
}), Xl = /* @__PURE__ */ I({
  __name: "BCollapse",
  props: {
    accordion: null,
    id: null,
    modelValue: { default: !1 },
    tag: { default: "div" },
    toggle: { default: !1 },
    visible: { default: !1 },
    isNav: { default: !1 }
  },
  emits: ["update:modelValue", "show", "shown", "hide", "hidden"],
  setup(e, { emit: t }) {
    const a = e, l = u(o(a, "modelValue")), n = u(o(a, "toggle")), r = u(o(a, "visible")), d = u(o(a, "isNav")), c = $e(o(a, "id"), "collapse"), v = K(), m = K(), S = i(() => ({
      show: l.value,
      "navbar-collapse": d.value
    })), p = () => t("update:modelValue", !1);
    return ce(l, (b) => {
      var A, w;
      b ? (A = m.value) == null || A.show() : (w = m.value) == null || w.hide();
    }), ce(r, (b) => {
      var A, w;
      b ? (t("update:modelValue", !!b), (A = m.value) == null || A.show()) : (t("update:modelValue", !!b), (w = m.value) == null || w.hide());
    }), qe(v, "show.bs.collapse", () => {
      t("show"), t("update:modelValue", !0);
    }), qe(v, "hide.bs.collapse", () => {
      t("hide"), t("update:modelValue", !1);
    }), qe(v, "shown.bs.collapse", () => t("shown")), qe(v, "hidden.bs.collapse", () => t("hidden")), ke(() => {
      var b;
      m.value = new Ln(v.value, {
        parent: a.accordion ? `#${a.accordion}` : void 0,
        toggle: n.value
      }), (r.value || l.value) && (t("update:modelValue", !0), (b = m.value) == null || b.show());
    }), (b, A) => (f(), N(Z(e.tag), {
      id: s(c),
      ref_key: "element",
      ref: v,
      class: L(["collapse", s(S)]),
      "data-bs-parent": e.accordion || null,
      "is-nav": s(d)
    }, {
      default: M(() => [
        B(b.$slots, "default", {
          visible: s(l),
          close: p
        })
      ]),
      _: 3
    }, 8, ["id", "class", "data-bs-parent", "is-nav"]));
  }
}), xa = (e, t) => e.setAttribute("data-bs-theme", t), rs = {
  mounted(e, t) {
    xa(e, t.value);
  },
  updated(e, t) {
    xa(e, t.value);
  }
}, is = {
  mounted(e, t) {
    const a = t.modifiers.left ? "left" : t.modifiers.right ? "right" : t.modifiers.bottom ? "bottom" : t.modifiers.top ? "top" : "right", l = [];
    t.modifiers.manual ? l.push("manual") : (t.modifiers.click && l.push("click"), t.modifiers.hover && l.push("hover"), t.modifiers.focus && l.push("focus")), e.setAttribute("data-bs-toggle", "popover"), new Mt(e, {
      trigger: l.length === 0 ? "click" : l.join(" "),
      placement: a,
      content: t.value,
      html: t.modifiers.html
    });
  },
  unmounted(e) {
    const t = Mt.getInstance(e);
    t !== null && t.dispose();
  }
}, us = (e) => {
  if (e.classList.contains("offcanvas"))
    return "offcanvas";
  if (e.classList.contains("collapse"))
    return "collapse";
  throw Error("Couldn't resolve toggle type");
}, ds = (e, t) => {
  const { modifiers: a, arg: l, value: n } = e, r = Object.keys(a || {}), d = typeof n == "string" ? n.split(pt) : n;
  if (io(t.tagName, "a")) {
    const c = sa(t, "href") || "";
    jn.test(c) && r.push(c.replace(Rn, ""));
  }
  return Array.prototype.concat.apply([], [l, d]).forEach((c) => typeof c == "string" && r.push(c)), r.filter((c, v, m) => c && m.indexOf(c) === v);
}, ua = {
  mounted(e, t) {
    const a = ds(t, e), l = [], n = e.tagName === "a" ? "href" : "data-bs-target";
    a.forEach((r) => {
      const d = document.getElementById(r);
      d !== null && (e.setAttribute("data-bs-toggle", us(d)), l.push(`#${r}`));
    }), l.length > 0 && e.setAttribute(n, l.join(","));
  }
}, cs = (e, t) => {
  if (t != null && t.trigger)
    return t.trigger;
  if (e.manual)
    return "manual";
  const a = [];
  return e.click && a.push("click"), e.hover && a.push("hover"), e.focus && a.push("focus"), a.length > 0 ? a.join(" ") : "hover focus";
}, fs = (e, t) => t != null && t.placement ? t.placement : e.left ? "left" : e.right ? "right" : e.bottom ? "bottom" : "top", vs = (e) => e != null && e.delay ? e.delay : 0, Pa = (e) => typeof e > "u" ? (console.warn(
  "Review tooltip directive usage. Some uses are not defining a title in root component or a value like `v-b-tooltip='{title: \"my title\"}'` nor `v-b-tooltip=\"'my title'\"` to define a title"
), "") : typeof e == "object" ? e == null ? void 0 : e.title : e, ms = {
  beforeMount(e, t) {
    e.setAttribute("data-bs-toggle", "tooltip"), e.getAttribute("title") || e.setAttribute("title", Pa(t.value).toString());
    const a = /<("[^"]*"|'[^']*'|[^'">])*>/.test(e.title), l = cs(t.modifiers, t.value), n = fs(t.modifiers, t.value), r = vs(t.value), d = e.getAttribute("title");
    new Lt(e, {
      trigger: l,
      placement: n,
      delay: r,
      html: a
    }), d && e.setAttribute("data-bs-original-title", d);
  },
  updated(e, t) {
    e.getAttribute("title") || e.setAttribute("title", Pa(t.value).toString());
    const a = e.getAttribute("title"), l = e.getAttribute("data-bs-original-title"), n = Lt.getInstance(e);
    e.removeAttribute("title"), a && a !== l && (n == null || n.setContent({ ".tooltip-inner": a }), e.setAttribute("data-bs-original-title", a));
  },
  unmounted(e) {
    const t = Lt.getInstance(e);
    t !== null && t.dispose();
  }
}, bt = /* @__PURE__ */ new Map();
class ps {
  constructor(t, a, l, n, r) {
    be(this, "element");
    be(this, "margin");
    be(this, "once");
    be(this, "callback");
    be(this, "instance");
    be(this, "observer");
    be(this, "doneOnce");
    be(this, "visible");
    this.element = t, this.margin = a, this.once = l, this.callback = n, this.instance = r, this.createObserver();
  }
  createObserver() {
    if (this.observer && this.stop(), !(this.doneOnce || typeof this.callback != "function")) {
      try {
        this.observer = new IntersectionObserver(this.handler.bind(this), {
          root: null,
          rootMargin: this.margin,
          threshold: 0
        });
      } catch {
        console.error("Intersection Observer not supported"), this.doneOnce = !0, this.observer = void 0, this.callback(null);
        return;
      }
      this.instance.$nextTick(() => {
        this.observer && this.observer.observe(this.element);
      });
    }
  }
  handler(t) {
    const [a] = t, l = Boolean(a.isIntersecting || a.intersectionRatio > 0);
    l !== this.visible && (this.visible = l, this.callback(l), this.once && this.visible && (this.doneOnce = !0, this.stop()));
  }
  stop() {
    this.observer && this.observer.disconnect(), this.observer = null;
  }
}
const Jl = (e) => {
  if (bt.has(e)) {
    const t = bt.get(e);
    t && t.stop && t.stop(), bt.delete(e);
  }
}, Ia = (e, t) => {
  const a = {
    margin: "0px",
    once: !1,
    callback: t.value
  };
  Object.keys(t.modifiers).forEach((n) => {
    Number.isInteger(n) ? a.margin = `${n}px` : n.toLowerCase() === "once" && (a.once = !0);
  }), Jl(e);
  const l = new ps(
    e,
    a.margin,
    a.once,
    a.callback,
    t.instance
  );
  bt.set(e, l);
}, bs = {
  beforeMount(e, t) {
    Ia(e, t);
  },
  updated(e, t) {
    Ia(e, t);
  },
  unmounted(e) {
    Jl(e);
  }
}, gs = { class: "accordion-item" }, hs = ["id"], ys = ["aria-expanded", "aria-controls"], Bs = { class: "accordion-body" }, $s = /* @__PURE__ */ I({
  __name: "BAccordionItem",
  props: {
    id: null,
    title: null,
    visible: { default: !1 }
  },
  setup(e) {
    const t = e, a = He(Al), l = $e(o(t, "id"), "accordion_item"), n = u(o(t, "visible"));
    return (r, d) => (f(), h("div", gs, [
      j("h2", {
        id: `${s(l)}heading`,
        class: "accordion-header"
      }, [
        Ge((f(), h("button", {
          class: L(["accordion-button", { collapsed: !s(n) }]),
          type: "button",
          "aria-expanded": s(n) ? "true" : "false",
          "aria-controls": s(l)
        }, [
          B(r.$slots, "title", {}, () => [
            ee(W(e.title), 1)
          ])
        ], 10, ys)), [
          [s(ua), void 0, s(l)]
        ])
      ], 8, hs),
      ve(Xl, {
        id: s(l),
        class: "accordion-collapse",
        visible: e.visible,
        accordion: s(a),
        "aria-labelledby": `heading${s(l)}`
      }, {
        default: M(() => [
          j("div", Bs, [
            B(r.$slots, "default")
          ])
        ]),
        _: 3
      }, 8, ["id", "visible", "accordion", "aria-labelledby"])
    ]));
  }
}), lt = /* @__PURE__ */ I({
  __name: "BTransition",
  props: {
    appear: { default: !1 },
    mode: null,
    noFade: { default: !1 },
    transProps: null
  },
  setup(e) {
    const t = e, a = u(o(t, "appear")), l = u(o(t, "noFade")), n = i(() => {
      const c = {
        name: "",
        enterActiveClass: "",
        enterToClass: "",
        leaveActiveClass: "",
        leaveToClass: "showing",
        enterFromClass: "showing",
        leaveFromClass: ""
      }, v = {
        ...c,
        enterActiveClass: "fade showing",
        leaveActiveClass: "fade showing"
      };
      return l.value ? c : v;
    }), r = i(() => ({ mode: t.mode, css: !0, ...n.value })), d = i(
      () => t.transProps !== void 0 ? {
        ...r.value,
        ...t.transProps
      } : a.value ? {
        ...r.value,
        appear: !0,
        appearActiveClass: n.value.enterActiveClass,
        appearToClass: n.value.enterToClass
      } : r.value
    );
    return (c, v) => (f(), N(nl, Be(_e(s(d))), {
      default: M(() => [
        B(c.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ks = ["type", "disabled", "aria-label"], nt = /* @__PURE__ */ I({
  __name: "BCloseButton",
  props: {
    ariaLabel: { default: "Close" },
    disabled: { default: !1 },
    white: { default: !1 },
    type: { default: "button" }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = u(o(a, "disabled")), n = u(o(a, "white")), r = i(() => ({
      "btn-close-white": n.value
    }));
    return (d, c) => (f(), h("button", {
      type: e.type,
      class: L(["btn-close", s(r)]),
      disabled: s(l),
      "aria-label": e.ariaLabel,
      onClick: c[0] || (c[0] = (v) => t("click", v))
    }, null, 10, ks));
  }
}), Ss = {
  key: 0,
  class: "visually-hidden"
}, Pt = /* @__PURE__ */ I({
  __name: "BSpinner",
  props: {
    label: null,
    role: { default: "status" },
    small: { default: !1 },
    tag: { default: "span" },
    type: { default: "border" },
    variant: null
  },
  setup(e) {
    const t = e, a = Se(), l = u(o(t, "small")), n = i(() => ({
      "spinner-border": t.type === "border",
      "spinner-border-sm": t.type === "border" && l.value,
      "spinner-grow": t.type === "grow",
      "spinner-grow-sm": t.type === "grow" && l.value,
      [`text-${t.variant}`]: t.variant !== void 0
    })), r = i(() => !we(a.label));
    return (d, c) => (f(), N(Z(e.tag), {
      class: L(s(n)),
      role: e.label || s(r) ? e.role : null,
      "aria-hidden": e.label || s(r) ? null : !0
    }, {
      default: M(() => [
        e.label || s(r) ? (f(), h("span", Ss, [
          B(d.$slots, "label", {}, () => [
            ee(W(e.label), 1)
          ])
        ])) : X("", !0)
      ]),
      _: 3
    }, 8, ["class", "role", "aria-hidden"]));
  }
}), Je = {
  active: { type: [Boolean, String], default: !1 },
  activeClass: { type: String, default: "router-link-active" },
  append: { type: [Boolean, String], default: !1 },
  disabled: { type: [Boolean, String], default: !1 },
  event: { type: [String, Array], default: "click" },
  exact: { type: [Boolean, String], default: !1 },
  exactActiveClass: { type: String, default: "router-link-exact-active" },
  href: { type: String },
  rel: { type: String, default: null },
  replace: { type: [Boolean, String], default: !1 },
  routerComponentName: { type: String, default: "router-link" },
  routerTag: { type: String, default: "a" },
  target: { type: String, default: "_self" },
  to: { type: [String, Object], default: null }
}, Cs = I({
  props: Je,
  emits: ["click"],
  setup(e, { emit: t, attrs: a }) {
    const l = u(o(e, "active")), n = u(o(e, "append")), r = u(o(e, "disabled")), d = u(o(e, "exact")), c = u(o(e, "replace")), v = ll(), m = K(null), S = i(() => {
      const y = e.routerComponentName.split("-").map((g) => g.charAt(0).toUpperCase() + g.slice(1)).join("");
      return !((v == null ? void 0 : v.appContext.app.component(y)) !== void 0) || r.value || !e.to ? "a" : e.routerComponentName;
    }), p = i(() => {
      const y = "#";
      if (e.href)
        return e.href;
      if (typeof e.to == "string")
        return e.to || y;
      const k = e.to;
      if (Object.prototype.toString.call(k) === "[object Object]" && (k.path || k.query || k.hash)) {
        const g = k.path || "", $ = k.query ? `?${Object.keys(k.query).map((P) => `${P}=${k.query[P]}`).join("=")}` : "", F = !k.hash || k.hash.charAt(0) === "#" ? k.hash || "" : `#${k.hash}`;
        return `${g}${$}${F}` || y;
      }
      return y;
    }), b = i(() => ({
      to: e.to,
      href: p.value,
      target: e.target,
      rel: e.target === "_blank" && e.rel === null ? "noopener" : e.rel || null,
      tabindex: r.value ? "-1" : typeof a.tabindex > "u" ? null : a.tabindex,
      "aria-disabled": r.value ? "true" : null
    }));
    return {
      computedLinkClasses: i(() => ({
        active: l.value,
        disabled: r.value
      })),
      tag: S,
      routerAttr: b,
      link: m,
      clicked: (y) => {
        if (r.value) {
          y.preventDefault(), y.stopImmediatePropagation();
          return;
        }
        t("click", y);
      },
      activeBoolean: l,
      appendBoolean: n,
      disabledBoolean: r,
      replaceBoolean: c,
      exactBoolean: d
    };
  }
}), Te = (e, t) => {
  const a = e.__vccOpts || e;
  for (const [l, n] of t)
    a[l] = n;
  return a;
};
function ws(e, t, a, l, n, r) {
  return e.tag === "router-link" ? (f(), N(Z(e.tag), Q({ key: 0 }, e.routerAttr, { custom: "" }), {
    default: M(({ href: d, navigate: c, isActive: v, isExactActive: m }) => [
      (f(), N(Z(e.routerTag), Q({
        ref: "link",
        href: d,
        class: [
          (v || e.activeBoolean) && e.activeClass,
          (m || e.exactBoolean) && e.exactActiveClass
        ]
      }, e.$attrs, { onClick: c }), {
        default: M(() => [
          B(e.$slots, "default")
        ]),
        _: 2
      }, 1040, ["href", "class", "onClick"]))
    ]),
    _: 3
  }, 16)) : (f(), N(Z(e.tag), Q({
    key: 1,
    ref: "link",
    class: e.computedLinkClasses
  }, e.routerAttr, { onClick: e.clicked }), {
    default: M(() => [
      B(e.$slots, "default")
    ]),
    _: 3
  }, 16, ["class", "onClick"]));
}
const Ve = /* @__PURE__ */ Te(Cs, [["render", ws]]), _s = I({
  components: { BLink: Ve, BSpinner: Pt },
  props: {
    ...Je,
    active: { type: [Boolean, String], default: !1 },
    disabled: { type: [Boolean, String], default: !1 },
    href: { type: String, required: !1 },
    pill: { type: [Boolean, String], default: !1 },
    pressed: { type: [Boolean, String], default: !1 },
    rel: { type: String, default: void 0 },
    size: { type: String, default: "md" },
    squared: { type: [Boolean, String], default: !1 },
    tag: { type: String, default: "button" },
    target: { type: String, default: "_self" },
    type: { type: String, default: "button" },
    variant: { type: String, default: "secondary" },
    loading: { type: [Boolean, String], default: !1 },
    loadingMode: { type: String, default: "inline" }
  },
  emits: ["click", "update:pressed"],
  setup(e, { emit: t }) {
    const a = u(o(e, "active")), l = u(o(e, "disabled")), n = u(o(e, "pill")), r = u(o(e, "pressed")), d = u(o(e, "squared")), c = u(o(e, "loading")), v = i(() => r.value === !0), m = i(
      () => e.tag === "button" && e.href === void 0 && e.to === null
    ), S = i(() => it(e)), p = i(() => e.to !== null), b = i(
      () => e.href !== void 0 ? !1 : !m.value
    ), A = i(() => [
      [`btn-${e.variant}`],
      [`btn-${e.size}`],
      {
        active: a.value || r.value,
        "rounded-pill": n.value,
        "rounded-0": d.value,
        disabled: l.value
      }
    ]), w = i(() => ({
      "aria-disabled": b.value ? l.value : null,
      "aria-pressed": v.value ? r.value : null,
      autocomplete: v.value ? "off" : null,
      disabled: m.value ? l.value : null,
      href: e.href,
      rel: S.value ? e.rel : null,
      role: b.value || S.value ? "button" : null,
      target: S.value ? e.target : null,
      type: m.value ? e.type : null,
      to: m.value ? null : e.to,
      append: S.value ? e.append : null,
      activeClass: p.value ? e.activeClass : null,
      event: p.value ? e.event : null,
      exact: p.value ? e.exact : null,
      exactActiveClass: p.value ? e.exactActiveClass : null,
      replace: p.value ? e.replace : null,
      routerComponentName: p.value ? e.routerComponentName : null,
      routerTag: p.value ? e.routerTag : null
    })), y = i(
      () => p.value ? Ve : e.href ? "a" : e.tag
    );
    return {
      computedClasses: A,
      computedAttrs: w,
      computedTag: y,
      clicked: (g) => {
        if (l.value) {
          g.preventDefault(), g.stopPropagation();
          return;
        }
        t("click", g), v.value && t("update:pressed", !r.value);
      },
      loadingBoolean: c
    };
  }
});
function Ts(e, t, a, l, n, r) {
  const d = ol("b-spinner");
  return f(), N(Z(e.computedTag), Q({
    class: ["btn", e.computedClasses]
  }, e.computedAttrs, { onClick: e.clicked }), {
    default: M(() => [
      e.loadingBoolean ? (f(), h("div", {
        key: 0,
        class: L(["btn-loading", { "mode-fill": e.loadingMode === "fill", "mode-inline": e.loadingMode === "inline" }])
      }, [
        B(e.$slots, "loading", {}, () => [
          ve(d, {
            class: "btn-spinner",
            small: e.size !== "lg"
          }, null, 8, ["small"])
        ])
      ], 2)) : X("", !0),
      j("div", {
        class: L(["btn-content", { "btn-loading-fill": e.loadingBoolean && e.loadingMode === "fill" }])
      }, [
        B(e.$slots, "default")
      ], 2)
    ]),
    _: 3
  }, 16, ["class", "onClick"]);
}
const et = /* @__PURE__ */ Te(_s, [["render", Ts]]), Vs = (e, t = K(1e3), a = {}) => {
  const l = K(!1), n = K(0), r = K(We(e)), d = K(We(t)), c = i(() => Math.ceil(r.value / d.value)), v = i(
    () => p.value || l.value ? Math.round(r.value - n.value * d.value) : 0
  ), { pause: m, resume: S, isActive: p } = Fl(
    () => n.value = n.value + 1,
    t,
    a
  ), b = () => {
    l.value = !1, n.value = 0, S();
  }, A = () => {
    l.value = !1, n.value = c.value;
  };
  Ze(() => {
    const k = We(e), g = r.value;
    k !== g && (r.value = k, A(), b());
  }), Ze(() => {
    const k = We(t), g = d.value;
    k !== g && (d.value = k, A(), b());
  }), Ze(() => {
    n.value > c.value && (n.value = c.value), n.value === c.value && m();
  });
  const w = () => {
    p.value !== !1 && (l.value = !0, m());
  }, y = () => {
    n.value !== c.value && (l.value = !1, S());
  };
  return {
    isActive: Ht(p),
    isPaused: Ht(l),
    restart: b,
    stop: A,
    pause: w,
    resume: y,
    value: v
  };
}, As = ["onMouseenter"], Os = /* @__PURE__ */ I({
  __name: "BAlert",
  props: {
    noHoverPause: { default: !1 },
    dismissLabel: { default: "Close" },
    dismissible: { default: !1 },
    fade: { default: !1 },
    modelValue: { type: [Boolean, Number], default: !1 },
    variant: { default: "info" },
    closeContent: null,
    immediate: { default: !0 },
    interval: { default: 1e3 },
    showOnPause: { default: !0 }
  },
  emits: ["closed", "close-countdown", "update:modelValue"],
  setup(e, { expose: t, emit: a }) {
    const l = e, n = u(o(l, "dismissible")), r = u(o(l, "fade")), d = u(o(l, "immediate")), c = u(o(l, "showOnPause")), v = u(o(l, "noHoverPause")), m = Se(), S = i(() => !we(m.close)), p = i(() => [
      [`alert-${l.variant}`],
      {
        "alert-dismissible": n.value
      }
    ]), {
      isActive: b,
      pause: A,
      restart: w,
      resume: y,
      stop: k,
      isPaused: g,
      value: $
    } = Vs(
      typeof l.modelValue == "boolean" ? 0 : o(l, "modelValue"),
      o(l, "interval"),
      {
        immediate: typeof l.modelValue == "number" && d.value
      }
    ), F = i(
      () => typeof l.modelValue == "boolean" ? l.modelValue : b.value || c.value && g.value
    );
    Ze(() => a("close-countdown", $.value));
    const P = () => {
      typeof l.modelValue == "boolean" ? a("update:modelValue", !1) : (a("update:modelValue", 0), k()), a("closed");
    }, O = () => {
      v.value || A();
    };
    return ta(k), t({ pause: A, resume: y, restart: w, stop: k }), (_, x) => (f(), N(lt, {
      "no-fade": !s(r),
      "trans-props": { enterToClass: "show" }
    }, {
      default: M(() => [
        s(F) ? (f(), h("div", {
          key: 0,
          class: L(["alert", s(p)]),
          role: "alert",
          "aria-live": "polite",
          "aria-atomic": "true",
          onMouseenter: Xe(O, ["stop"]),
          onMouseleave: x[0] || (x[0] = Xe(
            (...V) => s(y) && s(y)(...V),
            ["stop"]
          ))
        }, [
          B(_.$slots, "default"),
          s(n) ? (f(), h(ie, { key: 0 }, [
            s(S) || e.closeContent ? (f(), N(et, {
              key: 0,
              type: "button",
              onClick: P
            }, {
              default: M(() => [
                B(_.$slots, "close", {}, () => [
                  ee(W(e.closeContent), 1)
                ])
              ]),
              _: 3
            })) : (f(), N(nt, {
              key: 1,
              "aria-label": e.dismissLabel,
              onClick: P
            }, null, 8, ["aria-label"]))
          ], 64)) : X("", !0)
        ], 42, As)) : X("", !0)
      ]),
      _: 3
    }, 8, ["no-fade"]));
  }
}), xs = {
  key: 0,
  class: "b-avatar-custom"
}, Ps = {
  key: 1,
  class: "b-avatar-img"
}, Is = ["src", "alt"], Wt = (e) => {
  const t = typeof e == "string" && cl(e) ? rt(e, 0) : e;
  return typeof t == "number" ? `${t}px` : t || null;
}, Fs = /* @__PURE__ */ I({
  __name: "BAvatar",
  props: {
    alt: { default: "avatar" },
    ariaLabel: null,
    badge: { type: [Boolean, String], default: !1 },
    badgeLeft: { default: !1 },
    badgeOffset: null,
    badgeTop: { default: !1 },
    badgeVariant: { default: "primary" },
    button: { default: !1 },
    buttonType: { default: "button" },
    disabled: { default: !1 },
    icon: null,
    rounded: { type: [Boolean, String], default: "circle" },
    size: null,
    square: { default: !1 },
    src: null,
    text: null,
    textVariant: null,
    variant: { default: "secondary" }
  },
  emits: ["click", "img-error"],
  setup(e, { emit: t }) {
    const a = e, l = Se(), n = He(Vl), r = ["sm", null, "lg"], d = 0.4, c = d * 0.7, v = u(o(a, "badgeLeft")), m = u(o(a, "badgeTop")), S = u(o(a, "button")), p = u(o(a, "disabled")), b = u(o(a, "square")), A = i(() => !we(l.default)), w = i(() => !we(l.badge)), y = i(() => !!a.badge || a.badge === "" || w.value), k = i(
      () => n != null && n.size ? n.size : Wt(a.size)
    ), g = i(
      () => n != null && n.variant ? n.variant : a.variant
    ), $ = i(
      () => n != null && n.rounded ? n.rounded : a.rounded
    ), F = i(() => ({
      type: S.value ? a.buttonType : void 0,
      "aria-label": a.ariaLabel || null,
      disabled: p.value || null
    })), P = i(() => [`bg-${a.badgeVariant}`]), O = i(() => a.badge === !0 ? "" : a.badge), _ = i(() => [[`text-${se(a.badgeVariant)}`]]), x = i(() => ({
      [`b-avatar-${a.size}`]: !!a.size && r.indexOf(Wt(a.size)) !== -1,
      [`bg-${g.value}`]: !!g.value,
      badge: !S.value && g.value && A.value,
      rounded: $.value === "" || $.value === !0,
      ["rounded-circle"]: !b.value && $.value === "circle",
      ["rounded-0"]: b.value || $.value === "0",
      ["rounded-1"]: !b.value && $.value === "sm",
      ["rounded-3"]: !b.value && $.value === "lg",
      ["rounded-top"]: !b.value && $.value === "top",
      ["rounded-bottom"]: !b.value && $.value === "bottom",
      ["rounded-start"]: !b.value && $.value === "left",
      ["rounded-end"]: !b.value && $.value === "right",
      btn: S.value,
      [`btn-${g.value}`]: S.value ? !!g.value : !1
    })), V = i(() => [
      [`text-${a.textVariant || se(g.value)}`]
    ]), C = i(() => {
      const ae = a.badgeOffset || "0px";
      return {
        fontSize: (r.indexOf(k.value || null) === -1 ? `calc(${k.value} * ${c})` : "") || "",
        top: m.value ? ae : "",
        bottom: m.value ? "" : ae,
        left: v.value ? ae : "",
        right: v.value ? "" : ae
      };
    }), E = i(() => {
      const ae = r.indexOf(k.value || null) === -1 ? `calc(${k.value} * ${d})` : null;
      return ae ? { fontSize: ae } : {};
    }), D = i(() => {
      var re;
      const ae = ((re = n == null ? void 0 : n.overlapScale) == null ? void 0 : re.value) || 0, he = k.value && ae ? `calc(${k.value} * -${ae})` : null;
      return he ? { marginLeft: he, marginRight: he } : {};
    }), q = i(() => S.value ? "button" : "span"), G = i(() => ({
      ...D.value,
      width: k.value,
      height: k.value
    })), se = (ae) => ae === "light" || ae === "warning" ? "dark" : "light", J = (ae) => {
      !p.value && S.value && t("click", ae);
    }, ge = (ae) => t("img-error", ae);
    return (ae, he) => (f(), N(Z(s(q)), Q({
      class: ["b-avatar", s(x)],
      style: s(G)
    }, s(F), { onClick: J }), {
      default: M(() => [
        s(A) ? (f(), h("span", xs, [
          B(ae.$slots, "default")
        ])) : e.src ? (f(), h("span", Ps, [
          j("img", {
            src: e.src,
            alt: e.alt,
            onError: ge
          }, null, 40, Is)
        ])) : e.text ? (f(), h("span", {
          key: 2,
          class: L(["b-avatar-text", s(V)]),
          style: Fe(s(E))
        }, W(e.text), 7)) : X("", !0),
        s(y) ? (f(), h("span", {
          key: 3,
          class: L(["b-avatar-badge", s(P)]),
          style: Fe(s(C))
        }, [
          s(w) ? B(ae.$slots, "badge", { key: 0 }) : (f(), h("span", {
            key: 1,
            class: L(s(_))
          }, W(s(O)), 3))
        ], 6)) : X("", !0)
      ]),
      _: 3
    }, 16, ["class", "style"]));
  }
}), Es = /* @__PURE__ */ I({
  __name: "BAvatarGroup",
  props: {
    overlap: { default: 0.3 },
    rounded: { type: [Boolean, String], default: !1 },
    size: null,
    square: { default: !1 },
    tag: { default: "div" },
    variant: null
  },
  setup(e) {
    const t = e, a = u(o(t, "square")), l = i(() => Wt(t.size)), n = i(
      () => Math.min(Math.max(d(t.overlap), 0), 1) / 2
    ), r = i(() => {
      const c = l.value ? `calc(${l.value} * ${n.value})` : null;
      return c ? { paddingLeft: c, paddingRight: c } : {};
    }), d = (c) => typeof c == "string" && cl(c) ? rt(c, 0) : c || 0;
    return at(Vl, {
      overlapScale: n,
      size: t.size,
      square: a.value,
      rounded: t.rounded,
      variant: t.variant
    }), (c, v) => (f(), N(Z(e.tag), {
      class: "b-avatar-group",
      role: "group"
    }, {
      default: M(() => [
        j("div", {
          class: "b-avatar-group-inner",
          style: Fe(s(r))
        }, [
          B(c.$slots, "default")
        ], 4)
      ]),
      _: 3
    }));
  }
}), Fa = Ot(Je, ["event", "routerTag"]), Ls = I({
  components: { BLink: Ve },
  props: {
    pill: { type: [Boolean, String], default: !1 },
    tag: { type: String, default: "span" },
    variant: { type: String, default: "secondary" },
    textIndicator: { type: [Boolean, String], default: !1 },
    dotIndicator: { type: [Boolean, String], default: !1 },
    ...Fa
  },
  setup(e) {
    const t = u(o(e, "pill")), a = u(o(e, "textIndicator")), l = u(o(e, "dotIndicator")), n = u(o(e, "active")), r = u(o(e, "disabled")), d = i(() => it(e)), c = i(
      () => d.value ? Ve : e.tag
    ), v = i(() => [
      [`bg-${e.variant}`],
      {
        active: n.value,
        disabled: r.value,
        "text-dark": ["warning", "info", "light"].includes(e.variant),
        "rounded-pill": t.value,
        "position-absolute top-0 start-100 translate-middle": a.value || l.value,
        "p-2 border border-light rounded-circle": l.value,
        "text-decoration-none": d.value
      }
    ]), m = i(
      () => d.value ? ra(e, Fa) : {}
    );
    return {
      computedClasses: v,
      computedLinkProps: m,
      computedTag: c
    };
  }
});
function zs(e, t, a, l, n, r) {
  return f(), N(Z(e.computedTag), Q({
    class: ["badge", e.computedClasses]
  }, e.computedLinkProps), {
    default: M(() => [
      B(e.$slots, "default")
    ]),
    _: 3
  }, 16, ["class"]);
}
const Ns = /* @__PURE__ */ Te(Ls, [["render", zs]]), Ea = Ot(Je, ["event", "routerTag"]), Ds = I({
  components: { BLink: Ve },
  props: {
    ...Ea,
    active: { type: [Boolean, String], default: !1 },
    ariaCurrent: { type: String, default: "location" },
    disabled: { type: [Boolean, String], default: !1 },
    text: { type: String, required: !1 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = u(o(e, "active")), l = u(o(e, "disabled")), n = i(() => ({
      active: a.value
    })), r = i(
      () => a.value ? "span" : Ve
    ), d = i(
      () => a.value ? e.ariaCurrent : void 0
    );
    return {
      computedLinkProps: i(
        () => r.value !== "span" ? ra(e, Ea) : {}
      ),
      computedClasses: n,
      computedTag: r,
      computedAriaCurrent: d,
      clicked: (m) => {
        if (l.value || a.value) {
          m.preventDefault(), m.stopImmediatePropagation();
          return;
        }
        l.value || t("click", m);
      }
    };
  }
});
function Hs(e, t, a, l, n, r) {
  return f(), h("li", {
    class: L(["breadcrumb-item", e.computedClasses])
  }, [
    (f(), N(Z(e.computedTag), Q({ "aria-current": e.computedAriaCurrent }, e.computedLinkProps, { onClick: e.clicked }), {
      default: M(() => [
        B(e.$slots, "default", {}, () => [
          ee(W(e.text), 1)
        ])
      ]),
      _: 3
    }, 16, ["aria-current", "onClick"]))
  ], 2);
}
const Ql = /* @__PURE__ */ Te(Ds, [["render", Hs]]), Ms = { "aria-label": "breadcrumb" }, Rs = { class: "breadcrumb" }, js = /* @__PURE__ */ I({
  __name: "BBreadcrumb",
  props: {
    items: null
  },
  setup(e) {
    const t = e, a = Dl(), l = i(() => {
      const n = t.items || (a == null ? void 0 : a.items) || [];
      let r = !1;
      return n.map((c, v) => (typeof c == "string" && (c = { text: c }, v < n.length - 1 && (c.href = "#")), c.active && (r = !0), !c.active && !r && (c.active = v + 1 === n.length), c));
    });
    return (n, r) => (f(), h("nav", Ms, [
      j("ol", Rs, [
        B(n.$slots, "prepend"),
        (f(!0), h(ie, null, me(s(l), (d, c) => (f(), N(Ql, Q({ key: c }, d), {
          default: M(() => [
            ee(W(d.text), 1)
          ]),
          _: 2
        }, 1040))), 128)),
        B(n.$slots, "default"),
        B(n.$slots, "append")
      ])
    ]));
  }
}), qs = /* @__PURE__ */ I({
  __name: "BButtonGroup",
  props: {
    ariaLabel: { default: "Group" },
    size: null,
    tag: { default: "div" },
    vertical: { default: !1 }
  },
  setup(e) {
    const t = e, a = u(o(t, "vertical")), l = i(() => ({
      "btn-group": !a.value,
      [`btn-group-${t.size}`]: t.size !== void 0,
      "btn-group-vertical": a.value
    }));
    return (n, r) => (f(), N(Z(e.tag), {
      class: L(s(l)),
      role: "group",
      "aria-label": e.ariaLabel
    }, {
      default: M(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "aria-label"]));
  }
}), Gs = ["role", "aria-label"], Us = /* @__PURE__ */ I({
  __name: "BButtonToolbar",
  props: {
    ariaLabel: { default: "Group" },
    justify: { default: !1 },
    role: { default: "toolbar" }
  },
  setup(e) {
    const a = u(o(e, "justify")), l = i(() => ({
      "justify-content-between": a.value
    }));
    return (n, r) => (f(), h("div", {
      class: L([s(l), "btn-toolbar"]),
      role: e.role,
      "aria-label": e.ariaLabel
    }, [
      B(n.$slots, "default")
    ], 10, Gs));
  }
}), da = /* @__PURE__ */ I({
  __name: "BImg",
  props: {
    alt: null,
    blank: { default: !1 },
    blankColor: { default: "transparent" },
    block: { default: !1 },
    center: { default: !1 },
    fluid: { default: !1 },
    lazy: { default: !1 },
    fluidGrow: { default: !1 },
    height: null,
    left: { default: !1 },
    start: { default: !1 },
    right: { default: !1 },
    end: { default: !1 },
    rounded: { type: [Boolean, String], default: !1 },
    sizes: null,
    src: null,
    srcset: null,
    thumbnail: { default: !1 },
    width: null
  },
  emits: ["load"],
  setup(e, { emit: t }) {
    const a = e, l = '<svg width="%{w}" height="%{h}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 %{w} %{h}" preserveAspectRatio="none"><rect width="100%" height="100%" style="fill:%{f};"></rect></svg>', n = u(o(a, "lazy")), r = u(o(a, "blank")), d = u(o(a, "block")), c = u(o(a, "center")), v = u(o(a, "fluid")), m = u(o(a, "fluidGrow")), S = u(o(a, "left")), p = u(o(a, "start")), b = u(o(a, "right")), A = u(o(a, "end")), w = u(o(a, "thumbnail")), y = i(
      () => typeof a.srcset == "string" ? a.srcset.split(",").filter((x) => x).join(",") : Array.isArray(a.srcset) ? a.srcset.filter((x) => x).join(",") : void 0
    ), k = i(
      () => typeof a.sizes == "string" ? a.sizes.split(",").filter((x) => x).join(",") : Array.isArray(a.sizes) ? a.sizes.filter((x) => x).join(",") : void 0
    ), g = i(() => {
      const x = (E) => E === void 0 ? void 0 : typeof E == "number" ? E : Number.parseInt(E, 10) || void 0, V = x(a.width), C = x(a.height);
      if (r.value) {
        if (V !== void 0 && C === void 0)
          return { height: V, width: V };
        if (V === void 0 && C !== void 0)
          return { height: C, width: C };
        if (V === void 0 && C === void 0)
          return { height: 1, width: 1 };
      }
      return {
        width: V,
        height: C
      };
    }), $ = i(
      () => _(g.value.width, g.value.height, a.blankColor)
    ), F = i(() => ({
      src: r.value ? $.value : a.src,
      alt: a.alt,
      width: g.value.width || void 0,
      height: g.value.height || void 0,
      srcset: r.value ? void 0 : y.value,
      sizes: r.value ? void 0 : k.value,
      loading: n.value ? "lazy" : "eager"
    })), P = i(
      () => S.value || p.value ? "float-start" : b.value || A.value ? "float-end" : c.value ? "mx-auto" : void 0
    ), O = i(() => ({
      "img-thumbnail": w.value,
      "img-fluid": v.value || m.value,
      "w-100": m.value,
      rounded: a.rounded === "" || a.rounded === !0,
      [`rounded-${a.rounded}`]: typeof a.rounded == "string" && a.rounded !== "",
      [`${P.value}`]: P.value !== void 0,
      "d-block": d.value || c.value
    })), _ = (x, V, C) => `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(
      l.replace("%{w}", String(x)).replace("%{h}", String(V)).replace("%{f}", C)
    )}`;
    return (x, V) => (f(), h("img", Q({ class: s(O) }, s(F), {
      onLoad: V[0] || (V[0] = (C) => t("load", C))
    }), null, 16));
  }
}), _t = /* @__PURE__ */ I({
  __name: "BCardImg",
  props: {
    alt: null,
    blank: { default: !1 },
    blankColor: null,
    bottom: { default: !1 },
    lazy: { default: !1 },
    height: null,
    left: { default: !1 },
    start: { default: !1 },
    right: { default: !1 },
    end: { default: !1 },
    sizes: null,
    src: null,
    srcset: null,
    top: { default: !1 },
    width: null
  },
  emits: ["load"],
  setup(e, { emit: t }) {
    const a = e, l = u(o(a, "bottom")), n = u(o(a, "end")), r = u(o(a, "left")), d = u(o(a, "right")), c = u(o(a, "start")), v = u(o(a, "top")), m = i(
      () => v.value ? "card-img-top" : d.value || n.value ? "card-img-right" : l.value ? "card-img-bottom" : r.value || c.value ? "card-img-left" : "card-img"
    ), S = i(() => ({
      alt: a.alt,
      height: a.height,
      src: a.src,
      lazy: a.lazy,
      width: a.width,
      blank: a.blank,
      blankColor: a.blankColor,
      sizes: a.sizes,
      srcset: a.srcset
    }));
    return (p, b) => (f(), N(da, Q({ class: s(m) }, s(S), {
      onLoad: b[0] || (b[0] = (A) => t("load", A))
    }), null, 16, ["class"]));
  }
}), Ws = ["innerHTML"], Yl = /* @__PURE__ */ I({
  __name: "BCardHeadFoot",
  props: {
    text: null,
    bgVariant: null,
    borderVariant: null,
    html: null,
    tag: { default: "div" },
    textVariant: null
  },
  setup(e) {
    const t = e, a = i(() => ({
      [`text-${t.textVariant}`]: t.textVariant !== void 0,
      [`bg-${t.bgVariant}`]: t.bgVariant !== void 0,
      [`border-${t.borderVariant}`]: t.borderVariant !== void 0
    }));
    return (l, n) => (f(), N(Z(e.tag), {
      class: L(s(a))
    }, {
      default: M(() => [
        e.html ? (f(), h("div", {
          key: 0,
          innerHTML: e.html
        }, null, 8, Ws)) : B(l.$slots, "default", { key: 1 }, () => [
          ee(W(e.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Zl = /* @__PURE__ */ I({
  __name: "BCardHeader",
  props: {
    text: null,
    bgVariant: null,
    borderVariant: null,
    html: null,
    tag: { default: "div" },
    textVariant: null
  },
  setup(e) {
    const t = e;
    return (a, l) => (f(), N(Yl, Q({ class: "card-header" }, t), {
      default: M(() => [
        B(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), en = /* @__PURE__ */ I({
  __name: "BCardTitle",
  props: {
    text: null,
    tag: { default: "h4" }
  },
  setup(e) {
    return (t, a) => (f(), N(Z(e.tag), { class: "card-title" }, {
      default: M(() => [
        B(t.$slots, "default", {}, () => [
          ee(W(e.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), tn = /* @__PURE__ */ I({
  __name: "BCardSubtitle",
  props: {
    text: null,
    tag: { default: "h6" },
    textVariant: { default: "muted" }
  },
  setup(e) {
    const t = e, a = i(() => [`text-${t.textVariant}`]);
    return (l, n) => (f(), N(Z(e.tag), {
      class: L(["card-subtitle mb-2", s(a)])
    }, {
      default: M(() => [
        B(l.$slots, "default", {}, () => [
          ee(W(e.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), an = /* @__PURE__ */ I({
  __name: "BCardBody",
  props: {
    bodyBgVariant: null,
    bodyTag: { default: "div" },
    bodyTextVariant: null,
    overlay: { default: !1 },
    subtitle: null,
    subtitleTag: { default: "h4" },
    subtitleTextVariant: null,
    title: null,
    titleTag: { default: "h4" },
    text: null
  },
  setup(e) {
    const t = e, a = Se(), l = u(o(t, "overlay")), n = i(() => !we(a.title)), r = i(() => !we(a.subtitle)), d = i(() => ({
      "card-img-overlay": l.value,
      [`text-${t.bodyTextVariant}`]: t.bodyTextVariant !== void 0,
      [`bg-${t.bodyBgVariant}`]: t.bodyBgVariant !== void 0
    }));
    return (c, v) => (f(), N(Z(e.bodyTag), {
      class: L(["card-body", s(d)])
    }, {
      default: M(() => [
        !!e.title || s(n) ? (f(), N(en, {
          key: 0,
          tag: e.titleTag
        }, {
          default: M(() => [
            B(c.$slots, "title", {}, () => [
              ee(W(e.title), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag"])) : X("", !0),
        !!e.subtitle || s(r) ? (f(), N(tn, {
          key: 1,
          tag: e.subtitleTag,
          "text-variant": e.subtitleTextVariant
        }, {
          default: M(() => [
            B(c.$slots, "subtitle", {}, () => [
              ee(W(e.subtitle), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag", "text-variant"])) : X("", !0),
        B(c.$slots, "default", {}, () => [
          ee(W(e.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), ln = /* @__PURE__ */ I({
  __name: "BCardFooter",
  props: {
    text: null,
    bgVariant: null,
    borderVariant: null,
    html: null,
    tag: { default: "div" },
    textVariant: null
  },
  setup(e) {
    const t = e;
    return (a, l) => (f(), N(Yl, Q({ class: "card-footer" }, t), {
      default: M(() => [
        B(a.$slots, "default", {}, () => [
          ee(W(e.text), 1)
        ])
      ]),
      _: 3
    }, 16));
  }
}), nn = /* @__PURE__ */ I({
  __name: "BCard",
  props: {
    align: null,
    bgVariant: null,
    bodyBgVariant: null,
    bodyClass: null,
    bodyTag: { default: "div" },
    bodyTextVariant: null,
    borderVariant: null,
    footer: null,
    footerBgVariant: null,
    footerBorderVariant: null,
    footerClass: null,
    footerHtml: { default: "" },
    footerTag: { default: "div" },
    footerTextVariant: null,
    header: null,
    headerBgVariant: null,
    headerBorderVariant: null,
    headerClass: null,
    headerHtml: { default: "" },
    headerTag: { default: "div" },
    headerTextVariant: null,
    imgAlt: null,
    imgBottom: { default: !1 },
    imgEnd: { default: !1 },
    imgHeight: null,
    imgLeft: { default: !1 },
    imgRight: { default: !1 },
    imgSrc: null,
    imgStart: { default: !1 },
    imgTop: { default: !1 },
    imgWidth: null,
    noBody: { default: !1 },
    overlay: { default: !1 },
    subtitle: null,
    subtitleTag: { default: "h6" },
    subtitleTextVariant: { default: "muted" },
    tag: { default: "div" },
    textVariant: null,
    title: null,
    titleTag: { default: "h4" },
    bodyText: { default: "" }
  },
  setup(e) {
    const t = e, a = Se(), l = u(o(t, "imgBottom")), n = u(o(t, "imgEnd")), r = u(o(t, "imgLeft")), d = u(o(t, "imgRight")), c = u(o(t, "imgStart")), v = u(o(t, "noBody")), m = i(() => !we(a.header)), S = i(() => !we(a.footer)), p = i(() => ({
      [`text-${t.align}`]: t.align !== void 0,
      [`text-${t.textVariant}`]: t.textVariant !== void 0,
      [`bg-${t.bgVariant}`]: t.bgVariant !== void 0,
      [`border-${t.borderVariant}`]: t.borderVariant !== void 0,
      "flex-row": r.value || c.value,
      "flex-row-reverse": n.value || d.value
    })), b = i(() => ({
      bgVariant: t.headerBgVariant,
      borderVariant: t.headerBorderVariant,
      html: t.headerHtml,
      tag: t.headerTag,
      textVariant: t.headerTextVariant
    })), A = i(() => ({
      overlay: t.overlay,
      bodyBgVariant: t.bodyBgVariant,
      bodyTag: t.bodyTag,
      bodyTextVariant: t.bodyTextVariant,
      subtitle: t.subtitle,
      subtitleTag: t.subtitleTag,
      subtitleTextVariant: t.subtitleTextVariant,
      title: t.title,
      titleTag: t.titleTag
    })), w = i(() => ({
      bgVariant: t.footerBgVariant,
      borderVariant: t.footerBorderVariant,
      html: t.footerHtml,
      tag: t.footerTag,
      textVariant: t.footerTextVariant
    })), y = i(() => ({
      src: t.imgSrc,
      alt: t.imgAlt,
      height: t.imgHeight,
      width: t.imgWidth,
      bottom: t.imgBottom,
      end: t.imgEnd,
      left: t.imgLeft,
      right: t.imgRight,
      start: t.imgStart,
      top: t.imgTop
    }));
    return (k, g) => (f(), N(Z(e.tag), {
      class: L(["card", s(p)])
    }, {
      default: M(() => [
        s(l) ? X("", !0) : B(k.$slots, "img", { key: 0 }, () => [
          e.imgSrc ? (f(), N(_t, Be(Q({ key: 0 }, s(y))), null, 16)) : X("", !0)
        ]),
        e.header || s(m) || e.headerHtml ? (f(), N(Zl, Q({ key: 1 }, s(b), { class: e.headerClass }), {
          default: M(() => [
            B(k.$slots, "header", {}, () => [
              ee(W(e.header), 1)
            ])
          ]),
          _: 3
        }, 16, ["class"])) : X("", !0),
        s(v) ? B(k.$slots, "default", { key: 3 }, () => [
          ee(W(e.bodyText), 1)
        ]) : (f(), N(an, Q({ key: 2 }, s(A), { class: e.bodyClass }), {
          default: M(() => [
            B(k.$slots, "default", {}, () => [
              ee(W(e.bodyText), 1)
            ])
          ]),
          _: 3
        }, 16, ["class"])),
        e.footer || s(S) || e.footerHtml ? (f(), N(ln, Q({ key: 4 }, s(w), { class: e.footerClass }), {
          default: M(() => [
            B(k.$slots, "footer", {}, () => [
              ee(W(e.footer), 1)
            ])
          ]),
          _: 3
        }, 16, ["class"])) : X("", !0),
        s(l) ? B(k.$slots, "img", { key: 5 }, () => [
          e.imgSrc ? (f(), N(_t, Be(Q({ key: 0 }, s(y))), null, 16)) : X("", !0)
        ]) : X("", !0)
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Ks = /* @__PURE__ */ I({
  __name: "BCardGroup",
  props: {
    columns: { default: !1 },
    deck: { default: !1 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, a = u(o(t, "columns")), l = u(o(t, "deck")), n = i(
      () => l.value ? "card-deck" : a.value ? "card-columns" : "card-group"
    ), r = i(() => [n.value]);
    return (d, c) => (f(), N(Z(e.tag), {
      class: L(s(r))
    }, {
      default: M(() => [
        B(d.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Xs = /* @__PURE__ */ I({
  __name: "BCardText",
  props: {
    text: null,
    tag: { default: "p" }
  },
  setup(e) {
    return (t, a) => (f(), N(Z(e.tag), { class: "card-text" }, {
      default: M(() => [
        B(t.$slots, "default", {}, () => [
          ee(W(e.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), Js = ["id", "onMouseenter", "onMouseleave"], Qs = {
  key: 0,
  class: "carousel-indicators"
}, Ys = ["aria-current", "aria-label", "onClick"], Zs = { class: "carousel-inner" }, er = /* @__PURE__ */ j("span", {
  class: "carousel-control-prev-icon",
  "aria-hidden": "true"
}, null, -1), tr = { class: "visually-hidden" }, ar = /* @__PURE__ */ j("span", {
  class: "carousel-control-next-icon",
  "aria-hidden": "true"
}, null, -1), lr = { class: "visually-hidden" }, nr = /* @__PURE__ */ I({
  __name: "BCarousel",
  props: {
    ride: { type: [Boolean, String], default: !1 },
    noHoverPause: { default: !1 },
    rideReverse: { default: !1 },
    fade: { default: !1 },
    id: null,
    imgHeight: null,
    imgWidth: null,
    background: null,
    modelValue: { default: 0 },
    controls: { default: !1 },
    indicators: { default: !1 },
    interval: { default: 5e3 },
    noTouch: { default: !1 },
    noWrap: { default: !1 },
    controlsPrevText: { default: "Previous" },
    controlsNextText: { default: "Next" },
    indicatorsButtonLabel: { default: "Slide" },
    keyboard: { default: !0 }
  },
  emits: ["slid", "slide", "update:modelValue"],
  setup(e, { expose: t, emit: a }) {
    const l = e, n = Se(), r = $e(o(l, "id"), "carousel"), d = u(o(l, "keyboard")), c = u(o(l, "rideReverse")), v = u(o(l, "noHoverPause")), m = u(o(l, "fade")), S = u(o(l, "controls")), p = u(o(l, "indicators")), b = u(o(l, "noTouch")), A = u(o(l, "noWrap"));
    let w = null, y = null;
    const k = K(!1), g = K(!0), $ = K(null), F = K(null), P = i(
      () => Nn(l.ride) ? ul(l.ride) : l.ride
    ), { pause: O, resume: _ } = Fl(
      () => {
        c.value ? q() : G();
      },
      o(l, "interval"),
      { immediate: P.value === "carousel" }
    ), x = i(
      () => P.value === !0 && k.value === !0 || P.value === "carousel"
    ), V = i(() => {
      var re, ue;
      return (ue = (re = n.default) == null ? void 0 : re.call(n)) != null ? ue : [];
    }), C = i(() => [
      "carousel",
      "slide",
      "pointer-event",
      { "carousel-fade": m.value }
    ]), E = (re, ue) => {
      var te, z;
      return new dl(re, {
        componentId: r.value,
        cancelable: !1,
        target: F.value,
        direction: g.value ? "right" : "left",
        from: ue,
        to: l.modelValue,
        relatedTarget: (z = (te = $.value) == null ? void 0 : te.children[l.modelValue]) != null ? z : null
      });
    }, D = (re) => {
      if (P.value === !0 && (k.value = !0), x.value === !0 && _(), g.value = !(re < l.modelValue), re >= V.value.length) {
        if (A.value)
          return;
        a("update:modelValue", 0);
        return;
      }
      if (re < 0) {
        if (A.value)
          return;
        a("update:modelValue", V.value.length - 1);
        return;
      }
      a("update:modelValue", re);
    }, q = () => D(l.modelValue - 1), G = () => D(l.modelValue + 1), se = (re) => {
      d.value !== !1 && re();
    }, J = () => {
      v.value || O();
    }, ge = () => {
      !x.value || _();
    }, ae = (re) => {
      b.value || (w = re.touches[0].clientX, y = re.touches[0].clientY, O());
    }, he = (re) => {
      if (!w || !y)
        return;
      const ue = re.touches[0].clientX, te = re.touches[0].clientY, z = w - ue, H = y - te;
      Math.abs(z) > Math.abs(H) && (z > 0 ? G() : q()), w = null, y = null, x.value !== !1 && _();
    };
    return ce(
      () => l.ride,
      () => k.value = !1
    ), t({ pause: O, resume: _ }), at(Sl, {
      background: l.background,
      width: l.imgWidth,
      height: l.imgHeight
    }), (re, ue) => (f(), h("div", {
      id: s(r),
      ref_key: "target",
      ref: F,
      class: L(s(C)),
      onKeydown: [
        ue[0] || (ue[0] = yt((te) => se(q), ["left"])),
        ue[1] || (ue[1] = yt((te) => se(G), ["right"]))
      ],
      onMouseenter: Xe(J, ["stop"]),
      onMouseleave: Xe(ge, ["stop"]),
      onTouchstartPassive: ae,
      onTouchendPassive: he
    }, [
      s(p) ? (f(), h("div", Qs, [
        (f(!0), h(ie, null, me(s(V).length, (te, z) => (f(), h("button", {
          key: z,
          type: "button",
          "data-bs-target": "",
          class: L(z === e.modelValue ? "active" : ""),
          "aria-current": z === e.modelValue ? "true" : void 0,
          "aria-label": `${e.indicatorsButtonLabel} ${z}`,
          onClick: (H) => D(z)
        }, null, 10, Ys))), 128))
      ])) : X("", !0),
      j("div", {
        ref_key: "relatedTarget",
        ref: $,
        class: "carousel-inner"
      }, [
        (f(!0), h(ie, null, me(s(V), (te, z) => (f(), N(nl, {
          key: z,
          "enter-from-class": `carousel-item-next carousel-item-${g.value ? "end" : "start"}`,
          "leave-active-class": "active",
          "leave-to-class": `carousel-item-prev carousel-item-${g.value ? "start" : "end"}`,
          onBeforeLeave: (H) => a("slide", E("slide", z)),
          onAfterLeave: (H) => a("slid", E("slid", z))
        }, {
          default: M(() => [
            Ge((f(), N(Z(te), {
              class: L({ active: z === e.modelValue })
            }, null, 8, ["class"])), [
              [la, z === e.modelValue]
            ])
          ]),
          _: 2
        }, 1032, ["enter-from-class", "leave-to-class", "onBeforeLeave", "onAfterLeave"]))), 128))
      ], 512),
      j("div", Zs, [
        B(re.$slots, "default")
      ]),
      s(S) ? (f(), h(ie, { key: 1 }, [
        j("button", {
          class: "carousel-control-prev",
          type: "button",
          onClick: q
        }, [
          er,
          j("span", tr, W(e.controlsPrevText), 1)
        ]),
        j("button", {
          class: "carousel-control-next",
          type: "button",
          onClick: G
        }, [
          ar,
          j("span", lr, W(e.controlsNextText), 1)
        ])
      ], 64)) : X("", !0)
    ], 42, Js));
  }
}), or = ["innerHTML"], sr = { key: 1 }, rr = ["innerHTML"], ir = { key: 1 }, ur = /* @__PURE__ */ I({
  __name: "BCarouselSlide",
  props: {
    imgSrc: null,
    imgHeight: null,
    imgWidth: null,
    interval: null,
    background: null,
    caption: null,
    captionHtml: null,
    captionTag: { default: "h3" },
    contentTag: { default: "div" },
    contentVisibleUp: null,
    id: null,
    imgAlt: null,
    imgBlank: { default: !1 },
    imgBlankColor: { default: "transparent" },
    text: null,
    textHtml: null,
    textTag: { default: "p" }
  },
  setup(e) {
    const t = e, a = Se(), l = He(Sl), n = i(() => t.text || t.textHtml || !we(a.text)), r = i(() => t.caption || t.captionHtml || !we(a.caption)), d = i(() => n.value || r.value || !we(a.default)), c = i(() => ({
      background: `${t.background || (l == null ? void 0 : l.background) || "rgb(171, 171, 171)"} none repeat scroll 0% 0%`
    })), v = i(() => ({
      "d-none": t.contentVisibleUp !== void 0,
      [`d-${t.contentVisibleUp}-block`]: t.contentVisibleUp !== void 0
    }));
    return (m, S) => (f(), h("div", {
      class: "carousel-item",
      style: Fe(s(c))
    }, [
      B(m.$slots, "img", {}, () => {
        var p, b;
        return [
          ve(da, {
            class: "d-block w-100",
            alt: e.imgAlt,
            src: e.imgSrc,
            width: e.imgWidth || ((p = s(l)) == null ? void 0 : p.width),
            height: e.imgHeight || ((b = s(l)) == null ? void 0 : b.height),
            blank: e.imgBlank,
            "blank-color": e.imgBlankColor
          }, null, 8, ["alt", "src", "width", "height", "blank", "blank-color"])
        ];
      }),
      s(d) ? (f(), N(Z(e.contentTag), {
        key: 0,
        class: L(["carousel-caption", s(v)])
      }, {
        default: M(() => [
          s(r) ? (f(), N(Z(e.captionTag), { key: 0 }, {
            default: M(() => [
              B(m.$slots, "caption", {}, () => [
                e.captionHtml ? (f(), h("span", {
                  key: 0,
                  innerHTML: e.captionHtml
                }, null, 8, or)) : (f(), h("span", sr, W(e.caption), 1))
              ])
            ]),
            _: 3
          })) : X("", !0),
          s(n) ? (f(), N(Z(e.textTag), { key: 1 }, {
            default: M(() => [
              B(m.$slots, "text", {}, () => [
                e.textHtml ? (f(), h("span", {
                  key: 0,
                  innerHTML: e.textHtml
                }, null, 8, rr)) : (f(), h("span", ir, W(e.text), 1))
              ])
            ]),
            _: 3
          })) : X("", !0),
          B(m.$slots, "default")
        ]),
        _: 3
      }, 8, ["class"])) : X("", !0)
    ], 4));
  }
}), La = At("", [], { type: [Boolean, String, Number], default: !1 }), za = At("offset", [""], { type: [String, Number], default: null }), Na = At("order", [""], { type: [String, Number], default: null }), dr = I({
  name: "BCol",
  props: {
    col: { type: [Boolean, String], default: !1 },
    cols: { type: [String, Number], default: null },
    ...La,
    offset: { type: [String, Number], default: null },
    ...za,
    order: { type: [String, Number], default: null },
    ...Na,
    alignSelf: { type: String, default: null },
    tag: { type: String, default: "div" }
  },
  setup(e) {
    const t = [
      { content: La, propPrefix: "cols", classPrefix: "col" },
      { content: za, propPrefix: "offset" },
      { content: Na, propPrefix: "order" }
    ], a = u(o(e, "col")), l = i(
      () => t.flatMap((r) => kl(e, r.content, r.propPrefix, r.classPrefix))
    );
    return {
      computedClasses: i(() => [
        l.value,
        {
          col: a.value || !l.value.some((r) => /^col-/.test(r)) && !e.cols,
          [`col-${e.cols}`]: !!e.cols,
          [`offset-${e.offset}`]: !!e.offset,
          [`order-${e.order}`]: !!e.order,
          [`align-self-${e.alignSelf}`]: !!e.alignSelf
        }
      ])
    };
  }
});
function cr(e, t, a, l, n, r) {
  return f(), N(Z(e.tag), {
    class: L(e.computedClasses)
  }, {
    default: M(() => [
      B(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
const st = /* @__PURE__ */ Te(dr, [["render", cr]]), Qe = {
  autoHide: !0,
  delay: 5e3,
  noCloseButton: !1,
  pos: "top-right",
  value: !0
};
class Da {
  constructor(t) {
    be(this, "vm");
    be(this, "containerPositions");
    xn(t) ? this.vm = t : this.vm = Ne(t), this.containerPositions = i(() => {
      const a = /* @__PURE__ */ new Set([]);
      return this.vm.toasts.map((l) => {
        l.options.pos && a.add(l.options.pos);
      }), a;
    });
  }
  toasts(t) {
    return t ? i(
      () => this.vm.toasts.filter((a) => {
        if (a.options.pos === t && a.options.value)
          return a;
      })
    ) : i(() => this.vm.toasts);
  }
  remove(...t) {
    this.vm.toasts = this.vm.toasts.filter((a) => {
      if (a.options.id && !t.includes(a.options.id))
        return a;
    });
  }
  isRoot() {
    var t;
    return (t = this.vm.root) != null ? t : !1;
  }
  show(t, a = Qe) {
    const l = { id: Re(), ...Qe, ...a }, n = {
      options: Ne(l),
      content: t
    };
    return this.vm.toasts.push(n), n;
  }
  info(t, a = Qe) {
    return this.show(t, { variant: "info", ...a });
  }
  danger(t, a = Qe) {
    return this.show(t, { variant: "danger", ...a });
  }
  warning(t, a = Qe) {
    return this.show(t, { variant: "warning", ...a });
  }
  success(t, a = Qe) {
    return this.show(t, { variant: "success", ...a });
  }
  hide() {
  }
}
class fr {
  constructor() {
    be(this, "vms");
    be(this, "rootInstance");
    be(this, "useToast", sn);
    this.vms = {};
  }
  getOrCreateViewModel(t) {
    if (!t) {
      if (this.rootInstance)
        return this.vms[this.rootInstance];
      const a = { root: !0, toasts: [], container: void 0, id: Symbol("toast") };
      return this.rootInstance = a.id, this.vms[a.id] = a, a;
    }
    if (t.root) {
      if (this.rootInstance)
        return this.vms[this.rootInstance];
      this.rootInstance = t.id;
    }
    return this.vms[t.id] = t, t;
  }
  getVM(t) {
    if (!t && this.rootInstance)
      return this.vms[this.rootInstance];
    if (t)
      return this.vms[t];
  }
}
const Kt = Symbol(), on = Symbol(), vr = {
  container: void 0,
  toasts: [],
  root: !1
};
function mr() {
  return He(on);
}
function sn(e, t = Kt) {
  const a = He(mr());
  if (!e)
    return new Da(a.getOrCreateViewModel());
  const l = { id: Symbol("toastInstance") }, n = { ...vr, ...l, ...e }, r = a.getOrCreateViewModel(n);
  return new Da(r);
}
const pr = {
  install: (e, t = {}) => {
    var a, l, n, r;
    e.provide(on, (l = (a = t == null ? void 0 : t.BToast) == null ? void 0 : a.injectkey) != null ? l : Kt), e.provide((r = (n = t == null ? void 0 : t.BToast) == null ? void 0 : n.injectkey) != null ? r : Kt, new fr());
  }
}, br = "toast-title", Ha = 1e3, rn = I({
  components: { BLink: Ve },
  props: {
    ...Je,
    delay: { type: Number, default: 5e3 },
    bodyClass: { type: String },
    body: { type: [Object, String] },
    headerClass: { type: String },
    headerTag: { type: String, default: "div" },
    animation: { type: [Boolean, String], default: !0 },
    id: { type: String },
    isStatus: { type: [Boolean, String], default: !1 },
    autoHide: { type: [Boolean, String], default: !0 },
    noCloseButton: { type: [Boolean, String], default: !1 },
    noFade: { type: [Boolean, String], default: !1 },
    noHoverPause: { type: [Boolean, String], default: !1 },
    solid: { type: [Boolean, String], default: !1 },
    static: { type: [Boolean, String], default: !1 },
    title: { type: String },
    modelValue: { type: [Boolean, String], default: !1 },
    toastClass: { type: Array },
    variant: { type: String }
  },
  emits: ["destroyed", "update:modelValue"],
  setup(e, { emit: t, slots: a }) {
    u(o(e, "animation"));
    const l = u(o(e, "isStatus")), n = u(o(e, "autoHide")), r = u(o(e, "noCloseButton")), d = u(o(e, "noFade")), c = u(o(e, "noHoverPause"));
    u(o(e, "solid")), u(o(e, "static"));
    const v = u(o(e, "modelValue")), m = K(!1), S = K(!1), p = K(!1), b = i(() => ({
      [`b-toast-${e.variant}`]: e.variant !== void 0,
      show: p.value || m.value
    }));
    let A, w, y;
    const k = () => {
      typeof A > "u" || (clearTimeout(A), A = void 0);
    }, g = i(
      () => Math.max(je(e.delay, 0), Ha)
    ), $ = () => {
      v.value && (w = y = 0, k(), S.value = !0, ft(() => {
        p.value = !1;
      }));
    }, F = () => {
      k(), t("update:modelValue", !0), w = y = 0, S.value = !1, Ie(() => {
        ft(() => {
          p.value = !0;
        });
      });
    }, P = () => {
      if (!n.value || c.value || !A || y)
        return;
      const q = Date.now() - w;
      q > 0 && (k(), y = Math.max(g.value - q, Ha));
    }, O = () => {
      (!n.value || c.value || !y) && (y = w = 0), _();
    };
    ce(v, (q) => {
      q ? F() : $();
    });
    const _ = () => {
      k(), n.value && (A = setTimeout($, y || g.value), w = Date.now(), y = 0);
    }, x = () => {
      m.value = !0, t("update:modelValue", !0);
    }, V = () => {
      m.value = !1, _();
    }, C = () => {
      m.value = !0;
    }, E = () => {
      m.value = !1, y = w = 0, t("update:modelValue", !1);
    };
    Pn(() => {
      k(), n.value && t("destroyed", e.id);
    }), ke(() => {
      Ie(() => {
        v.value && ft(() => {
          F();
        });
      });
    });
    const D = () => {
      Ie(() => {
        ft(() => {
          $();
        });
      });
    };
    return () => {
      const q = () => {
        const G = [], se = Pe(br, { hide: $ }, a);
        se ? G.push(le(se)) : e.title && G.push(le("strong", { class: "me-auto" }, e.title)), !r.value && G.length !== 0 && G.push(
          le(nt, {
            class: ["btn-close"],
            onClick: () => {
              $();
            }
          })
        );
        const J = [];
        if (G.length > 0 && J.push(
          le(
            e.headerTag,
            {
              class: "toast-header"
            },
            { default: () => G }
          )
        ), Pe("default", { hide: $ }, a) || e.body) {
          const ge = le(
            it(e) ? "b-link" : "div",
            {
              class: ["toast-body", e.bodyClass],
              onClick: it(e) ? { click: D } : {}
            },
            Pe("default", { hide: $ }, a) || e.body
          );
          J.push(ge);
        }
        return le(
          "div",
          {
            class: ["toast", e.toastClass, b.value],
            tabindex: "0"
          },
          J
        );
      };
      return le(
        "div",
        {
          class: ["b-toast"],
          id: e.id,
          role: S.value ? null : l.value ? "status" : "alert",
          "aria-live": S.value ? null : l.value ? "polite" : "assertive",
          "aria-atomic": S.value ? null : "true",
          onmouseenter: P,
          onmouseleave: O
        },
        [
          le(
            lt,
            {
              noFade: d.value,
              onAfterEnter: V,
              onBeforeEnter: x,
              onAfterLeave: E,
              onBeforeLeave: C
            },
            () => [p.value ? q() : ""]
          )
        ]
      );
    };
  }
}), Xt = /* @__PURE__ */ I({
  __name: "BToaster",
  props: {
    position: { default: "top-right" },
    instance: null
  },
  setup(e) {
    const t = e, a = {
      "top-left": "top-0 start-0",
      "top-center": "top-0 start-50 translate-middle-x",
      "top-right": "top-0 end-0",
      "middle-left": "top-50 start-0 translate-middle-y",
      "middle-center": "top-50 start-50 translate-middle",
      "middle-right": "top-50 end-0 translate-middle-y",
      "bottom-left": "bottom-0 start-0",
      "bottom-center": "bottom-0 start-50 translate-middle-x",
      "bottom-right": "bottom-0 end-0"
    }, l = i(() => a[t.position]), n = (r) => {
      var d;
      (d = t.instance) == null || d.remove(r);
    };
    return (r, d) => {
      var c;
      return f(), h("div", {
        class: L([[s(l)], "b-toaster position-fixed p-3"]),
        style: { "z-index": "11" }
      }, [
        (f(!0), h(ie, null, me((c = e.instance) == null ? void 0 : c.toasts(e.position).value, (v) => (f(), N(rn, {
          id: v.options.id,
          key: v.options.id,
          modelValue: v.options.value,
          "onUpdate:modelValue": (m) => v.options.value = m,
          "auto-hide": v.options.autoHide,
          delay: v.options.delay,
          "no-close-button": v.options.noCloseButton,
          title: v.content.title,
          body: v.content.body,
          component: v.content.body,
          variant: v.options.variant,
          onDestroyed: n
        }, null, 8, ["id", "modelValue", "onUpdate:modelValue", "auto-hide", "delay", "no-close-button", "title", "body", "component", "variant"]))), 128))
      ], 2);
    };
  }
}), gr = I({
  props: {
    gutterX: { type: String, default: null },
    gutterY: { type: String, default: null },
    fluid: { type: [Boolean, String], default: !1 },
    toast: { type: Object },
    position: { type: String, required: !1 }
  },
  setup(e, { slots: t, expose: a }) {
    const l = K();
    let n;
    const r = i(() => ({
      container: !e.fluid,
      ["container-fluid"]: typeof e.fluid == "boolean" && e.fluid,
      [`container-${e.fluid}`]: typeof e.fluid == "string",
      [`gx-${e.gutterX}`]: e.gutterX !== null,
      [`gy-${e.gutterY}`]: e.gutterY !== null
    }));
    return ke(() => {
      e.toast;
    }), e.toast && (n = sn({ container: l, root: e.toast.root }), a({})), () => {
      var c;
      const d = [];
      return n == null || n.containerPositions.value.forEach((v) => {
        d.push(le(Xt, { key: v, instance: n, position: v }));
      }), le("div", { class: [r.value, e.position], ref: l }, [
        ...d,
        (c = t.default) == null ? void 0 : c.call(t)
      ]);
    };
  },
  methods: {}
}), hr = { class: "visually-hidden" }, yr = ["aria-labelledby", "role"], un = /* @__PURE__ */ I({
  __name: "BDropdown",
  props: {
    id: null,
    menuClass: null,
    size: null,
    splitClass: null,
    splitVariant: null,
    text: null,
    toggleClass: null,
    autoClose: { type: [Boolean, String], default: !0 },
    block: { default: !1 },
    boundary: { default: "clippingParents" },
    dark: { default: !1 },
    disabled: { default: !1 },
    isNav: { default: !1 },
    dropup: { default: !1 },
    dropright: { default: !1 },
    dropleft: { default: !1 },
    noFlip: { default: !1 },
    offset: { default: 0 },
    popperOpts: { default: () => ({}) },
    right: { default: !1 },
    role: { default: "menu" },
    split: { default: !1 },
    splitButtonType: { default: "button" },
    splitHref: { default: void 0 },
    noCaret: { default: !1 },
    toggleText: { default: "Toggle dropdown" },
    variant: { default: "secondary" }
  },
  emits: ["show", "shown", "hide", "hidden", "click", "toggle"],
  setup(e, { expose: t, emit: a }) {
    const l = e, n = $e(o(l, "id"), "dropdown"), r = u(o(l, "block")), d = u(o(l, "dark")), c = u(o(l, "dropup")), v = u(o(l, "dropright")), m = u(o(l, "isNav")), S = u(o(l, "dropleft")), p = u(o(l, "right")), b = u(o(l, "split")), A = u(o(l, "noCaret")), w = K(), y = K(), k = K(), g = i(() => ({
      "d-grid": r.value,
      "d-flex": r.value && b.value
    })), $ = i(() => [
      b.value ? l.splitClass : l.toggleClass,
      {
        "nav-link": m.value,
        "dropdown-toggle": !b.value,
        "dropdown-toggle-no-caret": A.value && !b.value,
        "w-100": b.value && r.value
      }
    ]), F = i(() => [
      l.menuClass,
      {
        "dropdown-menu-dark": d.value,
        "dropdown-menu-end": p.value
      }
    ]), P = i(() => ({
      "data-bs-toggle": b.value ? void 0 : "dropdown",
      "aria-expanded": b.value ? void 0 : !1,
      ref: b.value ? void 0 : y,
      href: b.value ? l.splitHref : void 0
    })), O = i(() => ({
      ref: b.value ? y : void 0
    })), _ = () => {
      var V;
      (V = k.value) == null || V.hide();
    }, x = (V) => {
      b.value && a("click", V);
    };
    return qe(w, "show.bs.dropdown", () => a("show")), qe(w, "shown.bs.dropdown", () => a("shown")), qe(w, "hide.bs.dropdown", () => a("hide")), qe(w, "hidden.bs.dropdown", () => a("hidden")), ke(() => {
      var V;
      k.value = new zn((V = y.value) == null ? void 0 : V.$el, {
        autoClose: l.autoClose,
        boundary: l.boundary,
        offset: l.offset ? l.offset.toString() : "",
        reference: l.offset || b.value ? "parent" : "toggle",
        popperConfig: (C) => {
          const E = {
            placement: "bottom-start",
            modifiers: l.noFlip ? [
              {
                name: "flip",
                options: {
                  fallbackPlacements: []
                }
              }
            ] : []
          };
          return c.value ? E.placement = p.value ? "top-end" : "top-start" : v.value ? E.placement = "right-start" : S.value ? E.placement = "left-start" : p.value && (E.placement = "bottom-end"), jt(C, jt(E, l.popperOpts));
        }
      });
    }), t({
      hide: _
    }), (V, C) => (f(), h("div", {
      ref_key: "parent",
      ref: w,
      class: L([s(g), "btn-group"])
    }, [
      ve(et, Q({
        id: s(n),
        variant: e.splitVariant || e.variant,
        size: e.size,
        class: s($),
        disabled: e.disabled,
        type: e.splitButtonType
      }, s(P), { onClick: x }), {
        default: M(() => [
          B(V.$slots, "button-content", {}, () => [
            ee(W(e.text), 1)
          ])
        ]),
        _: 3
      }, 16, ["id", "variant", "size", "class", "disabled", "type"]),
      s(b) ? (f(), N(et, Q({
        key: 0,
        variant: e.variant,
        size: e.size,
        disabled: e.disabled
      }, s(O), {
        class: [e.toggleClass, "dropdown-toggle-split dropdown-toggle"],
        "data-bs-toggle": "dropdown",
        "aria-expanded": "false",
        onClick: C[0] || (C[0] = (E) => a("toggle"))
      }), {
        default: M(() => [
          j("span", hr, [
            B(V.$slots, "toggle-text", {}, () => [
              ee(W(e.toggleText), 1)
            ])
          ])
        ]),
        _: 3
      }, 16, ["variant", "size", "disabled", "class"])) : X("", !0),
      j("ul", {
        class: L(["dropdown-menu", s(F)]),
        "aria-labelledby": s(n),
        role: e.role
      }, [
        B(V.$slots, "default")
      ], 10, yr)
    ], 2));
  }
}), Br = { role: "presentation" }, $r = /* @__PURE__ */ I({
  __name: "BDropdownDivider",
  props: {
    tag: { default: "hr" }
  },
  setup(e) {
    return (t, a) => (f(), h("li", Br, [
      (f(), N(Z(e.tag), {
        class: "dropdown-divider",
        role: "separator",
        "aria-orientation": "horizontal"
      }))
    ]));
  }
}), kr = {}, Sr = { role: "presentation" }, Cr = { class: "px-4 py-3" };
function wr(e, t) {
  return f(), h("li", Sr, [
    j("form", Cr, [
      B(e.$slots, "default")
    ])
  ]);
}
const _r = /* @__PURE__ */ Te(kr, [["render", wr]]), Tr = { role: "presentation" }, Vr = ["id", "aria-describedby"], Ar = {
  inheritAttrs: !1
}, Or = /* @__PURE__ */ I({
  ...Ar,
  __name: "BDropdownGroup",
  props: {
    id: null,
    ariaDescribedby: null,
    header: null,
    headerClass: null,
    headerTag: { default: "header" },
    headerVariant: null
  },
  setup(e) {
    const t = e, a = i(
      () => t.id ? `${t.id}_group_dd_header` : void 0
    ), l = i(
      () => t.headerTag === "header" ? void 0 : "heading"
    ), n = i(() => [
      t.headerClass,
      {
        [`text-${t.headerVariant}`]: t.headerVariant !== void 0
      }
    ]);
    return (r, d) => (f(), h("li", Tr, [
      (f(), N(Z(e.headerTag), {
        id: s(a),
        class: L(["dropdown-header", s(n)]),
        role: s(l)
      }, {
        default: M(() => [
          B(r.$slots, "header", {}, () => [
            ee(W(e.header), 1)
          ])
        ]),
        _: 3
      }, 8, ["id", "class", "role"])),
      j("ul", Q({
        id: e.id,
        role: "group",
        class: "list-unstyled"
      }, r.$attrs, {
        "aria-describedby": e.ariaDescribedby || s(a)
      }), [
        B(r.$slots, "default")
      ], 16, Vr)
    ]));
  }
}), xr = {}, Pr = { class: "dropdown-header" };
function Ir(e, t) {
  return f(), h("li", null, [
    j("h6", Pr, [
      B(e.$slots, "default")
    ])
  ]);
}
const Fr = /* @__PURE__ */ Te(xr, [["render", Ir]]), Er = {
  inheritAttrs: !1
}, Lr = /* @__PURE__ */ I({
  ...Er,
  __name: "BDropdownItem",
  props: {
    href: null,
    linkClass: null,
    active: { default: !1 },
    disabled: { default: !1 },
    rel: { default: void 0 },
    target: { default: "_self" },
    variant: null
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = u(o(a, "active")), n = u(o(a, "disabled")), r = sl(), d = i(() => [
      a.linkClass,
      {
        active: l.value,
        disabled: n.value,
        [`text-${a.variant}`]: a.variant !== void 0
      }
    ]), c = i(
      () => a.href ? "a" : r.to ? Ve : "button"
    ), v = i(() => ({
      disabled: n.value,
      "aria-current": l.value ? "true" : null,
      href: c.value === "a" ? a.href : null,
      rel: a.rel,
      type: c.value === "button" ? "button" : null,
      target: a.target,
      ...r.to ? { activeClass: "active", ...r } : {}
    })), m = (S) => t("click", S);
    return (S, p) => (f(), h("li", {
      role: "presentation",
      class: L(S.$attrs.class)
    }, [
      (f(), N(Z(s(c)), Q({
        class: ["dropdown-item", s(d)]
      }, s(v), { onClick: m }), {
        default: M(() => [
          B(S.$slots, "default")
        ]),
        _: 3
      }, 16, ["class"]))
    ], 2));
  }
}), zr = ["disabled"], Nr = {
  inheritAttrs: !1
}, Dr = /* @__PURE__ */ I({
  ...Nr,
  __name: "BDropdownItemButton",
  props: {
    buttonClass: null,
    active: { default: !1 },
    activeClass: { default: "active" },
    disabled: { default: !1 },
    variant: null
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = u(o(a, "active")), n = u(o(a, "disabled")), r = i(() => [
      a.buttonClass,
      {
        [a.activeClass]: l.value,
        disabled: n.value,
        [`text-${a.variant}`]: a.variant !== void 0
      }
    ]), d = (c) => t("click", c);
    return (c, v) => (f(), h("li", {
      role: "presentation",
      class: L(c.$attrs.class)
    }, [
      j("button", {
        role: "menu",
        type: "button",
        class: L(["dropdown-item", s(r)]),
        disabled: s(n),
        onClick: d
      }, [
        B(c.$slots, "default")
      ], 10, zr)
    ], 2));
  }
}), Hr = { role: "presentation" }, Mr = { class: "px-4 py-1 mb-0 text-muted" }, Rr = /* @__PURE__ */ I({
  __name: "BDropdownText",
  props: {
    text: { default: "" }
  },
  setup(e) {
    return (t, a) => (f(), h("li", Hr, [
      j("p", Mr, [
        B(t.$slots, "default", {}, () => [
          ee(W(e.text), 1)
        ])
      ])
    ]));
  }
}), jr = ["id", "novalidate", "onSubmit"], dn = /* @__PURE__ */ I({
  __name: "BForm",
  props: {
    id: null,
    floating: { default: !1 },
    novalidate: { default: !1 },
    validated: { default: !1 }
  },
  emits: ["submit"],
  setup(e, { emit: t }) {
    const a = e, l = u(o(a, "floating")), n = u(o(a, "novalidate")), r = u(o(a, "validated")), d = i(() => ({
      "form-floating": l.value,
      "was-validated": r.value
    })), c = (v) => t("submit", v);
    return (v, m) => (f(), h("form", {
      id: e.id,
      novalidate: s(n),
      class: L(s(d)),
      onSubmit: Xe(c, ["prevent"])
    }, [
      B(v.$slots, "default")
    ], 42, jr));
  }
}), qr = { class: "form-floating" }, Gr = ["for"], Ur = /* @__PURE__ */ I({
  __name: "BFormFloatingLabel",
  props: {
    labelFor: null,
    label: null,
    text: null
  },
  setup(e) {
    return (t, a) => (f(), h("div", qr, [
      B(t.$slots, "default", {}, () => [
        ee(W(e.text), 1)
      ]),
      j("label", { for: e.labelFor }, [
        B(t.$slots, "label", {}, () => [
          ee(W(e.label), 1)
        ])
      ], 8, Gr)
    ]));
  }
}), Jt = /* @__PURE__ */ I({
  __name: "BFormInvalidFeedback",
  props: {
    ariaLive: null,
    forceShow: { default: !1 },
    id: null,
    text: null,
    role: null,
    state: { default: void 0 },
    tag: { default: "div" },
    tooltip: { default: !1 }
  },
  setup(e) {
    const t = e, a = u(o(t, "forceShow")), l = u(o(t, "state")), n = u(o(t, "tooltip")), r = i(
      () => a.value === !0 || l.value === !1
    ), d = i(() => ({
      "d-block": r.value,
      "invalid-feedback": !n.value,
      "invalid-tooltip": n.value
    })), c = i(() => ({
      id: t.id,
      role: t.role,
      "aria-live": t.ariaLive,
      "aria-atomic": t.ariaLive ? "true" : void 0
    }));
    return (v, m) => (f(), N(Z(e.tag), Q({ class: s(d) }, s(c)), {
      default: M(() => [
        B(v.$slots, "default", {}, () => [
          ee(W(e.text), 1)
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), gt = /* @__PURE__ */ I({
  __name: "BFormRow",
  props: {
    tag: { default: "div" }
  },
  setup(e) {
    return (t, a) => (f(), N(Z(e.tag), { class: "row d-flex flex-wrap" }, {
      default: M(() => [
        B(t.$slots, "default")
      ]),
      _: 3
    }));
  }
}), Qt = /* @__PURE__ */ I({
  __name: "BFormText",
  props: {
    id: null,
    inline: { default: !1 },
    tag: { default: "small" },
    text: null,
    textVariant: { default: "muted" }
  },
  setup(e) {
    const t = e, a = u(o(t, "inline")), l = i(() => [
      [`text-${t.textVariant}`],
      {
        "form-text": !a.value
      }
    ]);
    return (n, r) => (f(), N(Z(e.tag), {
      id: e.id,
      class: L(s(l))
    }, {
      default: M(() => [
        B(n.$slots, "default", {}, () => [
          ee(W(e.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), Yt = /* @__PURE__ */ I({
  __name: "BFormValidFeedback",
  props: {
    ariaLive: null,
    forceShow: { default: !1 },
    id: null,
    role: null,
    text: null,
    state: { default: void 0 },
    tag: { default: "div" },
    tooltip: { default: !1 }
  },
  setup(e) {
    const t = e, a = u(o(t, "forceShow")), l = u(o(t, "state")), n = u(o(t, "tooltip")), r = i(
      () => a.value === !0 || l.value === !0
    ), d = i(() => ({
      "d-block": r.value,
      "valid-feedback": !n.value,
      "valid-tooltip": n.value
    })), c = i(() => t.ariaLive ? "true" : void 0);
    return (v, m) => (f(), N(Z(e.tag), {
      id: e.id,
      role: e.role,
      "aria-live": e.ariaLive,
      "aria-atomic": s(c),
      class: L(s(d))
    }, {
      default: M(() => [
        B(v.$slots, "default", {}, () => [
          ee(W(e.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "role", "aria-live", "aria-atomic", "class"]));
  }
}), Wr = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "aria-required", "value", "indeterminate"], Kr = ["for"], Xr = {
  inheritAttrs: !1
}, cn = /* @__PURE__ */ I({
  ...Xr,
  __name: "BFormCheckbox",
  props: {
    ariaLabel: null,
    ariaLabelledBy: null,
    form: null,
    indeterminate: null,
    name: null,
    id: { default: void 0 },
    autofocus: { default: !1 },
    plain: { default: !1 },
    button: { default: !1 },
    switch: { default: !1 },
    disabled: { default: !1 },
    buttonVariant: { default: "secondary" },
    inline: { default: !1 },
    required: { default: void 0 },
    size: { default: "md" },
    state: { default: void 0 },
    uncheckedValue: { type: [Array, Set, Boolean, String, Object, Number], default: !1 },
    value: { type: [Array, Set, Boolean, String, Object, Number], default: !0 },
    modelValue: { type: [Array, Set, Boolean, String, Object, Number], default: void 0 }
  },
  emits: ["update:modelValue", "input", "change"],
  setup(e, { emit: t }) {
    const a = e, l = Se(), n = $e(o(a, "id"), "form-check"), r = u(o(a, "indeterminate")), d = u(o(a, "autofocus")), c = u(o(a, "plain")), v = u(o(a, "button")), m = u(o(a, "switch")), S = u(o(a, "disabled")), p = u(o(a, "inline")), b = u(o(a, "required")), A = u(o(a, "state")), w = K(null), y = K(!1), k = i(() => !we(l.default)), g = i({
      get: () => a.uncheckedValue ? Array.isArray(a.modelValue) ? a.modelValue.indexOf(a.value) > -1 : a.modelValue === a.value : a.modelValue,
      set: (x) => {
        let V = x;
        Array.isArray(a.modelValue) ? a.uncheckedValue && (V = a.modelValue, x ? (V.indexOf(a.uncheckedValue) > -1 && V.splice(V.indexOf(a.uncheckedValue), 1), V.push(a.value)) : (V.indexOf(a.value) > -1 && V.splice(V.indexOf(a.value), 1), V.push(a.uncheckedValue))) : V = x ? a.value : a.uncheckedValue, t("input", V), t("update:modelValue", V), t("change", V);
      }
    }), $ = i(() => Array.isArray(a.modelValue) ? a.modelValue.indexOf(a.value) > -1 : JSON.stringify(a.modelValue) === JSON.stringify(a.value)), F = Ne({
      plain: o(c, "value"),
      button: o(v, "value"),
      inline: o(p, "value"),
      switch: o(m, "value"),
      size: o(a, "size"),
      state: o(A, "value"),
      buttonVariant: o(a, "buttonVariant")
    }), P = Hl(F), O = Ml(F), _ = Rl(F);
    return ke(() => {
      d.value && w.value.focus();
    }), (x, V) => (f(), h("div", {
      class: L(s(P))
    }, [
      Ge(j("input", Q({ id: s(n) }, x.$attrs, {
        ref_key: "input",
        ref: w,
        "onUpdate:modelValue": V[0] || (V[0] = (C) => tt(g) ? g.value = C : null),
        class: s(O),
        type: "checkbox",
        disabled: s(S),
        required: !!e.name && !!s(b),
        name: e.name,
        form: e.form,
        "aria-label": e.ariaLabel,
        "aria-labelledby": e.ariaLabelledBy,
        "aria-required": e.name && s(b) ? "true" : void 0,
        value: e.value,
        indeterminate: s(r),
        onFocus: V[1] || (V[1] = (C) => y.value = !0),
        onBlur: V[2] || (V[2] = (C) => y.value = !1)
      }), null, 16, Wr), [
        [In, s(g)]
      ]),
      s(k) || !s(c) ? (f(), h("label", {
        key: 0,
        for: s(n),
        class: L([s(_), { active: s($), focus: y.value }])
      }, [
        B(x.$slots, "default")
      ], 10, Kr)) : X("", !0)
    ], 2));
  }
}), Jr = ["id"], Qr = ["innerHTML"], Yr = ["textContent"], Zr = /* @__PURE__ */ I({
  __name: "BFormCheckboxGroup",
  props: {
    id: null,
    form: null,
    modelValue: { default: () => [] },
    ariaInvalid: { default: void 0 },
    autofocus: { default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { default: !1 },
    disabled: { default: !1 },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    name: null,
    options: { default: () => [] },
    plain: { default: !1 },
    required: { default: !1 },
    size: null,
    stacked: { default: !1 },
    state: { default: void 0 },
    switches: { default: !1 },
    textField: { default: "text" },
    validated: { default: !1 },
    valueField: { default: "value" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { emit: t }) {
    const a = e, l = Se(), n = "BFormCheckbox", r = $e(o(a, "id"), "checkbox"), d = $e(o(a, "name"), "checkbox");
    u(o(a, "autofocus"));
    const c = u(o(a, "buttons")), v = u(o(a, "disabled"));
    u(o(a, "plain"));
    const m = u(o(a, "required")), S = u(o(a, "stacked")), p = u(o(a, "state")), b = u(o(a, "switches")), A = u(o(a, "validated")), w = i({
      get: () => a.modelValue,
      set: (F) => {
        if (JSON.stringify(F) === JSON.stringify(a.modelValue))
          return;
        const P = a.options.filter(
          (O) => F.map((_) => JSON.stringify(_)).includes(JSON.stringify(typeof O == "string" ? O : O[a.valueField]))
        ).map((O) => typeof O == "string" ? O : O[a.valueField]);
        t("input", P), t("update:modelValue", P), t("change", P);
      }
    }), y = i(
      () => (l.first ? wt(l.first(), n, v.value) : []).concat(a.options.map((F) => Gl(F, a))).concat(l.default ? wt(l.default(), n, v.value) : []).map((F, P) => Ul(F, P, a, d, r)).map((F) => ({
        ...F,
        props: {
          switch: b.value,
          ...F.props
        }
      }))
    ), k = Ne({
      required: o(m, "value"),
      ariaInvalid: o(a, "ariaInvalid"),
      state: o(p, "value"),
      validated: o(A, "value"),
      buttons: o(c, "value"),
      stacked: o(S, "value"),
      size: o(a, "size")
    }), g = jl(k), $ = ql(k);
    return (F, P) => (f(), h("div", Q(s(g), {
      id: s(r),
      role: "group",
      class: [s($), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      (f(!0), h(ie, null, me(s(y), (O, _) => (f(), N(cn, Q({
        key: _,
        modelValue: s(w),
        "onUpdate:modelValue": P[0] || (P[0] = (x) => tt(w) ? w.value = x : null)
      }, O.props), {
        default: M(() => [
          O.html ? (f(), h("span", {
            key: 0,
            innerHTML: O.html
          }, null, 8, Qr)) : (f(), h("span", {
            key: 1,
            textContent: W(O.text)
          }, null, 8, Yr))
        ]),
        _: 2
      }, 1040, ["modelValue"]))), 128))
    ], 16, Jr));
  }
}), fn = ["input", "select", "textarea"], ei = fn.map((e) => `${e}:not([disabled])`).join(), ti = [...fn, "a", "button", "label"], ai = "label", li = "invalid-feedback", ni = "valid-feedback", oi = "description", si = "default", ri = I({
  components: { BCol: st, BFormInvalidFeedback: Jt, BFormRow: gt, BFormText: Qt, BFormValidFeedback: Yt },
  props: {
    contentCols: { type: [Boolean, String, Number], required: !1 },
    contentColsLg: { type: [Boolean, String, Number], required: !1 },
    contentColsMd: { type: [Boolean, String, Number], required: !1 },
    contentColsSm: { type: [Boolean, String, Number], required: !1 },
    contentColsXl: { type: [Boolean, String, Number], required: !1 },
    description: { type: [String], required: !1 },
    disabled: { type: [Boolean, String], default: !1 },
    feedbackAriaLive: { type: String, default: "assertive" },
    id: { type: String, required: !1 },
    invalidFeedback: { type: String, required: !1 },
    label: { type: String, required: !1 },
    labelAlign: { type: [Boolean, String, Number], required: !1 },
    labelAlignLg: { type: [Boolean, String, Number], required: !1 },
    labelAlignMd: { type: [Boolean, String, Number], required: !1 },
    labelAlignSm: { type: [Boolean, String, Number], required: !1 },
    labelAlignXl: { type: [Boolean, String, Number], required: !1 },
    labelClass: { type: [Array, Object, String], required: !1 },
    labelCols: { type: [Boolean, String, Number], required: !1 },
    labelColsLg: { type: [Boolean, String, Number], required: !1 },
    labelColsMd: { type: [Boolean, String, Number], required: !1 },
    labelColsSm: { type: [Boolean, String, Number], required: !1 },
    labelColsXl: { type: [Boolean, String, Number], required: !1 },
    labelFor: { type: String, required: !1 },
    labelSize: { type: String, required: !1 },
    labelSrOnly: { type: [Boolean, String], default: !1 },
    state: { type: [Boolean, String], default: null },
    tooltip: { type: [Boolean, String], default: !1 },
    validFeedback: { type: String, required: !1 },
    validated: { type: [Boolean, String], default: !1 },
    floating: { type: [Boolean, String], default: !1 }
  },
  setup(e, { attrs: t }) {
    const a = u(o(e, "disabled")), l = u(o(e, "labelSrOnly")), n = u(o(e, "state")), r = u(o(e, "tooltip")), d = u(o(e, "validated")), c = u(o(e, "floating")), v = null, m = ["xs", "sm", "md", "lg", "xl"], S = (_, x) => m.reduce((V, C) => {
      const E = ga(C === "xs" ? "" : C, `${x}Align`), D = _[E] || null;
      return D && (C === "xs" ? V.push(`text-${D}`) : V.push(`text-${C}-${D}`)), V;
    }, []), p = (_, x) => m.reduce((V, C) => {
      const E = ga(C === "xs" ? "" : C, `${x}Cols`);
      let D = _[E];
      return D = D === "" ? !0 : D || !1, typeof D != "boolean" && D !== "auto" && (D = ot(D, 0), D = D > 0 ? D : !1), D && (C === "xs" ? V.cols = D : V[C || (typeof D == "boolean" ? "col" : "cols")] = D), V;
    }, {}), b = K(), A = (_, x = null) => {
      if (yl && e.labelFor) {
        const V = Bl(`#${Un(e.labelFor)}`, b);
        if (V) {
          const C = "aria-describedby", E = (_ || "").split(pt), D = (x || "").split(pt), q = (sa(V, C) || "").split(pt).filter((G) => !D.includes(G)).concat(E).filter((G, se, J) => J.indexOf(G) === se).filter((G) => G).join(" ").trim();
          q ? so(V, C, q) : ro(V, C);
        }
      }
    }, w = i(() => p(e, "content")), y = i(() => S(e, "label")), k = i(() => p(e, "label")), g = i(
      () => Object.keys(w.value).length > 0 || Object.keys(k.value).length > 0
    ), $ = i(
      () => typeof n.value == "boolean" ? n.value : null
    ), F = i(() => {
      const _ = $.value;
      return _ === !0 ? "is-valid" : _ === !1 ? "is-invalid" : null;
    }), P = i(
      () => xt(t.ariaInvalid, n.value)
    );
    return ce(
      () => v,
      (_, x) => {
        _ !== x && A(_, x);
      }
    ), ke(() => {
      Ie(() => {
        A(v);
      });
    }), {
      disabledBoolean: a,
      labelSrOnlyBoolean: l,
      stateBoolean: n,
      tooltipBoolean: r,
      validatedBoolean: d,
      floatingBoolean: c,
      ariaDescribedby: v,
      computedAriaInvalid: P,
      contentColProps: w,
      isHorizontal: g,
      labelAlignClasses: y,
      labelColProps: k,
      onLegendClick: (_) => {
        if (e.labelFor)
          return;
        const { target: x } = _, V = x ? x.tagName : "";
        if (ti.indexOf(V) !== -1)
          return;
        const C = no(ei, b).filter(lo);
        C.length === 1 && to(C[0]);
      },
      stateClass: F
    };
  },
  render() {
    const e = this.$props, t = this.$slots, a = $e(), l = !e.labelFor;
    let n = null;
    const r = Pe(ai, {}, t) || e.label, d = r ? Re("_BV_label_") : null;
    if (r || this.isHorizontal) {
      const P = l ? "legend" : "label";
      if (this.labelSrOnlyBoolean)
        r && (n = le(
          P,
          {
            class: "visually-hidden",
            id: d,
            for: e.labelFor || null
          },
          r
        )), this.isHorizontal ? n = le(st, this.labelColProps, { default: () => n }) : n = le("div", {}, [n]);
      else {
        const O = {
          onClick: l ? this.onLegendClick : null,
          ...this.isHorizontal ? this.labelColProps : {},
          tag: this.isHorizontal ? P : null,
          id: d,
          for: e.labelFor || null,
          tabIndex: l ? "-1" : null,
          class: [
            this.isHorizontal ? "col-form-label" : "form-label",
            {
              "bv-no-focus-ring": l,
              "col-form-label": this.isHorizontal || l,
              "pt-0": !this.isHorizontal && l,
              "d-block": !this.isHorizontal && !l,
              [`col-form-label-${e.labelSize}`]: !!e.labelSize
            },
            this.labelAlignClasses,
            e.labelClass
          ]
        };
        this.isHorizontal ? n = le(st, O, { default: () => r }) : n = le(P, O, r);
      }
    }
    let c = null;
    const v = Pe(li, {}, t) || this.invalidFeedback, m = v ? Re("_BV_feedback_invalid_") : void 0;
    v && (c = le(
      Jt,
      {
        ariaLive: e.feedbackAriaLive,
        id: m,
        state: this.stateBoolean,
        tooltip: this.tooltipBoolean
      },
      { default: () => v }
    ));
    let S = null;
    const p = Pe(ni, {}, t) || this.validFeedback, b = p ? Re("_BV_feedback_valid_") : void 0;
    p && (S = le(
      Yt,
      {
        ariaLive: e.feedbackAriaLive,
        id: b,
        state: this.stateBoolean,
        tooltip: this.tooltipBoolean
      },
      { default: () => p }
    ));
    let A = null;
    const w = Pe(oi, {}, t) || this.description, y = w ? Re("_BV_description_") : void 0;
    w && (A = le(
      Qt,
      {
        id: y
      },
      { default: () => w }
    ));
    const k = this.ariaDescribedby = [
      y,
      this.stateBoolean === !1 ? m : null,
      this.stateBoolean === !0 ? b : null
    ].filter((P) => P).join(" ") || null, g = [
      Pe(si, { ariaDescribedby: k, descriptionId: y, id: a, labelId: d }, t) || "",
      c,
      S,
      A
    ];
    !this.isHorizontal && this.floatingBoolean && g.push(n);
    let $ = le(
      "div",
      {
        ref: "content",
        class: [
          {
            "form-floating": !this.isHorizontal && this.floatingBoolean
          }
        ]
      },
      g
    );
    this.isHorizontal && ($ = le(st, { ref: "content", ...this.contentColProps }, { default: () => g }));
    const F = {
      class: [
        "mb-3",
        this.stateClass,
        {
          "was-validated": this.validatedBoolean
        }
      ],
      id: $e(o(e, "id")).value,
      disabled: l ? this.disabledBoolean : null,
      role: l ? null : "group",
      "aria-invalid": this.computedAriaInvalid,
      "aria-labelledby": l && this.isHorizontal ? d : null
    };
    return this.isHorizontal && !l ? le(gt, F, { default: () => [n, $] }) : le(
      l ? "fieldset" : "div",
      F,
      this.isHorizontal && l ? [le(gt, null, { default: () => [n, $] })] : this.isHorizontal || !this.floatingBoolean ? [n, $] : [$]
    );
  }
}), Ma = [
  "text",
  "number",
  "email",
  "password",
  "search",
  "url",
  "tel",
  "date",
  "time",
  "range",
  "color"
], ii = I({
  props: {
    ...Wl,
    max: { type: [String, Number], required: !1 },
    min: { type: [String, Number], required: !1 },
    step: { type: [String, Number], required: !1 },
    type: {
      type: String,
      default: "text",
      validator: (e) => Ma.includes(e)
    }
  },
  emits: ["update:modelValue", "change", "blur", "input"],
  setup(e, { emit: t }) {
    const { input: a, computedId: l, computedAriaInvalid: n, onInput: r, onChange: d, onBlur: c, focus: v, blur: m } = Kl(e, t), S = K(!1), p = i(() => {
      const w = e.type === "range", y = e.type === "color";
      return {
        "form-control-highlighted": S.value,
        "form-range": w,
        "form-control": y || !e.plaintext && !w,
        "form-control-color": y,
        "form-control-plaintext": e.plaintext && !w && !y,
        [`form-control-${e.size}`]: !!e.size,
        "is-valid": e.state === !0,
        "is-invalid": e.state === !1
      };
    }), b = i(
      () => Ma.includes(e.type) ? e.type : "text"
    );
    return {
      computedClasses: p,
      localType: b,
      input: a,
      computedId: l,
      computedAriaInvalid: n,
      onInput: r,
      onChange: d,
      onBlur: c,
      focus: v,
      blur: m,
      highlight: () => {
        S.value !== !0 && (S.value = !0, setTimeout(() => {
          S.value = !1;
        }, 2e3));
      }
    };
  }
}), ui = ["id", "name", "form", "type", "disabled", "placeholder", "required", "autocomplete", "readonly", "min", "max", "step", "list", "aria-required", "aria-invalid"];
function di(e, t, a, l, n, r) {
  return f(), h("input", Q({
    id: e.computedId,
    ref: "input",
    class: e.computedClasses,
    name: e.name || void 0,
    form: e.form || void 0,
    type: e.localType,
    disabled: e.disabled,
    placeholder: e.placeholder,
    required: e.required,
    autocomplete: e.autocomplete || void 0,
    readonly: e.readonly || e.plaintext,
    min: e.min,
    max: e.max,
    step: e.step,
    list: e.type !== "password" ? e.list : void 0,
    "aria-required": e.required ? "true" : void 0,
    "aria-invalid": e.computedAriaInvalid
  }, e.$attrs, {
    onInput: t[0] || (t[0] = (d) => e.onInput(d)),
    onChange: t[1] || (t[1] = (d) => e.onChange(d)),
    onBlur: t[2] || (t[2] = (d) => e.onBlur(d))
  }), null, 16, ui);
}
const ci = /* @__PURE__ */ Te(ii, [["render", di]]), fi = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "value", "aria-required"], vi = ["for"], vn = /* @__PURE__ */ I({
  __name: "BFormRadio",
  props: {
    ariaLabel: null,
    ariaLabelledby: null,
    form: null,
    id: null,
    name: null,
    size: null,
    autofocus: { default: !1 },
    modelValue: { type: [Boolean, String, Array, Object, Number], default: void 0 },
    plain: { default: !1 },
    button: { default: !1 },
    switch: { default: !1 },
    disabled: { default: !1 },
    buttonVariant: { default: "secondary" },
    inline: { default: !1 },
    required: { default: !1 },
    state: { default: void 0 },
    value: { type: [String, Boolean, Object, Number], default: !0 }
  },
  emits: ["input", "change", "update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = Se(), n = $e(o(a, "id"), "form-check"), r = u(o(a, "autofocus")), d = u(o(a, "plain")), c = u(o(a, "button")), v = u(o(a, "switch")), m = u(o(a, "disabled")), S = u(o(a, "inline")), p = u(o(a, "required")), b = u(o(a, "state")), A = K(null), w = K(!1), y = i({
      get: () => Array.isArray(a.modelValue) ? a.modelValue[0] : a.modelValue,
      set: (_) => {
        const x = _ ? a.value : !1, V = Array.isArray(a.modelValue) ? [x] : x;
        t("input", V), t("change", V), t("update:modelValue", V);
      }
    }), k = i(() => Array.isArray(a.modelValue) ? (a.modelValue || []).find((_) => _ === a.value) : JSON.stringify(a.modelValue) === JSON.stringify(a.value)), g = i(() => !we(l.default)), $ = Ne({
      plain: o(d, "value"),
      button: o(c, "value"),
      inline: o(S, "value"),
      switch: o(v, "value"),
      size: o(a, "size"),
      state: o(b, "value"),
      buttonVariant: o(a, "buttonVariant")
    }), F = Hl($), P = Ml($), O = Rl($);
    return ke(() => {
      r.value && A.value !== null && A.value.focus();
    }), (_, x) => (f(), h("div", {
      class: L(s(F))
    }, [
      Ge(j("input", Q({ id: s(n) }, _.$attrs, {
        ref_key: "input",
        ref: A,
        "onUpdate:modelValue": x[0] || (x[0] = (V) => tt(y) ? y.value = V : null),
        class: s(P),
        type: "radio",
        disabled: s(m),
        required: !!e.name && s(p),
        name: e.name,
        form: e.form,
        "aria-label": e.ariaLabel,
        "aria-labelledby": e.ariaLabelledby,
        value: e.value,
        "aria-required": !!e.name && s(p) ? !0 : void 0,
        onFocus: x[1] || (x[1] = (V) => w.value = !0),
        onBlur: x[2] || (x[2] = (V) => w.value = !1)
      }), null, 16, fi), [
        [Fn, s(y)]
      ]),
      s(g) || s(d) === !1 ? (f(), h("label", {
        key: 0,
        for: s(n),
        class: L([s(O), { active: s(k), focus: w.value }])
      }, [
        B(_.$slots, "default")
      ], 10, vi)) : X("", !0)
    ], 2));
  }
}), mi = ["id"], pi = ["innerHTML"], bi = ["textContent"], gi = /* @__PURE__ */ I({
  __name: "BFormRadioGroup",
  props: {
    size: null,
    form: null,
    id: null,
    name: null,
    modelValue: { type: [String, Boolean, Array, Object, Number], default: "" },
    ariaInvalid: { default: void 0 },
    autofocus: { default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { default: !1 },
    disabled: { default: !1 },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    options: { default: () => [] },
    plain: { default: !1 },
    required: { default: !1 },
    stacked: { default: !1 },
    state: { default: void 0 },
    textField: { default: "text" },
    validated: { default: !1 },
    valueField: { default: "value" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { emit: t }) {
    const a = e, l = Se(), n = "BFormRadio", r = $e(o(a, "id"), "radio"), d = $e(o(a, "name"), "checkbox");
    u(o(a, "autofocus"));
    const c = u(o(a, "buttons")), v = u(o(a, "disabled"));
    u(o(a, "plain"));
    const m = u(o(a, "required")), S = u(o(a, "stacked")), p = u(o(a, "state")), b = u(o(a, "validated")), A = i({
      get: () => a.modelValue,
      set: ($) => {
        t("input", $), t("update:modelValue", $), t("change", $);
      }
    }), w = i(
      () => (l.first ? wt(l.first(), n, v.value) : []).concat(a.options.map(($) => Gl($, a))).concat(l.default ? wt(l.default(), n, v.value) : []).map(($, F) => Ul($, F, a, d, r)).map(($) => ({
        ...$
      }))
    ), y = Ne({
      required: o(m, "value"),
      ariaInvalid: o(a, "ariaInvalid"),
      state: o(p, "value"),
      validated: o(b, "value"),
      buttons: o(c, "value"),
      stacked: o(S, "value"),
      size: o(a, "size")
    }), k = jl(y), g = ql(y);
    return ($, F) => (f(), h("div", Q(s(k), {
      id: s(r),
      role: "radiogroup",
      class: [s(g), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      (f(!0), h(ie, null, me(s(w), (P, O) => (f(), N(vn, Q({
        key: O,
        modelValue: s(A),
        "onUpdate:modelValue": F[0] || (F[0] = (_) => tt(A) ? A.value = _ : null)
      }, P.props), {
        default: M(() => [
          P.html ? (f(), h("span", {
            key: 0,
            innerHTML: P.html
          }, null, 8, pi)) : (f(), h("span", {
            key: 1,
            textContent: W(P.text)
          }, null, 8, bi))
        ]),
        _: 2
      }, 1040, ["modelValue"]))), 128))
    ], 16, mi));
  }
}), hi = ["value", "disabled"], ca = /* @__PURE__ */ I({
  __name: "BFormSelectOption",
  props: {
    value: null,
    disabled: { default: !1 }
  },
  setup(e) {
    const a = u(o(e, "disabled"));
    return (l, n) => (f(), h("option", {
      value: e.value,
      disabled: s(a)
    }, [
      B(l.$slots, "default")
    ], 8, hi));
  }
}), yi = ["label"], mn = /* @__PURE__ */ I({
  __name: "BFormSelectOptionGroup",
  props: {
    label: null,
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    options: { default: () => [] },
    textField: { default: "text" },
    valueField: { default: "value" }
  },
  setup(e) {
    const t = e, a = i(
      () => ia(t.options, "BFormSelectOptionGroup", t)
    );
    return (l, n) => (f(), h("optgroup", { label: e.label }, [
      B(l.$slots, "first"),
      (f(!0), h(ie, null, me(s(a), (r, d) => (f(), N(ca, Q({
        key: d,
        value: r.value,
        disabled: r.disabled
      }, l.$attrs, {
        innerHTML: r.html || r.text
      }), null, 16, ["value", "disabled", "innerHTML"]))), 128)),
      B(l.$slots, "default")
    ], 8, yi));
  }
}), Bi = ["id", "name", "form", "multiple", "size", "disabled", "required", "aria-required", "aria-invalid"], $i = /* @__PURE__ */ I({
  __name: "BFormSelect",
  props: {
    ariaInvalid: { default: void 0 },
    autofocus: { default: !1 },
    disabled: { default: !1 },
    disabledField: { default: "disabled" },
    form: null,
    htmlField: { default: "html" },
    id: null,
    labelField: { default: "label" },
    multiple: { default: !1 },
    name: null,
    options: { default: () => [] },
    optionsField: { default: "options" },
    plain: { default: !1 },
    required: { default: !1 },
    selectSize: { default: 0 },
    size: null,
    state: { default: void 0 },
    textField: { default: "text" },
    valueField: { default: "value" },
    modelValue: { default: "" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { expose: t, emit: a }) {
    const l = e, n = $e(o(l, "id"), "input"), r = u(o(l, "autofocus")), d = u(o(l, "disabled")), c = u(o(l, "multiple")), v = u(o(l, "plain")), m = u(o(l, "required")), S = u(o(l, "state")), p = K(), b = i(() => ({
      "form-control": v.value,
      [`form-control-${l.size}`]: l.size && v.value,
      "form-select": !v.value,
      [`form-select-${l.size}`]: l.size && !v.value,
      "is-valid": S.value === !0,
      "is-invalid": S.value === !1
    })), A = i(() => {
      if (l.selectSize || v.value)
        return l.selectSize;
    }), w = i(
      () => xt(l.ariaInvalid, S.value)
    ), y = i(
      () => ia(l.options, "BFormSelect", l)
    ), k = i({
      get() {
        return l.modelValue;
      },
      set(P) {
        a("change", P), a("update:modelValue", P), a("input", P);
      }
    }), g = () => {
      var P;
      d.value || (P = p.value) == null || P.focus();
    }, $ = () => {
      var P;
      d.value || (P = p.value) == null || P.blur();
    }, F = () => {
      var P;
      r.value && ((P = p.value) == null || P.focus());
    };
    return ke(() => {
      Ie(() => {
        F();
      });
    }), aa(() => {
      Ie(() => {
        F();
      });
    }), t({
      blur: $,
      focus: g
    }), (P, O) => Ge((f(), h("select", Q({
      id: s(n),
      ref_key: "input",
      ref: p
    }, P.$attrs, {
      "onUpdate:modelValue": O[0] || (O[0] = (_) => tt(k) ? k.value = _ : null),
      class: s(b),
      name: e.name,
      form: e.form || void 0,
      multiple: s(c) || void 0,
      size: s(A),
      disabled: s(d),
      required: s(m),
      "aria-required": s(m) ? !0 : void 0,
      "aria-invalid": s(w)
    }), [
      B(P.$slots, "first"),
      (f(!0), h(ie, null, me(s(y), (_, x) => (f(), h(ie, { key: x }, [
        Array.isArray(_.options) ? (f(), N(mn, {
          key: 0,
          label: _.label,
          options: _.options
        }, null, 8, ["label", "options"])) : (f(), N(ca, {
          key: 1,
          value: _.value,
          disabled: _.disabled,
          innerHTML: _.html || _.text
        }, null, 8, ["value", "disabled", "innerHTML"]))
      ], 64))), 128)),
      B(P.$slots, "default")
    ], 16, Bi)), [
      [En, s(k)]
    ]);
  }
}), ki = ["id"], pn = /* @__PURE__ */ I({
  __name: "BFormTag",
  props: {
    id: null,
    title: null,
    disabled: { default: !1 },
    noRemove: { default: !1 },
    pill: { default: !1 },
    removeLabel: { default: "Remove tag" },
    tag: { default: "span" },
    variant: { default: "secondary" }
  },
  emits: ["remove"],
  setup(e, { emit: t }) {
    const a = e, l = Se(), n = $e(o(a, "id")), r = u(o(a, "disabled")), d = u(o(a, "noRemove")), c = u(o(a, "pill")), v = i(
      () => {
        var p, b, A;
        return (A = ((b = (p = l.default) == null ? void 0 : p.call(l)[0].children) != null ? b : "").toString() || a.title) != null ? A : "";
      }
    ), m = i(() => `${n.value}taglabel__`), S = i(() => [
      `bg-${a.variant}`,
      {
        "text-dark": ["warning", "info", "light"].includes(a.variant),
        "rounded-pill": c.value,
        disabled: r.value
      }
    ]);
    return (p, b) => (f(), N(Z(e.tag), {
      id: s(n),
      title: s(v),
      class: L(["badge b-form-tag d-inline-flex align-items-center mw-100", s(S)]),
      "aria-labelledby": s(m)
    }, {
      default: M(() => [
        j("span", {
          id: s(m),
          class: "b-form-tag-content flex-grow-1 text-truncate"
        }, [
          B(p.$slots, "default", {}, () => [
            ee(W(s(v)), 1)
          ])
        ], 8, ki),
        !s(r) && !s(d) ? (f(), N(nt, {
          key: 0,
          "aria-keyshortcuts": "Delete",
          "aria-label": e.removeLabel,
          class: "b-form-tag-remove",
          white: !["warning", "info", "light"].includes(e.variant),
          "aria-describedby": s(m),
          "aria-controls": e.id,
          onClick: b[0] || (b[0] = (A) => t("remove", s(v)))
        }, null, 8, ["aria-label", "white", "aria-describedby", "aria-controls"])) : X("", !0)
      ]),
      _: 3
    }, 8, ["id", "title", "class", "aria-labelledby"]));
  }
}), Si = ["id"], Ci = ["id", "for", "aria-live"], wi = ["id", "aria-live"], _i = ["id"], Ti = ["aria-controls"], Vi = {
  role: "group",
  class: "d-flex"
}, Ai = ["id", "disabled", "value", "type", "placeholder", "form", "required"], Oi = ["disabled"], xi = {
  "aria-live": "polite",
  "aria-atomic": "true"
}, Pi = {
  key: 0,
  class: "d-block invalid-feedback"
}, Ii = {
  key: 1,
  class: "form-text text-muted"
}, Fi = {
  key: 2,
  class: "form-text text-muted"
}, Ei = ["name", "value"], Li = /* @__PURE__ */ I({
  __name: "BFormTags",
  props: {
    addButtonText: { default: "Add" },
    addButtonVariant: { default: "outline-secondary" },
    addOnChange: { default: !1 },
    autofocus: { default: !1 },
    disabled: { default: !1 },
    duplicateTagText: { default: "Duplicate tag(s)" },
    inputAttrs: null,
    inputClass: null,
    inputId: null,
    inputType: { default: "text" },
    invalidTagText: { default: "Invalid tag(s)" },
    form: null,
    limit: null,
    limitTagsText: { default: "Tag limit reached" },
    modelValue: { default: () => [] },
    name: null,
    noAddOnEnter: { default: !1 },
    noOuterFocus: { default: !1 },
    noTagRemove: { default: !1 },
    placeholder: { default: "Add tag..." },
    removeOnDelete: { default: !1 },
    required: { default: !1 },
    separator: null,
    state: { default: void 0 },
    size: null,
    tagClass: null,
    tagPills: { default: !1 },
    tagRemoveLabel: null,
    tagRemovedLabel: { default: "Tag removed" },
    tagValidator: { type: Function, default: () => !0 },
    tagVariant: { default: "secondary" }
  },
  emits: ["update:modelValue", "input", "tag-state", "focus", "focusin", "focusout", "blur"],
  setup(e, { emit: t }) {
    const a = e, l = $e(), n = u(o(a, "addOnChange")), r = u(o(a, "autofocus")), d = u(o(a, "disabled")), c = u(o(a, "noAddOnEnter")), v = u(o(a, "noOuterFocus")), m = u(o(a, "noTagRemove")), S = u(o(a, "removeOnDelete")), p = u(o(a, "required")), b = u(o(a, "state")), A = u(o(a, "tagPills")), w = K(null), y = i(() => a.inputId || `${l.value}input__`), k = K(a.modelValue), g = K(""), $ = K(!1), F = K(!1), P = K(""), O = K([]), _ = K([]), x = K([]), V = i(() => ({
      [`form-control-${a.size}`]: a.size !== void 0,
      disabled: d.value,
      focus: F.value,
      "is-invalid": b.value === !1,
      "is-valid": b.value === !0
    })), C = i(() => k.value.includes(g.value)), E = i(
      () => g.value === "" ? !1 : !a.tagValidator(g.value)
    ), D = i(() => k.value.length === a.limit), q = i(() => !E.value && !C.value), G = i(() => ({
      addButtonText: a.addButtonText,
      addButtonVariant: a.addButtonVariant,
      addTag: te,
      disableAddButton: q.value,
      disabled: d.value,
      duplicateTagText: a.duplicateTagText,
      duplicateTags: x.value,
      form: a.form,
      inputAttrs: {
        ...a.inputAttrs,
        disabled: d.value,
        form: a.form,
        id: y,
        value: g
      },
      inputHandlers: {
        input: he,
        keydown: ue,
        change: re
      },
      inputId: y,
      inputType: a.inputType,
      invalidTagText: a.invalidTagText,
      invalidTags: _.value,
      isDuplicate: C.value,
      isInvalid: E.value,
      isLimitReached: D.value,
      limitTagsText: a.limitTagsText,
      limit: a.limit,
      noTagRemove: m.value,
      placeholder: a.placeholder,
      removeTag: z,
      required: p.value,
      separator: a.separator,
      size: a.size,
      state: b.value,
      tagClass: a.tagClass,
      tagPills: A.value,
      tagRemoveLabel: a.tagRemoveLabel,
      tagVariant: a.tagVariant,
      tags: k.value
    }));
    ce(
      () => a.modelValue,
      (H) => {
        k.value = H;
      }
    );
    const se = () => {
      var H;
      r.value && ((H = w.value) == null || H.focus());
    }, J = (H) => {
      if (d.value) {
        H.target.blur();
        return;
      }
      t("focusin", H);
    }, ge = (H) => {
      d.value || v.value || (F.value = !0, t("focus", H));
    }, ae = (H) => {
      F.value = !1, t("blur", H);
    }, he = (H) => {
      var ne, ye;
      const Y = typeof H == "string" ? H : H.target.value;
      if ($.value = !1, ((ne = a.separator) == null ? void 0 : ne.includes(Y.charAt(0))) && Y.length > 0) {
        w.value && (w.value.value = "");
        return;
      }
      if (g.value = Y, (ye = a.separator) != null && ye.includes(Y.charAt(Y.length - 1))) {
        te(Y.slice(0, Y.length - 1));
        return;
      }
      O.value = a.tagValidator(Y) && !C.value ? [Y] : [], _.value = a.tagValidator(Y) ? [] : [Y], x.value = C.value ? [Y] : [], t("tag-state", O.value, _.value, x.value);
    }, re = (H) => {
      n.value && (he(H), C.value || te(g.value));
    }, ue = (H) => {
      if (H.key === "Enter" && !c.value) {
        te(g.value);
        return;
      }
      (H.key === "Backspace" || H.key === "Delete") && S.value && g.value === "" && $.value && k.value.length > 0 ? z(k.value[k.value.length - 1]) : $.value = !0;
    }, te = (H) => {
      var ne;
      if (H = (H || g.value).trim(), H === "" || C.value || !a.tagValidator(H) || a.limit && D.value)
        return;
      const Y = [...a.modelValue, H];
      g.value = "", $.value = !0, t("update:modelValue", Y), t("input", Y), (ne = w.value) == null || ne.focus();
    }, z = (H) => {
      var ne;
      const Y = k.value.indexOf((ne = H == null ? void 0 : H.toString()) != null ? ne : "");
      P.value = k.value.splice(Y, 1).toString(), t("update:modelValue", k.value);
    };
    return ke(() => {
      se(), a.modelValue.length > 0 && ($.value = !0);
    }), aa(se), (H, Y) => (f(), h("div", {
      id: s(l),
      class: L(["b-form-tags form-control h-auto", s(V)]),
      role: "group",
      tabindex: "-1",
      onFocusin: J,
      onFocusout: Y[1] || (Y[1] = (ne) => t("focusout", ne))
    }, [
      j("output", {
        id: `${s(l)}selected_tags__`,
        class: "visually-hidden",
        role: "status",
        for: s(y),
        "aria-live": F.value ? "polite" : "off",
        "aria-atomic": "true",
        "aria-relevant": "additions text"
      }, W(k.value.join(", ")), 9, Ci),
      j("div", {
        id: `${s(l)}removed_tags__`,
        role: "status",
        "aria-live": F.value ? "assertive" : "off",
        "aria-atomic": "true",
        class: "visually-hidden"
      }, " (" + W(e.tagRemovedLabel) + ") " + W(P.value), 9, wi),
      B(H.$slots, "default", Be(_e(s(G))), () => [
        j("ul", {
          id: `${s(l)}tag_list__`,
          class: "b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center"
        }, [
          (f(!0), h(ie, null, me(k.value, (ne, ye) => B(H.$slots, "tag", Be(Q({ key: ye }, { tag: ne, tagClass: e.tagClass, tagVariant: e.tagVariant, tagPills: s(A), removeTag: z })), () => [
            ve(pn, {
              class: L(e.tagClass),
              tag: "li",
              variant: e.tagVariant,
              pill: e.tagPills,
              onRemove: z
            }, {
              default: M(() => [
                ee(W(ne), 1)
              ]),
              _: 2
            }, 1032, ["class", "variant", "pill"])
          ])), 128)),
          j("li", {
            role: "none",
            "aria-live": "off",
            class: "b-from-tags-field flex-grow-1",
            "aria-controls": `${s(l)}tag_list__`
          }, [
            j("div", Vi, [
              j("input", Q({
                id: s(y),
                ref_key: "input",
                ref: w,
                disabled: s(d),
                value: g.value,
                type: e.inputType,
                placeholder: e.placeholder,
                class: "b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0",
                style: { outline: "currentcolor none 0px", "min-width": "5rem" }
              }, e.inputAttrs, {
                form: e.form,
                required: s(p),
                onInput: he,
                onChange: re,
                onKeydown: ue,
                onFocus: ge,
                onBlur: ae
              }), null, 16, Ai),
              s(q) ? (f(), h("button", {
                key: 0,
                type: "button",
                class: L(["btn b-form-tags-button py-0", [
                  `btn-${e.addButtonVariant}`,
                  {
                    "disabled invisible": g.value.length === 0
                  },
                  e.inputClass
                ]]),
                style: { "font-size": "90%" },
                disabled: s(d) || g.value.length === 0 || s(D),
                onClick: Y[0] || (Y[0] = (ne) => te(g.value))
              }, [
                B(H.$slots, "add-button-text", {}, () => [
                  ee(W(e.addButtonText), 1)
                ])
              ], 10, Oi)) : X("", !0)
            ])
          ], 8, Ti)
        ], 8, _i),
        j("div", xi, [
          s(E) ? (f(), h("div", Pi, W(e.invalidTagText) + ": " + W(g.value), 1)) : X("", !0),
          s(C) ? (f(), h("small", Ii, W(e.duplicateTagText) + ": " + W(g.value), 1)) : X("", !0),
          k.value.length === e.limit ? (f(), h("small", Fi, "Tag limit reached")) : X("", !0)
        ])
      ]),
      e.name ? (f(!0), h(ie, { key: 0 }, me(k.value, (ne, ye) => (f(), h("input", {
        key: ye,
        type: "hidden",
        name: e.name,
        value: ne
      }, null, 8, Ei))), 128)) : X("", !0)
    ], 42, Si));
  }
}), zi = I({
  props: {
    ...Wl,
    noResize: { type: [Boolean, String], default: !1 },
    rows: { type: [String, Number], required: !1, default: 2 },
    wrap: { type: String, default: "soft" }
  },
  emits: ["update:modelValue", "change", "blur", "input"],
  setup(e, { emit: t }) {
    const { input: a, computedId: l, computedAriaInvalid: n, onInput: r, onChange: d, onBlur: c, focus: v, blur: m } = Kl(e, t), S = u(o(e, "noResize")), p = i(() => ({
      "form-control": !e.plaintext,
      "form-control-plaintext": e.plaintext,
      [`form-control-${e.size}`]: !!e.size,
      "is-valid": e.state === !0,
      "is-invalid": e.state === !1
    })), b = i(
      () => S.value ? { resize: "none" } : void 0
    );
    return {
      input: a,
      computedId: l,
      computedAriaInvalid: n,
      onInput: r,
      onChange: d,
      onBlur: c,
      focus: v,
      blur: m,
      computedClasses: p,
      computedStyles: b
    };
  }
}), Ni = ["id", "name", "form", "disabled", "placeholder", "required", "autocomplete", "readonly", "aria-required", "aria-invalid", "rows", "wrap"];
function Di(e, t, a, l, n, r) {
  return f(), h("textarea", Q({
    id: e.computedId,
    ref: "input",
    class: e.computedClasses,
    name: e.name || void 0,
    form: e.form || void 0,
    disabled: e.disabled,
    placeholder: e.placeholder,
    required: e.required,
    autocomplete: e.autocomplete || void 0,
    readonly: e.readonly || e.plaintext,
    "aria-required": e.required ? "true" : void 0,
    "aria-invalid": e.computedAriaInvalid,
    rows: e.rows,
    style: e.computedStyles,
    wrap: e.wrap || void 0
  }, e.$attrs, {
    onInput: t[0] || (t[0] = (d) => e.onInput(d)),
    onChange: t[1] || (t[1] = (d) => e.onChange(d)),
    onBlur: t[2] || (t[2] = (d) => e.onBlur(d))
  }), null, 16, Ni);
}
const Hi = /* @__PURE__ */ Te(zi, [["render", Di]]), Mi = {
  key: 0,
  class: "input-group-text"
}, Ri = ["innerHTML"], ji = { key: 1 }, qi = {
  key: 0,
  class: "input-group-text"
}, Gi = ["innerHTML"], Ui = { key: 1 }, Wi = /* @__PURE__ */ I({
  __name: "BInputGroup",
  props: {
    append: null,
    appendHtml: null,
    id: null,
    prepend: null,
    prependHtml: null,
    size: null,
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, a = i(() => ({
      "input-group-sm": t.size === "sm",
      "input-group-lg": t.size === "lg"
    })), l = i(() => !!t.append || !!t.appendHtml), n = i(() => !!t.prepend || !!t.prependHtml);
    return (r, d) => (f(), N(Z(e.tag), {
      id: e.id,
      class: L(["input-group", s(a)]),
      role: "group"
    }, {
      default: M(() => [
        B(r.$slots, "prepend", {}, () => [
          s(n) ? (f(), h("span", Mi, [
            e.prependHtml ? (f(), h("span", {
              key: 0,
              innerHTML: e.prependHtml
            }, null, 8, Ri)) : (f(), h("span", ji, W(e.prepend), 1))
          ])) : X("", !0)
        ]),
        B(r.$slots, "default"),
        B(r.$slots, "append", {}, () => [
          s(l) ? (f(), h("span", qi, [
            e.appendHtml ? (f(), h("span", {
              key: 0,
              innerHTML: e.appendHtml
            }, null, 8, Gi)) : (f(), h("span", Ui, W(e.append), 1))
          ])) : X("", !0)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), bn = /* @__PURE__ */ I({
  __name: "BInputGroupText",
  props: {
    tag: { default: "div" },
    text: null
  },
  setup(e) {
    return (t, a) => (f(), N(Z(e.tag), { class: "input-group-text" }, {
      default: M(() => [
        B(t.$slots, "default", {}, () => [
          ee(W(e.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), fa = /* @__PURE__ */ I({
  __name: "BInputGroupAddon",
  props: {
    isText: { default: !1 }
  },
  setup(e) {
    const a = u(o(e, "isText"));
    return (l, n) => s(a) ? (f(), N(bn, { key: 0 }, {
      default: M(() => [
        B(l.$slots, "default")
      ]),
      _: 3
    })) : B(l.$slots, "default", { key: 1 });
  }
}), Ki = /* @__PURE__ */ I({
  __name: "BInputGroupAppend",
  props: {
    isText: { default: !1 }
  },
  setup(e) {
    return (t, a) => (f(), N(fa, { "is-text": e.isText }, {
      default: M(() => [
        B(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["is-text"]));
  }
}), Xi = /* @__PURE__ */ I({
  __name: "BInputGroupPrepend",
  props: {
    isText: { default: !1 }
  },
  setup(e) {
    return (t, a) => (f(), N(fa, { "is-text": e.isText }, {
      default: M(() => [
        B(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["is-text"]));
  }
}), Ji = /* @__PURE__ */ I({
  __name: "BListGroup",
  props: {
    flush: { default: !1 },
    horizontal: { type: [Boolean, String], default: !1 },
    numbered: { default: !1 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, a = u(o(t, "flush")), l = u(o(t, "numbered")), n = i(() => {
      const d = a.value ? !1 : t.horizontal;
      return {
        "list-group-flush": a.value,
        "list-group-horizontal": d === !0,
        [`list-group-horizontal-${d}`]: typeof d == "string",
        "list-group-numbered": l.value
      };
    }), r = i(() => l.value === !0 ? "ol" : t.tag);
    return at(Tl, {
      numbered: l.value
    }), (d, c) => (f(), N(Z(s(r)), {
      class: L(["list-group", s(n)])
    }, {
      default: M(() => [
        B(d.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Qi = /* @__PURE__ */ I({
  __name: "BListGroupItem",
  props: {
    action: { default: !1 },
    active: { default: !1 },
    button: { default: !1 },
    disabled: { default: !1 },
    href: null,
    tag: { default: "div" },
    target: { default: "_self" },
    to: null,
    variant: null
  },
  setup(e) {
    const t = e, a = sl(), l = He(Tl), n = u(o(t, "action")), r = u(o(t, "active")), d = u(o(t, "button")), c = u(o(t, "disabled")), v = i(() => !d.value && (!!t.href || !!t.to)), m = i(
      () => l != null && l.numbered ? "li" : d.value ? "button" : v.value ? Ve : t.tag
    ), S = i(
      () => n.value || v.value || d.value || ["a", "router-link", "button", "b-link"].includes(t.tag)
    ), p = i(() => ({
      [`list-group-item-${t.variant}`]: t.variant !== void 0,
      "list-group-item-action": S.value,
      active: r.value,
      disabled: c.value
    })), b = i(() => {
      const A = {};
      return d.value && ((!a || !a.type) && (A.type = "button"), c.value && (A.disabled = !0)), A;
    });
    return (A, w) => (f(), N(Z(s(m)), Q({
      class: ["list-group-item", s(p)],
      "aria-current": s(r) ? !0 : void 0,
      "aria-disabled": s(c) ? !0 : void 0,
      target: s(v) ? e.target : void 0,
      href: s(d) ? void 0 : e.href,
      to: s(d) ? void 0 : e.to
    }, s(b)), {
      default: M(() => [
        B(A.$slots, "default")
      ]),
      _: 3
    }, 16, ["class", "aria-current", "aria-disabled", "target", "href", "to"]));
  }
}), Yi = ["id", "aria-labelledby", "aria-describedby"], Zi = ["id"], eu = {
  inheritAttrs: !1
}, tu = /* @__PURE__ */ I({
  ...eu,
  __name: "BModal",
  props: {
    bodyBgVariant: null,
    bodyClass: null,
    bodyTextVariant: null,
    busy: { default: !1 },
    lazy: { default: !1 },
    buttonSize: { default: "md" },
    cancelDisabled: { default: !1 },
    cancelTitle: { default: "Cancel" },
    cancelVariant: { default: "secondary" },
    centered: { default: !1 },
    contentClass: null,
    dialogClass: null,
    footerBgVariant: null,
    footerBorderVariant: null,
    footerClass: null,
    footerTextVariant: null,
    fullscreen: { type: [Boolean, String], default: !1 },
    headerBgVariant: null,
    headerBorderVariant: null,
    headerClass: null,
    headerCloseLabel: { default: "Close" },
    headerCloseWhite: { default: !1 },
    headerTextVariant: null,
    hideBackdrop: { default: !1 },
    hideFooter: { default: !1 },
    hideHeader: { default: !1 },
    hideHeaderClose: { default: !1 },
    id: null,
    modalClass: null,
    modelValue: { default: !1 },
    noCloseOnBackdrop: { default: !1 },
    noCloseOnEsc: { default: !1 },
    noFade: { default: !1 },
    noFocus: { default: !1 },
    okDisabled: { default: !1 },
    okOnly: { default: !1 },
    okTitle: { default: "Ok" },
    okVariant: { default: "primary" },
    scrollable: { default: !1 },
    show: { default: !1 },
    size: null,
    title: null,
    titleClass: null,
    titleSrOnly: { default: !1 },
    titleTag: { default: "h5" },
    static: { default: !1 }
  },
  emits: ["update:modelValue", "show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "ok", "cancel", "close"],
  setup(e, { emit: t }) {
    const a = e, l = Se(), n = $e(o(a, "id"), "modal"), r = u(o(a, "busy")), d = u(o(a, "lazy")), c = u(o(a, "cancelDisabled")), v = u(o(a, "centered")), m = u(o(a, "hideBackdrop")), S = u(o(a, "hideFooter")), p = u(o(a, "hideHeader")), b = u(o(a, "hideHeaderClose")), A = u(o(a, "modelValue")), w = u(o(a, "noCloseOnBackdrop")), y = u(o(a, "noCloseOnEsc")), k = u(o(a, "noFade")), g = u(o(a, "noFocus")), $ = u(o(a, "okDisabled")), F = u(o(a, "okOnly")), P = u(o(a, "scrollable")), O = u(o(a, "titleSrOnly")), _ = u(o(a, "static")), x = K(!1), V = K(null), C = K(!1), E = i(() => [
      a.modalClass,
      {
        fade: !k.value,
        show: x.value
      }
    ]), D = i(
      () => d.value === !1 || d.value === !0 && C.value === !0 || d.value === !0 && A.value === !0
    ), q = i(() => !we(l["header-close"])), G = i(() => [
      a.dialogClass,
      {
        "modal-fullscreen": a.fullscreen === !0,
        [`modal-fullscreen-${a.fullscreen}-down`]: typeof a.fullscreen == "string",
        [`modal-${a.size}`]: a.size !== void 0,
        "modal-dialog-centered": v.value,
        "modal-dialog-scrollable": P.value
      }
    ]), se = i(() => [
      a.bodyClass,
      {
        [`bg-${a.bodyBgVariant}`]: a.bodyBgVariant !== void 0,
        [`text-${a.bodyTextVariant}`]: a.bodyTextVariant !== void 0
      }
    ]), J = i(() => [
      a.headerClass,
      {
        [`bg-${a.headerBgVariant}`]: a.headerBgVariant !== void 0,
        [`border-${a.headerBorderVariant}`]: a.headerBorderVariant !== void 0,
        [`text-${a.headerTextVariant}`]: a.headerTextVariant !== void 0
      }
    ]), ge = i(() => [
      a.footerClass,
      {
        [`bg-${a.footerBgVariant}`]: a.footerBgVariant !== void 0,
        [`border-${a.footerBorderVariant}`]: a.footerBorderVariant !== void 0,
        [`text-${a.footerTextVariant}`]: a.footerTextVariant !== void 0
      }
    ]), ae = i(() => [
      a.titleClass,
      {
        ["visually-hidden"]: O.value
      }
    ]), he = i(() => c.value || r.value), re = i(() => $.value || r.value), ue = (oe, de = {}) => new na(oe, {
      cancelable: !1,
      target: V.value || null,
      relatedTarget: null,
      trigger: null,
      ...de,
      componentId: n.value
    }), te = (oe = "") => {
      const de = ue("hide", { cancelable: oe !== "", trigger: oe });
      if (oe === "ok" && t(oe, de), oe === "cancel" && t(oe, de), oe === "close" && t(oe, de), t("hide", de), de.defaultPrevented || oe === "backdrop" && w.value || oe === "esc" && y.value) {
        t("update:modelValue", !0), t("hide-prevented");
        return;
      }
      t("update:modelValue", !1);
    }, z = () => {
      const oe = ue("show", { cancelable: !0 });
      if (t("show", oe), oe.defaultPrevented) {
        t("update:modelValue", !1), t("show-prevented");
        return;
      }
      t("update:modelValue", !0);
    }, H = () => z(), Y = () => {
      x.value = !0, t("shown", ue("shown")), d.value === !0 && (C.value = !0);
    }, ne = () => x.value = !1, ye = () => {
      t("hidden", ue("hidden")), d.value === !0 && (C.value = !1);
    };
    return ce(
      A,
      (oe) => {
        oe === !0 && !g.value && V.value !== null && V.value.focus();
      },
      { flush: "post" }
    ), (oe, de) => (f(), N(rl, {
      to: "body",
      disabled: s(_)
    }, [
      ve(lt, {
        "no-fade": !0,
        "trans-props": { enterToClass: "show" },
        onBeforeEnter: H,
        onAfterEnter: Y,
        onLeave: ne,
        onAfterLeave: ye
      }, {
        default: M(() => [
          Ge(j("div", Q({
            id: s(n),
            ref_key: "element",
            ref: V,
            class: ["modal", s(E)],
            role: "dialog",
            "aria-labelledby": `${s(n)}-label`,
            "aria-describedby": `${s(n)}-body`,
            tabindex: "-1"
          }, oe.$attrs, {
            onKeyup: de[5] || (de[5] = yt((Ae) => te("esc"), ["esc"]))
          }), [
            j("div", {
              class: L(["modal-dialog", s(G)])
            }, [
              s(D) ? (f(), h("div", {
                key: 0,
                class: L(["modal-content", e.contentClass])
              }, [
                s(p) ? X("", !0) : (f(), h("div", {
                  key: 0,
                  class: L(["modal-header", s(J)])
                }, [
                  B(oe.$slots, "header", {}, () => [
                    (f(), N(Z(e.titleTag), {
                      id: `${s(n)}-label`,
                      class: L(["modal-title", s(ae)])
                    }, {
                      default: M(() => [
                        B(oe.$slots, "title", {}, () => [
                          ee(W(e.title), 1)
                        ], !0)
                      ]),
                      _: 3
                    }, 8, ["id", "class"])),
                    s(b) ? X("", !0) : (f(), h(ie, { key: 0 }, [
                      s(q) ? (f(), h("button", {
                        key: 0,
                        type: "button",
                        onClick: de[0] || (de[0] = (Ae) => te("close"))
                      }, [
                        B(oe.$slots, "header-close", {}, void 0, !0)
                      ])) : (f(), N(nt, {
                        key: 1,
                        "aria-label": e.headerCloseLabel,
                        white: e.headerCloseWhite,
                        onClick: de[1] || (de[1] = (Ae) => te("close"))
                      }, null, 8, ["aria-label", "white"]))
                    ], 64))
                  ], !0)
                ], 2)),
                j("div", {
                  id: `${s(n)}-body`,
                  class: L(["modal-body", s(se)])
                }, [
                  B(oe.$slots, "default", {}, void 0, !0)
                ], 10, Zi),
                s(S) ? X("", !0) : (f(), h("div", {
                  key: 1,
                  class: L(["modal-footer", s(ge)])
                }, [
                  B(oe.$slots, "footer", {}, () => [
                    B(oe.$slots, "cancel", {}, () => [
                      s(F) ? X("", !0) : (f(), N(et, {
                        key: 0,
                        type: "button",
                        class: "btn",
                        disabled: s(he),
                        size: e.buttonSize,
                        variant: e.cancelVariant,
                        onClick: de[2] || (de[2] = (Ae) => te("cancel"))
                      }, {
                        default: M(() => [
                          ee(W(e.cancelTitle), 1)
                        ]),
                        _: 1
                      }, 8, ["disabled", "size", "variant"]))
                    ], !0),
                    B(oe.$slots, "ok", {}, () => [
                      ve(et, {
                        type: "button",
                        class: "btn",
                        disabled: s(re),
                        size: e.buttonSize,
                        variant: e.okVariant,
                        onClick: de[3] || (de[3] = (Ae) => te("ok"))
                      }, {
                        default: M(() => [
                          ee(W(e.okTitle), 1)
                        ]),
                        _: 1
                      }, 8, ["disabled", "size", "variant"])
                    ], !0)
                  ], !0)
                ], 2))
              ], 2)) : X("", !0)
            ], 2),
            s(m) ? X("", !0) : B(oe.$slots, "backdrop", { key: 0 }, () => [
              j("div", {
                class: "modal-backdrop fade show",
                onClick: de[4] || (de[4] = (Ae) => te("backdrop"))
              })
            ], !0)
          ], 16, Yi), [
            [la, s(A)]
          ])
        ]),
        _: 3
      })
    ], 8, ["disabled"]));
  }
});
const au = /* @__PURE__ */ Te(tu, [["__scopeId", "data-v-8331ea82"]]), lu = /* @__PURE__ */ I({
  __name: "BNav",
  props: {
    align: null,
    cardHeader: { default: !1 },
    fill: { default: !1 },
    justified: { default: !1 },
    pills: { default: !1 },
    small: { default: !1 },
    tabs: { default: !1 },
    tag: { default: "ul" },
    vertical: { default: !1 }
  },
  setup(e) {
    const t = e, a = u(o(t, "cardHeader")), l = u(o(t, "fill")), n = u(o(t, "justified")), r = u(o(t, "pills")), d = u(o(t, "small")), c = u(o(t, "tabs")), v = u(o(t, "vertical")), m = dt(o(t, "align")), S = i(() => ({
      "nav-tabs": c.value,
      "nav-pills": r.value && !c.value,
      "card-header-tabs": !v.value && a.value && c.value,
      "card-header-pills": !v.value && a.value && r.value && !c.value,
      "flex-column": v.value,
      "nav-fill": !v.value && l.value,
      "nav-justified": !v.value && n.value,
      [m.value]: !v.value && t.align !== void 0,
      small: d.value
    }));
    return (p, b) => (f(), N(Z(e.tag), {
      class: L(["nav", s(S)])
    }, {
      default: M(() => [
        B(p.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), nu = /* @__PURE__ */ I({
  __name: "BNavForm",
  props: {
    role: null,
    id: null,
    floating: { default: !1 },
    novalidate: { default: !1 },
    validated: { default: !1 }
  },
  emits: ["submit"],
  setup(e, { emit: t }) {
    const a = e, l = i(() => ({
      floating: a.floating,
      role: a.role,
      id: a.id,
      novalidate: a.novalidate,
      validated: a.validated
    })), n = (r) => t("submit", r);
    return (r, d) => (f(), N(dn, Q(s(l), {
      class: "d-flex",
      onSubmit: Xe(n, ["prevent"])
    }), {
      default: M(() => [
        B(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["onSubmit"]));
  }
}), ou = I({
  components: { BLink: Ve },
  props: {
    ...Ot(Je, ["event", "routerTag"])
  },
  setup(e) {
    return { disabledBoolean: u(o(e, "disabled")) };
  }
}), su = { class: "nav-item" };
function ru(e, t, a, l, n, r) {
  const d = ol("b-link");
  return f(), h("li", su, [
    ve(d, Q({ class: "nav-link" }, e.$props, {
      "active-class": "active",
      tabindex: e.disabledBoolean ? -1 : void 0,
      "aria-disabled": e.disabledBoolean ? !0 : void 0
    }), {
      default: M(() => [
        B(e.$slots, "default")
      ]),
      _: 3
    }, 16, ["tabindex", "aria-disabled"])
  ]);
}
const iu = /* @__PURE__ */ Te(ou, [["render", ru]]), uu = { class: "nav-item dropdown" }, du = /* @__PURE__ */ I({
  __name: "BNavItemDropdown",
  props: {
    id: null,
    text: null,
    toggleClass: null,
    size: null,
    offset: null,
    autoClose: { type: [Boolean, String], default: !0 },
    dark: { type: Boolean, default: !1 },
    dropleft: { type: Boolean, default: !1 },
    dropright: { type: Boolean, default: !1 },
    dropup: { type: Boolean, default: !1 },
    right: { type: Boolean, default: !1 },
    left: { type: [Boolean, String], default: !1 },
    split: { type: Boolean, default: !1 },
    splitVariant: null,
    noCaret: { type: Boolean, default: !1 },
    variant: { default: "link" }
  },
  setup(e) {
    const t = e;
    return (a, l) => (f(), h("li", uu, [
      ve(un, Q(t, { "is-nav": "" }), il({ _: 2 }, [
        me(a.$slots, (n, r, d) => ({
          name: r,
          fn: M((c) => [
            B(a.$slots, r, Be(_e(c || {})))
          ])
        }))
      ]), 1040)
    ]));
  }
}), cu = { class: "navbar-text" }, fu = /* @__PURE__ */ I({
  __name: "BNavText",
  props: {
    text: null
  },
  setup(e) {
    return (t, a) => (f(), h("li", cu, [
      B(t.$slots, "default", {}, () => [
        ee(W(e.text), 1)
      ])
    ]));
  }
}), vu = /* @__PURE__ */ I({
  __name: "BNavbar",
  props: {
    fixed: null,
    print: { default: !1 },
    sticky: null,
    tag: { default: "nav" },
    toggleable: { type: [Boolean, String], default: !1 },
    dark: { default: !1 },
    variant: null,
    container: { type: [String, Boolean], default: "fluid" }
  },
  setup(e) {
    const t = e, a = u(o(t, "print")), l = u(o(t, "dark")), n = i(
      () => t.tag === "nav" ? void 0 : "navigation"
    ), r = i(
      () => typeof t.toggleable == "string" ? `navbar-expand-${t.toggleable}` : t.toggleable === !1 ? "navbar-expand" : void 0
    ), d = i(
      () => t.container === !0 ? "container" : "container-fluid"
    ), c = i(() => ({
      "d-print": a.value,
      [`sticky-${t.sticky}`]: t.sticky !== void 0,
      "navbar-dark": l.value,
      [`bg-${t.variant}`]: t.variant !== void 0,
      [`fixed-${t.fixed}`]: t.fixed !== void 0,
      [`${r.value}`]: r.value !== void 0
    }));
    return (v, m) => (f(), N(Z(e.tag), {
      class: L(["navbar", s(c)]),
      role: s(n)
    }, {
      default: M(() => [
        e.container !== !1 ? (f(), h("div", {
          key: 0,
          class: L(s(d))
        }, [
          B(v.$slots, "default")
        ], 2)) : B(v.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 8, ["class", "role"]));
  }
}), Ra = Ot(Je, ["event", "routerTag"]), mu = I({
  components: {
    BLink: Ve
  },
  props: {
    tag: { type: String, default: "div" },
    ...Ra
  },
  setup(e) {
    const t = i(() => it(e)), a = i(
      () => t.value ? Ve : e.tag
    );
    return {
      computedLinkProps: i(
        () => t.value ? ra(e, Ra) : {}
      ),
      computedTag: a
    };
  }
});
function pu(e, t, a, l, n, r) {
  return f(), N(Z(e.computedTag), Q({ class: "navbar-brand" }, e.computedLinkProps), {
    default: M(() => [
      B(e.$slots, "default")
    ]),
    _: 3
  }, 16);
}
const bu = /* @__PURE__ */ Te(mu, [["render", pu]]), gu = /* @__PURE__ */ I({
  __name: "BNavbarNav",
  props: {
    align: null,
    fill: { default: !1 },
    justified: { default: !1 },
    small: { default: !1 },
    tag: { default: "ul" }
  },
  setup(e) {
    const t = e, a = u(o(t, "fill")), l = u(o(t, "justified")), n = u(o(t, "small")), r = dt(o(t, "align")), d = i(() => ({
      "nav-fill": a.value,
      "nav-justified": l.value,
      [r.value]: t.align !== void 0,
      small: n.value
    }));
    return (c, v) => (f(), h("ul", {
      class: L(["navbar-nav", s(d)])
    }, [
      B(c.$slots, "default")
    ], 2));
  }
}), hu = /* @__PURE__ */ j("span", { class: "navbar-toggler-icon" }, null, -1), yu = /* @__PURE__ */ I({
  __name: "BNavbarToggle",
  props: {
    disabled: { default: !1 },
    label: { default: "Toggle navigation" },
    target: null
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = u(o(a, "disabled")), n = i(() => ({
      disabled: l.value,
      "aria-label": a.label
    })), r = i(() => ({
      disabled: l.value
    })), d = (c) => {
      l.value || t("click", c);
    };
    return (c, v) => Ge((f(), h("button", Q({
      class: ["navbar-toggler", s(r)],
      type: "button"
    }, s(n), { onClick: d }), [
      B(c.$slots, "default", {}, () => [
        hu
      ])
    ], 16)), [
      [s(ua), s(l) ? void 0 : e.target]
    ]);
  }
}), gn = /* @__PURE__ */ I({
  __name: "BOverlay",
  props: {
    bgColor: null,
    blur: { default: "2px" },
    fixed: { default: !1 },
    noCenter: { default: !1 },
    noFade: { default: !1 },
    noWrap: { default: !1 },
    opacity: { default: 0.85 },
    overlayTag: { default: "div" },
    rounded: { type: [Boolean, String], default: !1 },
    show: { default: !1 },
    spinnerSmall: { default: !1 },
    spinnerType: { default: "border" },
    spinnerVariant: null,
    noSpinner: { default: !1 },
    variant: { default: "light" },
    wrapTag: { default: "div" },
    zIndex: { default: 10 }
  },
  emits: ["click", "hidden", "shown"],
  setup(e, { emit: t }) {
    const a = e, l = { top: 0, left: 0, bottom: 0, right: 0 }, n = u(o(a, "fixed")), r = u(o(a, "noSpinner")), d = u(o(a, "noCenter")), c = u(o(a, "noWrap")), v = u(o(a, "show")), m = u(o(a, "spinnerSmall")), S = i(
      () => a.rounded === !0 || a.rounded === "" ? "rounded" : a.rounded === !1 ? "" : `rounded-${a.rounded}`
    ), p = i(
      () => a.variant && !a.bgColor ? `bg-${a.variant}` : ""
    ), b = i(() => v.value ? "true" : null), A = i(() => ({
      type: a.spinnerType || void 0,
      variant: a.spinnerVariant || void 0,
      small: m.value
    })), w = i(() => ({
      ...l,
      zIndex: a.zIndex || 10
    })), y = i(() => [
      "b-overlay",
      {
        "position-absolute": !c.value || !n.value,
        "position-fixed": c.value && n.value
      }
    ]), k = i(() => [p.value, S.value]), g = i(() => ({
      ...l,
      opacity: a.opacity,
      backgroundColor: a.bgColor || void 0,
      backdropFilter: blur ? `blur(${blur})` : void 0
    })), $ = i(
      () => d.value ? l : {
        top: "50%",
        left: "50%",
        transform: "translateX(-50%) translateY(-50%)"
      }
    );
    return (F, P) => (f(), N(Z(e.wrapTag), {
      class: "b-overlay-wrap position-relative",
      "aria-busy": s(b)
    }, {
      default: M(() => [
        B(F.$slots, "default"),
        ve(lt, {
          "no-fade": e.noFade,
          "trans-props": { enterToClass: "show" },
          name: "fade",
          onOnAfterEnter: P[1] || (P[1] = (O) => t("shown")),
          onOnAfterLeave: P[2] || (P[2] = (O) => t("hidden"))
        }, {
          default: M(() => [
            s(v) ? (f(), N(Z(e.overlayTag), {
              key: 0,
              class: L(s(y)),
              style: Fe(s(w)),
              onClick: P[0] || (P[0] = (O) => t("click", O))
            }, {
              default: M(() => [
                j("div", {
                  class: L(["position-absolute", s(k)]),
                  style: Fe(s(g))
                }, null, 6),
                j("div", {
                  class: "position-absolute",
                  style: Fe(s($))
                }, [
                  B(F.$slots, "overlay", Be(_e(s(A))), () => [
                    s(r) ? X("", !0) : (f(), N(Pt, Be(Q({ key: 0 }, s(A))), null, 16))
                  ])
                ], 4)
              ]),
              _: 3
            }, 8, ["class", "style"])) : X("", !0)
          ]),
          _: 3
        }, 8, ["no-fade"])
      ]),
      _: 3
    }, 8, ["aria-busy"]));
  }
}), Bu = {
  key: 0,
  class: "offcanvas-header"
}, $u = {
  id: "offcanvasLabel",
  class: "offcanvas-title"
}, ku = { class: "offcanvas-body" }, Su = { key: 1 }, Cu = /* @__PURE__ */ I({
  __name: "BOffcanvas",
  props: {
    dismissLabel: { default: "Close" },
    modelValue: { default: !1 },
    bodyScrolling: { default: !1 },
    backdrop: { default: !0 },
    noCloseOnBackdrop: { default: !1 },
    noCloseOnEsc: { default: !1 },
    placement: { default: "start" },
    title: null,
    noHeaderClose: { default: !1 },
    noHeader: { default: !1 },
    lazy: { default: !1 },
    id: null,
    noFocus: { default: !1 },
    static: { default: !1 },
    backdropVariant: { default: "dark" }
  },
  emits: ["update:modelValue", "show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "esc", "close"],
  setup(e, { emit: t }) {
    const a = e, l = Se(), n = u(o(a, "modelValue"));
    u(o(a, "bodyScrolling"));
    const r = u(o(a, "backdrop")), d = u(o(a, "noHeaderClose")), c = u(o(a, "noHeader")), v = u(o(a, "noFocus")), m = u(o(a, "noCloseOnBackdrop")), S = u(o(a, "noCloseOnEsc")), p = u(o(a, "lazy")), b = u(o(a, "static")), A = $e(o(a, "id"), "offcanvas"), w = K(!1), y = K(null), k = K(!1), g = i(
      () => r.value === !0 && n.value === !0
    ), $ = i(
      () => p.value === !1 || p.value === !0 && k.value === !0 || p.value === !0 && n.value === !0
    ), F = i(() => !we(l.footer)), P = i(() => [
      "offcanvas",
      `offcanvas-${a.placement}`,
      {
        show: n.value && w.value === !0
      }
    ]), O = (q, G = {}) => new na(q, {
      cancelable: !1,
      target: y.value || null,
      relatedTarget: null,
      trigger: null,
      ...G,
      componentId: A.value
    }), _ = (q = "") => {
      const G = O("hide", { cancelable: q !== "", trigger: q });
      if (q === "close" && t(q, G), q === "esc" && t(q, G), t("hide", G), G.defaultPrevented || q === "backdrop" && m.value || q === "esc" && S.value) {
        t("update:modelValue", !0), t("hide-prevented");
        return;
      }
      t("update:modelValue", !1);
    }, x = () => {
      const q = O("show", { cancelable: !0 });
      if (t("show", q), q.defaultPrevented) {
        t("update:modelValue", !1), t("show-prevented");
        return;
      }
      t("update:modelValue", !0);
    }, V = () => x(), C = () => {
      w.value = !0, t("shown", O("shown")), p.value === !0 && (k.value = !0);
    }, E = () => w.value = !1, D = () => {
      t("hidden", O("hidden")), p.value === !0 && (k.value = !1);
    };
    return ke(() => {
      n.value === !0 && (w.value = !0);
    }), ce(
      n,
      (q) => {
        q === !0 && !v.value && y.value !== null && y.value.focus();
      },
      { flush: "post" }
    ), (q, G) => (f(), N(rl, {
      to: "body",
      disabled: s(b)
    }, [
      ve(lt, {
        "no-fade": !0,
        "trans-props": {
          enterToClass: "showing",
          enterFromClass: "",
          leaveToClass: "hiding show",
          leaveFromClass: "show"
        },
        onBeforeEnter: V,
        onAfterEnter: C,
        onLeave: E,
        onAfterLeave: D
      }, {
        default: M(() => [
          Ge(j("div", {
            ref_key: "element",
            ref: y,
            "aria-modal": "true",
            role: "dialog",
            class: L(s(P)),
            tabindex: "-1",
            "aria-labelledby": "offcanvasLabel",
            "data-bs-backdrop": "false",
            onKeyup: G[1] || (G[1] = yt((se) => _("esc"), ["esc"]))
          }, [
            s($) ? (f(), h(ie, { key: 0 }, [
              s(c) ? X("", !0) : (f(), h("div", Bu, [
                B(q.$slots, "header", Be(_e({ visible: s(n), placement: e.placement, hide: _ })), () => [
                  j("h5", $u, [
                    B(q.$slots, "title", {}, () => [
                      ee(W(e.title), 1)
                    ])
                  ]),
                  s(d) ? X("", !0) : (f(), N(nt, {
                    key: 0,
                    class: "text-reset",
                    "aria-label": e.dismissLabel,
                    onClick: G[0] || (G[0] = (se) => _("close"))
                  }, null, 8, ["aria-label"]))
                ])
              ])),
              j("div", ku, [
                B(q.$slots, "default")
              ]),
              s(F) ? (f(), h("div", Su, [
                B(q.$slots, "footer", Be(_e({ visible: s(n), placement: e.placement, hide: _ })))
              ])) : X("", !0)
            ], 64)) : X("", !0)
          ], 34), [
            [la, e.modelValue]
          ])
        ]),
        _: 3
      }),
      ve(gn, {
        variant: e.backdropVariant,
        show: s(g),
        fixed: !0,
        "no-wrap": "",
        "no-spinner": !0,
        onClick: G[2] || (G[2] = (se) => _("backdrop"))
      }, null, 8, ["variant", "show"])
    ], 8, ["disabled"]));
  }
}), wu = 5, hn = 20, yn = 0, Ee = 3, _u = "ellipsis-text", Tu = "first-text", Vu = "last-text", Au = "next-text", Ou = "page", xu = "prev-text", ja = (e) => Math.max(je(e) || hn, 1), qa = (e) => Math.max(je(e) || yn, 0), Pu = (e, t) => {
  const a = je(e) || 1;
  return a > t ? t : a < 1 ? 1 : a;
}, Iu = I({
  name: "BPagination",
  props: {
    align: { type: String, default: "start" },
    ariaControls: { type: String, required: !1 },
    ariaLabel: { type: String, default: "Pagination" },
    disabled: { type: [Boolean, String], default: !1 },
    ellipsisClass: { type: [Array, String], default: () => [] },
    ellipsisText: { type: String, default: "\u2026" },
    firstClass: { type: [Array, String], default: () => [] },
    firstNumber: { type: [Boolean, String], default: !1 },
    firstText: { type: String, default: "\xAB" },
    hideEllipsis: { type: [Boolean, String], default: !1 },
    hideGotoEndButtons: { type: [Boolean, String], default: !1 },
    labelFirstPage: { type: String, default: "Go to first page" },
    labelLastPage: { type: String, default: "Go to last page" },
    labelNextPage: { type: String, default: "Go to next page" },
    labelPage: { type: String, default: "Go to page" },
    labelPrevPage: { type: String, default: "Go to previous page" },
    lastClass: { type: [Array, String], default: () => [] },
    lastNumber: { type: [Boolean, String], default: !1 },
    lastText: { type: String, default: "\xBB" },
    limit: { type: Number, default: wu },
    modelValue: { type: Number, default: 1 },
    nextClass: { type: [Array, String], default: () => [] },
    nextText: { type: String, default: "\u203A" },
    pageClass: { type: [Array, String], default: () => [] },
    perPage: { type: Number, default: hn },
    pills: { type: [Boolean, String], default: !1 },
    prevClass: { type: [Array, String], default: () => [] },
    prevText: { type: String, default: "\u2039" },
    size: { type: String, required: !1 },
    totalRows: { type: Number, default: yn }
  },
  emits: ["update:modelValue", "page-click"],
  setup(e, { emit: t, slots: a }) {
    const l = u(o(e, "disabled")), n = u(o(e, "firstNumber")), r = u(o(e, "hideEllipsis")), d = u(o(e, "hideGotoEndButtons")), c = u(o(e, "lastNumber")), v = u(o(e, "pills")), m = i(
      () => e.align === "fill" ? "start" : e.align
    ), S = dt(o(m, "value")), p = i(
      () => Math.ceil(qa(e.totalRows) / ja(e.perPage))
    ), b = i(() => {
      let O;
      return p.value - e.modelValue + 2 < e.limit && e.limit > Ee ? O = p.value - w.value + 1 : O = e.modelValue - Math.floor(w.value / 2), O < 1 ? O = 1 : O > p.value - w.value && (O = p.value - w.value + 1), e.limit <= Ee && c.value && p.value === O + w.value - 1 && (O = Math.max(O - 1, 1)), O;
    }), A = i(() => {
      const O = p.value - e.modelValue;
      let _ = !1;
      return O + 2 < e.limit && e.limit > Ee ? e.limit > Ee && (_ = !0) : e.limit > Ee && (_ = !!(!r.value || n.value)), b.value <= 1 && (_ = !1), _ && n.value && b.value < 4 && (_ = !1), _;
    }), w = i(() => {
      let O = e.limit;
      return p.value <= e.limit ? O = p.value : e.modelValue < e.limit - 1 && e.limit > Ee ? ((!r.value || c.value) && (O = e.limit - (n.value ? 0 : 1)), O = Math.min(O, e.limit)) : p.value - e.modelValue + 2 < e.limit && e.limit > Ee ? (!r.value || n.value) && (O = e.limit - (c.value ? 0 : 1)) : e.limit > Ee && (O = e.limit - (r.value ? 0 : 2)), O;
    }), y = i(() => {
      const O = p.value - w.value;
      let _ = !1;
      e.modelValue < e.limit - 1 && e.limit > Ee ? (!r.value || c.value) && (_ = !0) : e.limit > Ee && (_ = !!(!r.value || c.value)), b.value > O && (_ = !1);
      const x = b.value + w.value - 1;
      return _ && c.value && x > p.value - 3 && (_ = !1), _;
    }), k = Ne({
      pageSize: ja(e.perPage),
      totalRows: qa(e.totalRows),
      numberOfPages: p.value
    }), g = (O, _) => {
      if (_ === e.modelValue)
        return;
      const { target: x } = O, V = new De("page-click", {
        cancelable: !0,
        target: x
      });
      t("page-click", V, _), !V.defaultPrevented && t("update:modelValue", _);
    }, $ = i(() => e.size ? `pagination-${e.size}` : ""), F = i(() => v.value ? "b-pagination-pills" : "");
    ce(
      () => e.modelValue,
      (O) => {
        const _ = Pu(O, p.value);
        _ !== e.modelValue && t("update:modelValue", _);
      }
    ), ce(k, (O, _) => {
      O != null && (_.pageSize !== O.pageSize && _.totalRows === O.totalRows || _.numberOfPages !== O.numberOfPages && e.modelValue > _.numberOfPages) && t("update:modelValue", 1);
    });
    const P = i(() => {
      const O = [];
      for (let _ = 0; _ < w.value; _++)
        O.push({ number: b.value + _, classes: null });
      return O;
    });
    return () => {
      const O = [], _ = P.value.map((J) => J.number), x = (J) => J === e.modelValue, V = e.modelValue < 1, C = e.align === "fill", E = (J, ge, ae, he, re, ue) => {
        const te = l.value || x(ue) || V || J < 1 || J > p.value, z = J < 1 ? 1 : J > p.value ? p.value : J, H = { disabled: te, page: z, index: z - 1 }, Y = Pe(ae, H, a) || he || "";
        return le(
          "li",
          {
            class: [
              "page-item",
              {
                disabled: te,
                "flex-fill": C,
                "d-flex": C && !te
              },
              re
            ]
          },
          le(
            te ? "span" : "button",
            {
              class: ["page-link", { "flex-grow-1": !te && C }],
              "aria-label": ge,
              "aria-controls": e.ariaControls || null,
              "aria-disabled": te ? "true" : null,
              role: "menuitem",
              type: te ? null : "button",
              tabindex: te ? null : "-1",
              onClick: (ne) => {
                te || g(ne, z);
              }
            },
            Y
          )
        );
      }, D = (J) => le(
        "li",
        {
          class: [
            "page-item",
            "disabled",
            "bv-d-xs-down-none",
            C ? "flex-fill" : "",
            e.ellipsisClass
          ],
          role: "separator",
          key: `ellipsis-${J ? "last" : "first"}`
        },
        [
          le(
            "span",
            { class: ["page-link"] },
            Pe(_u, {}, a) || e.ellipsisText || "..."
          )
        ]
      ), q = (J, ge) => {
        const ae = x(J.number) && !V, he = l.value ? null : ae || V && ge === 0 ? "0" : "-1", re = {
          active: ae,
          disabled: l.value,
          page: J.number,
          index: J.number - 1,
          content: J.number
        }, ue = Pe(Ou, re, a) || J.number, te = le(
          l.value ? "span" : "button",
          {
            class: ["page-link", { "flex-grow-1": !l.value && C }],
            "aria-controls": e.ariaControls || null,
            "aria-disabled": l.value ? "true" : null,
            "aria-label": e.labelPage ? `${e.labelPage} ${J.number}` : null,
            role: "menuitemradio",
            type: l.value ? null : "button",
            tabindex: he,
            onClick: (z) => {
              l.value || g(z, J.number);
            }
          },
          ue
        );
        return le(
          "li",
          {
            class: [
              "page-item",
              {
                disabled: l.value,
                active: ae,
                "flex-fill": C,
                "d-flex": C && !l.value
              },
              e.pageClass
            ],
            role: "presentation",
            key: `page-${J.number}`
          },
          te
        );
      };
      if (!d.value && !n.value) {
        const J = E(
          1,
          e.labelFirstPage,
          Tu,
          e.firstText,
          e.firstClass,
          1
        );
        O.push(J);
      }
      const G = E(
        e.modelValue - 1,
        e.labelFirstPage,
        xu,
        e.prevText,
        e.prevClass,
        1
      );
      O.push(G), n.value && _[0] !== 1 && O.push(q({ number: 1 }, 0)), A.value && O.push(D(!1)), P.value.forEach((J, ge) => {
        const ae = A.value && n.value && _[0] !== 1 ? 1 : 0;
        O.push(q(J, ge + ae));
      }), y.value && O.push(D(!0)), c.value && _[_.length - 1] !== p.value && O.push(q({ number: p.value }, -1));
      const se = E(
        e.modelValue + 1,
        e.labelNextPage,
        Au,
        e.nextText,
        e.nextClass,
        p.value
      );
      if (O.push(se), !c.value && !d.value) {
        const J = E(
          p.value,
          e.labelLastPage,
          Vu,
          e.lastText,
          e.lastClass,
          p.value
        );
        O.push(J);
      }
      return le(
        "ul",
        {
          class: ["pagination", $.value, S.value, F.value],
          role: "menubar",
          "aria-disabled": l.value,
          "aria-label": e.ariaLabel || null
        },
        O
      );
    };
  }
}), xe = /* @__PURE__ */ I({
  __name: "BPlaceholder",
  props: {
    tag: { default: "span" },
    width: null,
    cols: null,
    variant: null,
    size: null,
    animation: null
  },
  setup(e) {
    const t = e, a = i(
      () => t.width === void 0 ? void 0 : typeof t.width == "number" ? t.width.toString() : t.width.includes("%") ? t.width.replaceAll("%", "") : t.width
    ), l = i(
      () => t.cols === void 0 ? void 0 : typeof t.cols == "number" ? t.cols.toString() : t.cols
    ), n = i(() => ({
      [`col-${l.value}`]: l.value !== void 0 && a.value === void 0,
      [`bg-${t.variant}`]: t.variant !== void 0,
      [`placeholder-${t.size}`]: t.size !== void 0,
      [`placeholder-${t.animation}`]: t.animation !== void 0
    })), r = i(
      () => a.value === void 0 ? void 0 : `width: ${a.value}%;`
    );
    return (d, c) => (f(), N(Z(e.tag), {
      class: L(["placeholder", s(n)]),
      style: Fe(s(r))
    }, null, 8, ["class", "style"]));
  }
}), Bn = /* @__PURE__ */ I({
  __name: "BPlaceholderButton",
  props: {
    tag: { default: "div" },
    width: null,
    cols: null,
    variant: { default: "primary" },
    animation: null
  },
  setup(e) {
    const t = e, a = i(() => ["btn", `btn-${t.variant}`, "disabled"]), l = i(() => ({
      animation: t.animation,
      width: t.width,
      cols: t.cols,
      tag: t.tag
    }));
    return (n, r) => (f(), N(xe, Q({ class: s(a) }, s(l)), null, 16, ["class"]));
  }
}), Fu = /* @__PURE__ */ I({
  __name: "BPlaceholderCard",
  props: {
    noHeader: { default: !1 },
    headerWidth: { default: 100 },
    headerVariant: null,
    headerAnimation: null,
    headerSize: null,
    noFooter: { default: !1 },
    footerWidth: { default: 100 },
    footerVariant: null,
    footerAnimation: null,
    footerSize: null,
    animation: null,
    size: null,
    variant: null,
    noButton: { default: !1 },
    imgBottom: { default: !1 },
    imgSrc: null,
    imgBlankColor: { default: "#868e96" },
    imgHeight: { default: 100 },
    noImg: { default: !1 }
  },
  setup(e) {
    const t = e, a = u(o(t, "noButton")), l = u(o(t, "noHeader")), n = u(o(t, "noFooter")), r = u(o(t, "noImg")), d = i(() => ({
      width: t.headerWidth,
      variant: t.headerVariant,
      animation: t.headerAnimation,
      size: t.headerSize
    })), c = i(() => ({
      width: t.footerWidth,
      animation: t.footerAnimation,
      size: a.value ? t.footerSize : void 0,
      variant: t.footerVariant
    })), v = i(() => ({
      blank: !t.imgSrc,
      blankColor: t.imgBlankColor,
      height: t.imgSrc ? void 0 : t.imgHeight,
      src: t.imgSrc,
      top: !t.imgBottom,
      bottom: t.imgBottom
    }));
    return (m, S) => (f(), N(nn, { "img-bottom": e.imgBottom }, il({
      default: M(() => [
        B(m.$slots, "default", {}, () => [
          ve(xe, { cols: "7" }),
          ve(xe, { cols: "4" }),
          ve(xe, { cols: "4" }),
          ve(xe, { cols: "6" }),
          ve(xe, { cols: "8" })
        ])
      ]),
      _: 2
    }, [
      s(r) ? void 0 : {
        name: "img",
        fn: M(() => [
          B(m.$slots, "img", {}, () => [
            ve(_t, Be(_e(s(v))), null, 16)
          ])
        ]),
        key: "0"
      },
      s(l) ? void 0 : {
        name: "header",
        fn: M(() => [
          B(m.$slots, "header", {}, () => [
            ve(xe, Be(_e(s(d))), null, 16)
          ])
        ]),
        key: "1"
      },
      s(n) ? void 0 : {
        name: "footer",
        fn: M(() => [
          B(m.$slots, "footer", {}, () => [
            s(a) ? (f(), N(xe, Be(Q({ key: 1 }, s(c))), null, 16)) : (f(), N(Bn, Be(Q({ key: 0 }, s(c))), null, 16))
          ])
        ]),
        key: "2"
      }
    ]), 1032, ["img-bottom"]));
  }
}), It = /* @__PURE__ */ I({
  __name: "BTableSimple",
  props: {
    bordered: { default: !1 },
    borderless: { default: !1 },
    borderVariant: null,
    captionTop: { default: !1 },
    dark: { default: !1 },
    hover: { default: !1 },
    responsive: { type: [Boolean, String], default: !1 },
    stacked: { type: [Boolean, String], default: !1 },
    striped: { default: !1 },
    small: { default: !1 },
    tableClass: null,
    tableVariant: null,
    stickyHeader: { default: !1 }
  },
  setup(e) {
    const t = e, a = u(o(t, "captionTop")), l = u(o(t, "borderless")), n = u(o(t, "bordered")), r = u(o(t, "dark")), d = u(o(t, "hover")), c = u(o(t, "small")), v = u(o(t, "striped")), m = u(o(t, "stickyHeader")), S = i(() => [
      "table",
      "b-table",
      {
        "table-bordered": n.value,
        "table-borderless": l.value,
        [`border-${t.borderVariant}`]: t.borderVariant !== void 0,
        "caption-top": a.value,
        "table-dark": r.value,
        "table-hover": d.value,
        "b-table-stacked": typeof t.stacked == "boolean" && t.stacked,
        [`b-table-stacked-${t.stacked}`]: typeof t.stacked == "string",
        "table-striped": v.value,
        "table-sm": c.value,
        [`table-${t.tableVariant}`]: t.tableVariant !== void 0
      },
      t.tableClass
    ]), p = i(() => [
      {
        "table-responsive": t.responsive === !0,
        [`table-responsive-${t.responsive}`]: typeof t.responsive == "string",
        "b-table-sticky-header": m.value
      }
    ]);
    return (b, A) => e.responsive ? (f(), h("div", {
      key: 1,
      class: L(s(p))
    }, [
      j("table", {
        role: "table",
        class: L(s(S))
      }, [
        B(b.$slots, "default")
      ], 2)
    ], 2)) : (f(), h("table", {
      key: 0,
      role: "table",
      class: L(s(S))
    }, [
      B(b.$slots, "default")
    ], 2));
  }
}), Eu = /* @__PURE__ */ I({
  __name: "BPlaceholderTable",
  props: {
    rows: { default: 3 },
    columns: { default: 5 },
    cellWidth: { default: 100 },
    size: null,
    animation: null,
    variant: null,
    headerColumns: null,
    hideHeader: { default: !1 },
    headerCellWidth: { default: 100 },
    headerSize: null,
    headerAnimation: null,
    headerVariant: null,
    footerColumns: null,
    showFooter: { default: !1 },
    footerCellWidth: { default: 100 },
    footerSize: null,
    footerAnimation: null,
    footerVariant: null
  },
  setup(e) {
    const t = e, a = i(
      () => typeof t.columns == "string" ? ot(t.columns, 5) : t.columns
    ), l = i(
      () => typeof t.rows == "string" ? ot(t.rows, 3) : t.rows
    ), n = i(
      () => t.headerColumns === void 0 ? a.value : typeof t.headerColumns == "string" ? ot(t.headerColumns, a.value) : t.headerColumns
    ), r = i(
      () => t.footerColumns === void 0 ? a.value : typeof t.footerColumns == "string" ? ot(t.footerColumns, a.value) : t.footerColumns
    ), d = i(() => ({
      size: t.size,
      variant: t.variant,
      animation: t.animation,
      width: t.cellWidth
    })), c = i(() => ({
      size: t.headerSize,
      variant: t.headerVariant,
      animation: t.headerAnimation,
      width: t.headerCellWidth
    })), v = i(() => ({
      size: t.footerSize,
      variant: t.footerVariant,
      animation: t.footerAnimation,
      width: t.footerCellWidth
    })), m = u(o(t, "hideHeader")), S = u(o(t, "showFooter"));
    return (p, b) => (f(), N(It, null, {
      default: M(() => [
        s(m) ? X("", !0) : B(p.$slots, "thead", { key: 0 }, () => [
          j("thead", null, [
            j("tr", null, [
              (f(!0), h(ie, null, me(s(n), (A, w) => (f(), h("th", { key: w }, [
                ve(xe, Be(_e(s(c))), null, 16)
              ]))), 128))
            ])
          ])
        ]),
        B(p.$slots, "default", {}, () => [
          j("tbody", null, [
            (f(!0), h(ie, null, me(s(l), (A, w) => (f(), h("tr", { key: w }, [
              (f(!0), h(ie, null, me(s(a), (y, k) => (f(), h("td", { key: k }, [
                ve(xe, Be(_e(s(d))), null, 16)
              ]))), 128))
            ]))), 128))
          ])
        ]),
        s(S) ? B(p.$slots, "tfoot", { key: 1 }, () => [
          j("tfoot", null, [
            j("tr", null, [
              (f(!0), h(ie, null, me(s(r), (A, w) => (f(), h("th", { key: w }, [
                ve(xe, Be(_e(s(v))), null, 16)
              ]))), 128))
            ])
          ])
        ]) : X("", !0)
      ]),
      _: 3
    }));
  }
}), Lu = /* @__PURE__ */ I({
  __name: "BPlaceholderWrapper",
  props: {
    loading: { default: !1 }
  },
  setup(e) {
    const a = u(o(e, "loading"));
    return (l, n) => s(a) ? B(l.$slots, "loading", { key: 0 }) : B(l.$slots, "default", { key: 1 });
  }
}), zu = I({
  props: {
    container: {
      type: [String, Object],
      default: "body"
    },
    content: { type: String },
    id: { type: String },
    customClass: { type: String, default: "" },
    noninteractive: { type: [Boolean, String], default: !1 },
    placement: { type: String, default: "right" },
    target: {
      type: [String, Object],
      default: void 0
    },
    title: { type: String },
    delay: { type: [Number, Object], default: 0 },
    triggers: { type: String, default: "click" },
    show: { type: [Boolean, String], default: !1 },
    variant: { type: String, default: void 0 },
    html: { type: [Boolean, String], default: !0 },
    sanitize: { type: [Boolean, String], default: !1 },
    offset: { type: String, default: "0" }
  },
  emits: ["show", "shown", "hide", "hidden", "inserted"],
  setup(e, { emit: t, slots: a }) {
    u(o(e, "noninteractive"));
    const l = u(o(e, "show")), n = u(o(e, "html")), r = u(o(e, "sanitize")), d = K(), c = K(), v = K(), m = K(), S = K(), p = i(() => ({
      [`b-popover-${e.variant}`]: e.variant !== void 0
    })), b = ($) => {
      if (typeof $ == "string")
        return $;
      if ($ instanceof HTMLElement)
        return $;
      if (typeof $ < "u")
        return $.$el;
    }, A = ($) => {
      if (!!$) {
        if (typeof $ == "string") {
          const F = document.getElementById($);
          return F || void 0;
        }
        return $;
      }
    }, w = [
      { event: "show.bs.popover", handler: () => t("show") },
      { event: "shown.bs.popover", handler: () => t("shown") },
      { event: "hide.bs.popover", handler: () => t("hide") },
      { event: "hidden.bs.popover", handler: () => t("hidden") },
      { event: "inserted.bs.popover", handler: () => t("inserted") }
    ], y = ($) => {
      for (const F of w)
        $.addEventListener(F.event, F.handler);
    }, k = ($) => {
      for (const F of w)
        $.removeEventListener(F.event, F.handler);
    }, g = ($) => {
      c.value = A(b($)), c.value && (y(c.value), v.value = new Mt(c.value, {
        customClass: e.customClass,
        container: b(e.container),
        trigger: e.triggers,
        placement: e.placement,
        title: e.title || a.title ? m.value : "",
        content: S.value,
        html: n.value,
        delay: e.delay,
        sanitize: r.value,
        offset: e.offset
      }));
    };
    return ce(
      () => e.target,
      ($) => {
        var F;
        (F = v.value) == null || F.dispose(), c.value instanceof HTMLElement && k(c.value), g($);
      }
    ), ce(l, ($, F) => {
      var P, O;
      $ !== F && ($ ? (P = v.value) == null || P.show() : (O = v.value) == null || O.hide());
    }), ke(() => {
      var $, F, P;
      Ie(() => {
        g(e.target);
      }), (F = ($ = d.value) == null ? void 0 : $.parentNode) == null || F.removeChild(d.value), l.value && ((P = v.value) == null || P.show());
    }), ta(() => {
      var $;
      ($ = v.value) == null || $.dispose(), c.value instanceof HTMLElement && k(c.value);
    }), {
      element: d,
      titleRef: m,
      contentRef: S,
      computedClasses: p
    };
  }
}), Nu = ["id"], Du = { ref: "titleRef" }, Hu = { ref: "contentRef" };
function Mu(e, t, a, l, n, r) {
  return f(), h("div", {
    id: e.id,
    ref: "element",
    class: L(["popover b-popover", e.computedClasses]),
    role: "tooltip",
    tabindex: "-1"
  }, [
    j("div", Du, [
      B(e.$slots, "title", {}, () => [
        ee(W(e.title), 1)
      ])
    ], 512),
    j("div", Hu, [
      B(e.$slots, "default", {}, () => [
        ee(W(e.content), 1)
      ])
    ], 512)
  ], 10, Nu);
}
const Ru = /* @__PURE__ */ Te(zu, [["render", Mu]]), ju = ["aria-valuenow", "aria-valuemax"], $n = /* @__PURE__ */ I({
  __name: "BProgressBar",
  props: {
    animated: { default: !1 },
    label: null,
    labelHtml: null,
    max: null,
    precision: { default: 0 },
    showProgress: { default: !1 },
    showValue: { default: !1 },
    striped: { default: !1 },
    value: { default: 0 },
    variant: null
  },
  setup(e) {
    const t = e, a = He(_l), l = u(o(t, "animated")), n = u(o(t, "showProgress")), r = u(o(t, "showValue")), d = u(o(t, "striped")), c = i(() => ({
      "progress-bar-animated": l.value || (a == null ? void 0 : a.animated),
      "progress-bar-striped": d.value || (a == null ? void 0 : a.striped) || l.value || (a == null ? void 0 : a.animated),
      [`bg-${t.variant}`]: t.variant !== void 0
    })), v = i(
      () => typeof t.precision == "number" ? t.precision : Number.parseFloat(t.precision)
    ), m = i(
      () => typeof t.value == "number" ? t.value : Number.parseFloat(t.value)
    ), S = i(
      () => typeof t.max == "number" ? t.max : t.max === void 0 ? void 0 : Number.parseFloat(t.max)
    ), p = i(
      () => t.labelHtml !== void 0 ? t.labelHtml : r.value || (a == null ? void 0 : a.showValue) ? m.value.toFixed(v.value) : n.value || (a == null ? void 0 : a.showProgress) ? (m.value * 100 / (S.value || 100)).toFixed(v.value) : t.label !== void 0 ? t.label : ""
    ), b = i(
      () => a != null && a.max ? `${m.value * 100 / (typeof a.max == "number" ? a.max : Number.parseInt(a.max))}%` : t.max ? `${m.value * 100 / (typeof t.max == "number" ? t.max : Number.parseInt(t.max))}%` : typeof t.value == "string" ? t.value : `${t.value}%`
    );
    return (A, w) => (f(), h("div", {
      class: L(["progress-bar", s(c)]),
      role: "progressbar",
      "aria-valuenow": e.value,
      "aria-valuemin": "0",
      "aria-valuemax": e.max,
      style: Fe({ width: s(b) })
    }, [
      B(A.$slots, "default", {}, () => [
        ee(W(s(p)), 1)
      ])
    ], 14, ju));
  }
}), qu = /* @__PURE__ */ I({
  __name: "BProgress",
  props: {
    variant: null,
    max: null,
    height: null,
    animated: { default: !1 },
    precision: { default: 0 },
    showProgress: { default: !1 },
    showValue: { default: !1 },
    striped: { default: !1 },
    value: { default: 0 }
  },
  setup(e) {
    const t = e, a = u(o(t, "animated")), l = u(o(t, "showProgress")), n = u(o(t, "showValue")), r = u(o(t, "striped")), d = i(() => ({
      animated: t.animated,
      max: t.max,
      precision: t.precision,
      showProgress: t.showProgress,
      showValue: t.showValue,
      striped: t.striped,
      value: t.value,
      variant: t.variant
    }));
    return at(_l, {
      animated: a.value,
      max: t.max,
      showProgress: l.value,
      showValue: n.value,
      striped: r.value
    }), (c, v) => (f(), h("div", {
      class: "progress",
      style: Fe({ height: e.height })
    }, [
      B(c.$slots, "default", {}, () => [
        ve($n, Be(_e(s(d))), null, 16)
      ])
    ], 4));
  }
}), Ga = At("cols", [""], { type: [String, Number], default: null }), Gu = I({
  name: "BRow",
  props: {
    tag: { type: String, default: "div" },
    gutterX: { type: String, default: null },
    gutterY: { type: String, default: null },
    noGutters: { type: [Boolean, String], default: !1 },
    alignV: { type: String, default: null },
    alignH: { type: String, default: null },
    alignContent: { type: String, default: null },
    ...Ga
  },
  setup(e) {
    const t = u(o(e, "noGutters")), a = dt(o(e, "alignH")), l = i(() => kl(e, Ga, "cols", "row-cols"));
    return {
      computedClasses: i(() => [
        l.value,
        {
          [`gx-${e.gutterX}`]: e.gutterX !== null,
          [`gy-${e.gutterY}`]: e.gutterY !== null,
          "g-0": t.value,
          [`align-items-${e.alignV}`]: e.alignV !== null,
          [a.value]: e.alignH !== null,
          [`align-content-${e.alignContent}`]: e.alignContent !== null
        }
      ])
    };
  }
});
function Uu(e, t, a, l, n, r) {
  return f(), N(Z(e.tag), {
    class: L(["row", e.computedClasses])
  }, {
    default: M(() => [
      B(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
const Wu = /* @__PURE__ */ Te(Gu, [["render", Uu]]), ht = /* @__PURE__ */ I({
  __name: "BSkeleton",
  props: {
    height: null,
    width: null,
    size: null,
    animation: { default: "wave" },
    type: { default: "text" },
    variant: null
  },
  setup(e) {
    const t = e, a = i(() => [
      `b-skeleton-${t.type}`,
      {
        [`b-skeleton-animate-${t.animation}`]: typeof t.animation == "boolean" ? !1 : t.animation,
        [`bg-${t.variant}`]: t.variant !== void 0
      }
    ]), l = i(() => ({
      width: t.size || t.width,
      height: t.size || t.height
    }));
    return (n, r) => (f(), h("div", {
      class: L(["b-skeleton", s(a)]),
      style: Fe(s(l))
    }, null, 6));
  }
}), Ku = /* @__PURE__ */ I({
  __name: "BSkeletonIcon",
  props: {
    animation: { default: "wave" }
  },
  setup(e) {
    const t = e, a = i(() => [`b-skeleton-animate-${t.animation}`]);
    return (l, n) => (f(), h("div", {
      class: L(["b-skeleton-icon-wrapper position-relative d-inline-block overflow-hidden", s(a)])
    }, [
      B(l.$slots, "default")
    ], 2));
  }
}), Xu = { key: 0 }, Ju = { key: 1 }, Qu = /* @__PURE__ */ I({
  __name: "BSkeletonTable",
  props: {
    animation: { default: "wave" },
    columns: { default: 5 },
    hideHeader: { default: !1 },
    rows: { default: 3 },
    showFooter: { default: !1 },
    tableProps: null
  },
  setup(e) {
    const t = e, a = u(o(t, "hideHeader")), l = u(o(t, "showFooter"));
    return (n, r) => (f(), N(It, Be(_e(e.tableProps)), {
      default: M(() => [
        s(a) ? X("", !0) : (f(), h("thead", Xu, [
          j("tr", null, [
            (f(!0), h(ie, null, me(e.columns, (d, c) => (f(), h("th", { key: c }, [
              ve(ht)
            ]))), 128))
          ])
        ])),
        j("tbody", null, [
          (f(!0), h(ie, null, me(e.rows, (d, c) => (f(), h("tr", { key: c }, [
            (f(!0), h(ie, null, me(e.columns, (v, m) => (f(), h("td", { key: m }, [
              ve(ht, { width: "75%" })
            ]))), 128))
          ]))), 128))
        ]),
        s(l) ? (f(), h("tfoot", Ju, [
          j("tr", null, [
            (f(!0), h(ie, null, me(e.columns, (d, c) => (f(), h("th", { key: c }, [
              ve(ht)
            ]))), 128))
          ])
        ])) : X("", !0)
      ]),
      _: 1
    }, 16));
  }
}), Yu = /* @__PURE__ */ I({
  __name: "BSkeletonWrapper",
  props: {
    loading: { default: !1 }
  },
  setup(e) {
    const a = u(o(e, "loading"));
    return (l, n) => s(a) ? B(l.$slots, "loading", { key: 0 }) : B(l.$slots, "default", { key: 1 });
  }
}), Ua = [
  "ar",
  "az",
  "ckb",
  "fa",
  "he",
  "ks",
  "lrc",
  "mzn",
  "ps",
  "sd",
  "te",
  "ug",
  "ur",
  "yi"
].map((e) => e.toLowerCase()), Zu = (e) => {
  const t = Bt(e).toLowerCase().replace(qn, "").split("-"), a = t.slice(0, 2).join("-"), l = t[0];
  return Ua.includes(a) || Ua.includes(l);
}, ed = (e) => Jn ? Rt(e) ? e : { capture: !!e || !1 } : !!(Rt(e) ? e.capture : e), td = (e, t, a, l) => {
  e && e.addEventListener && e.addEventListener(t, a, ed(l));
}, ad = (e, t, a, l) => {
  e && e.removeEventListener && e.removeEventListener(t, a, l);
}, Wa = (e, t) => {
  (e ? td : ad)(...t);
}, vt = (e, { preventDefault: t = !0, propagation: a = !0, immediatePropagation: l = !1 } = {}) => {
  t && e.preventDefault(), a && e.stopPropagation(), l && e.stopImmediatePropagation();
}, Zt = "ArrowDown", kn = "End", Sn = "Home", Cn = "PageDown", wn = "PageUp", ea = "ArrowUp", Ka = 1, Xa = 100, Ja = 1, Qa = 500, Ya = 100, Za = 10, el = 4, tl = [ea, Zt, Sn, kn, wn, Cn], ld = I({
  props: {
    ariaControls: { type: String, required: !1 },
    ariaLabel: { type: String, required: !1 },
    labelIncrement: { type: String, default: "Increment" },
    labelDecrement: { type: String, default: "Decrement" },
    modelValue: { type: Number, default: null },
    name: { type: String, default: "BFormSpinbutton" },
    disabled: { type: [Boolean, String], default: !1 },
    placeholder: { type: String, required: !1 },
    locale: { type: String, default: "locale" },
    form: { type: String, required: !1 },
    inline: { type: Boolean, default: !1 },
    size: { type: String, required: !1 },
    formatterFn: {
      type: Function
    },
    readonly: { type: Boolean, default: !1 },
    vertical: { type: Boolean, default: !1 },
    repeatDelay: {
      type: [String, Number],
      default: Qa
    },
    repeatInterval: {
      type: [String, Number],
      default: Ya
    },
    repeatStepMultiplier: {
      type: [String, Number],
      default: el
    },
    repeatThreshold: {
      type: [String, Number],
      default: Za
    },
    required: { type: [Boolean, String], default: !1 },
    step: { type: [String, Number], default: Ja },
    min: { type: [String, Number], default: Ka },
    max: { type: [String, Number], default: Xa },
    wrap: { type: Boolean, default: !1 },
    state: { type: [Boolean, String], default: null }
  },
  emits: ["update:modelValue", "change"],
  setup(e, { emit: t }) {
    const a = K(!1), l = i(() => 1), n = () => {
      t("change", d.value);
    }, r = K(null), d = i({
      get() {
        return ze(e.modelValue) ? r.value : e.modelValue;
      },
      set(z) {
        ze(e.modelValue) ? r.value = z : t("update:modelValue", z);
      }
    });
    let c, v, m = !1;
    const S = i(() => rt(e.step, Ja)), p = i(() => rt(e.min, Ka)), b = i(() => {
      const z = rt(e.max, Xa), H = S.value, Y = p.value;
      return Math.floor((z - Y) / H) * H + Y;
    }), A = i(() => {
      const z = je(e.repeatDelay, 0);
      return z > 0 ? z : Qa;
    }), w = i(() => {
      const z = je(e.repeatInterval, 0);
      return z > 0 ? z : Ya;
    }), y = i(
      () => Math.max(je(e.repeatThreshold, Za), 1)
    ), k = i(
      () => Math.max(je(e.repeatStepMultiplier, el), 1)
    ), g = i(() => {
      const z = S.value;
      return Math.floor(z) === z ? 0 : (z.toString().split(".")[1] || "").length;
    }), $ = i(() => Math.pow(10, g.value || 0)), F = i(() => {
      const { value: z } = d;
      return z === null ? "" : z.toFixed(g.value);
    }), P = i(() => {
      const z = [e.locale];
      return new Intl.NumberFormat(z).resolvedOptions().locale;
    }), O = i(
      () => Zu(P.value)
    ), _ = () => {
      const z = g.value;
      return new Intl.NumberFormat(P.value, {
        style: "decimal",
        useGrouping: !1,
        minimumIntegerDigits: 1,
        minimumFractionDigits: z,
        maximumFractionDigits: z,
        notation: "standard"
      }).format;
    }, x = i(
      () => e.formatterFn ? e.formatterFn : _()
    ), V = i(() => ({
      role: "group",
      lang: P.value,
      tabindex: e.disabled ? null : "-1",
      title: e.ariaLabel
    })), C = i(() => !ze(e.modelValue) || !ze(r.value)), E = i(() => ({
      dir: O.value,
      spinId: l.value,
      tabindex: e.disabled ? null : "0",
      role: "spinbutton",
      "aria-live": "off",
      "aria-label": e.ariaLabel || null,
      "aria-controls": e.ariaControls || null,
      "aria-invalid": e.state === !1 || !C.value && e.required ? "true" : null,
      "aria-required": e.required ? "true" : null,
      "aria-valuemin": p.value,
      "aria-valuemax": b.value,
      "aria-valuenow": ze(d.value) ? null : d.value,
      "aria-valuetext": ze(d.value) ? null : x.value(d.value)
    })), D = (z) => {
      let { value: H } = d;
      if (!e.disabled && !ze(H)) {
        const Y = S.value * z, ne = p.value, ye = b.value, oe = $.value, { wrap: de } = e;
        H = Math.round((H - ne) / Y) * Y + ne + Y, H = Math.round(H * oe) / oe, d.value = H > ye ? de ? ne : ye : H < ne ? de ? ye : ne : H;
      }
    }, q = (z = 1) => {
      ze(d.value) ? d.value = p.value : D(1 * z);
    }, G = (z = 1) => {
      ze(d.value) ? d.value = e.wrap ? b.value : p.value : D(-1 * z);
    }, se = (z) => {
      const { code: H, altKey: Y, ctrlKey: ne, metaKey: ye } = z;
      if (!(e.disabled || e.readonly || Y || ne || ye) && tl.includes(H)) {
        if (vt(z, { propagation: !1 }), m)
          return;
        ue(), [ea, Zt].includes(H) ? (m = !0, H === ea ? ge(z, q) : H === Zt && ge(z, G)) : H === wn ? q(k.value) : H === Cn ? G(k.value) : H === Sn ? d.value = p.value : H === kn && (d.value = b.value);
      }
    }, J = (z) => {
      const { code: H, altKey: Y, ctrlKey: ne, metaKey: ye } = z;
      e.disabled || e.readonly || Y || ne || ye || tl.includes(H) && (vt(z, { propagation: !1 }), ue(), m = !1, n());
    }, ge = (z, H) => {
      const { type: Y } = z || {};
      if (!e.disabled && !e.readonly) {
        if (ae(z) && Y === "mousedown" && z.button)
          return;
        ue(), H(1);
        const ne = y.value, ye = k.value, oe = A.value, de = w.value;
        c = setTimeout(() => {
          let Ae = 0;
          v = setInterval(() => {
            H(Ae < ne ? 1 : ye), Ae++;
          }, de);
        }, oe);
      }
    };
    function ae(z) {
      return z.type === "mouseup" || z.type === "mousedown";
    }
    const he = (z) => {
      ae(z) && z.type === "mouseup" && z.button || (vt(z, { propagation: !1 }), ue(), re(!1), n());
    }, re = (z) => {
      try {
        Wa(z, [document.body, "mouseup", he, !1]), Wa(z, [document.body, "touchend", he, !1]);
      } catch {
        return 0;
      }
    }, ue = () => {
      clearTimeout(c), clearInterval(v), c = void 0, v = void 0;
    }, te = (z, H, Y, ne, ye, oe, de) => {
      const Ae = le(Y, {
        props: { scale: a.value ? 1.5 : 1.25 },
        attrs: { "aria-hidden": "true" }
      }), Ft = { hasFocus: a.value }, ct = (Me) => {
        !e.disabled && !e.readonly && (vt(Me, { propagation: !1 }), re(!0), ge(Me, z));
      };
      return le(
        "button",
        {
          class: [{ "py-0": !e.vertical }, "btn", "btn-sm", "border-0", "rounded-0"],
          tabindex: "-1",
          type: "button",
          disabled: e.disabled || e.readonly || oe,
          "aria-disabled": e.disabled || e.readonly || oe ? "true" : null,
          "aria-controls": l.value,
          "aria-label": H || null,
          "aria-keyshortcuts": ye || null,
          onmousedown: ct,
          ontouchstart: ct
        },
        [Pe(de, Ft) || Ae]
      );
    };
    return () => {
      const z = te(
        q,
        e.labelIncrement,
        le(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            width: "16",
            height: "16",
            fill: "currentColor",
            class: "bi bi-plus",
            viewBox: "0 0 16 16"
          },
          le("path", {
            d: "M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"
          })
        ),
        "inc",
        "ArrowUp",
        !1,
        "increment"
      ), H = te(
        G,
        e.labelDecrement,
        le(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            width: "16",
            height: "16",
            fill: "currentColor",
            class: "bi bi-dash",
            viewBox: "0 0 16 16"
          },
          le("path", { d: "M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z" })
        ),
        "dec",
        "ArrowDown",
        !1,
        "decrement"
      ), Y = [];
      e.name && !e.disabled && Y.push(
        le("input", {
          type: "hidden",
          name: e.name,
          form: e.form || null,
          value: F.value,
          key: "hidden"
        })
      );
      const ne = le(
        "output",
        {
          class: [
            { "d-flex": e.vertical },
            { "align-self-center": !e.vertical },
            { "align-items-center": e.vertical },
            { "border-top": e.vertical },
            { "border-bottom": e.vertical },
            { "border-start": !e.vertical },
            { "border-end": !e.vertical },
            "flex-grow-1"
          ],
          ...E.value,
          key: "output"
        },
        [
          le(
            "bdi",
            C.value ? x.value(d.value) : e.placeholder || ""
          )
        ]
      );
      return le(
        "div",
        {
          class: [
            "b-form-spinbutton form-control",
            { disabled: e.disabled },
            { readonly: e.readonly },
            { focus: a },
            { "d-inline-flex": e.inline || e.vertical },
            { "d-flex": !e.inline && !e.vertical },
            { "align-items-stretch": !e.vertical },
            { "flex-column": e.vertical },
            e.size ? `form-control-${e.size}` : null
          ],
          ...V.value,
          onkeydown: se,
          onkeyup: J
        },
        e.vertical ? [z, Y, ne, H] : [H, Y, ne, z]
      );
    };
  }
}), nd = ["TD", "TH", "TR"], od = [
  "a",
  "a *",
  "button",
  "button *",
  "input:not(.disabled):not([disabled])",
  "select:not(.disabled):not([disabled])",
  "textarea:not(.disabled):not([disabled])",
  '[role="link"]',
  '[role="link"] *',
  '[role="button"]',
  '[role="button"] *',
  "[tabindex]:not(.disabled):not([disabled])"
].join(","), mt = (e) => {
  if (!e || !e.target)
    return !1;
  const t = e.target;
  if ("disabled" in t && t.disabled || nd.indexOf(t.tagName) !== -1)
    return !1;
  if (ba(".dropdown-menu", t))
    return !0;
  const a = t.tagName === "LABEL" ? t : ba("label", t);
  if (a) {
    const l = sa(a, "for"), n = l ? oo(l) : Bl("input, select, textarea", a);
    if (n && !n.disabled)
      return !0;
  }
  return $l(t, od);
}, sd = () => {
  const e = (m, S) => {
    const p = [];
    return !(m != null && m.length) && (S == null ? void 0 : S.length) ? (Object.keys(S[0]).forEach((b) => p.push({ key: b, label: va(b) })), p) : (Array.isArray(m) && m.forEach((b) => {
      typeof b == "string" ? p.push({ key: b, label: va(b) }) : Rt(b) && b.key && typeof b.key == "string" && p.push({ ...b });
    }), p);
  }, t = K([]), a = (m, S, p, b) => (t.value = $t(S), "isFilterableTable" in b && b.isFilterableTable.value === !0 && p.filter && (t.value = r(t.value, p.filter, p.filterable)), "isSortable" in b && b.isSortable.value === !0 && (t.value = n(
    m,
    t.value,
    {
      key: p.sortBy,
      desc: b.sortDescBoolean.value
    },
    p.sortCompare
  )), t.value), l = K(void 0), n = (m, S, p, b) => {
    if (!p || !p.key)
      return S;
    const A = p.key;
    return S.sort((w, y) => {
      if (b !== void 0)
        return b(w, y, p.key, p.desc);
      const k = (F) => typeof F == "object" ? JSON.stringify(F) : F;
      return k(w[A]) > k(y[A]) ? p.desc ? -1 : 1 : k(y[A]) > k(w[A]) ? p.desc ? 1 : -1 : 0;
    });
  }, r = (m, S, p) => m.filter(
    (b) => Object.entries(b).filter((A) => {
      const [w, y] = A;
      return !y || w[0] === "_" || p.length > 0 && !p.includes(w) ? !1 : (typeof y == "object" ? JSON.stringify(Object.values(y)) : typeof y == "string" ? y : y.toString()).toLowerCase().includes(S.toLowerCase());
    }).length > 0
  );
  return {
    normaliseFields: e,
    mapItems: a,
    internalItems: t,
    updateInternalItems: async (m) => {
      try {
        return t.value = await qt(m), t.value;
      } catch {
        return;
      }
    },
    filterEvent: l,
    notifyFilteredItems: () => {
      l.value && l.value(t.value);
    },
    formatItem: (m, S) => {
      const p = m[S.key];
      return S.formatter && typeof S.formatter == "function" ? S.formatter(p, S.key, m) : m[S.key];
    }
  };
}, rd = ["title", "abbr", "onClick"], id = { class: "d-inline-flex flex-nowrap align-items-center gap-1" }, ud = { key: 1 }, dd = ["onClick", "onDblclick", "onMouseenter", "onMouseleave"], cd = {
  key: 0,
  class: "b-table-stacked-label"
}, fd = ["colspan"], vd = ["colspan"], md = { class: "d-flex align-items-center justify-content-center gap-2" }, pd = /* @__PURE__ */ j("strong", null, "Loading...", -1), bd = {
  key: 1,
  class: "b-table-empty-slot"
}, gd = ["colspan"], hd = { key: 0 }, yd = ["title", "abbr", "onClick"], Bd = { key: 1 }, $d = { key: 2 }, kd = { key: 3 }, Sd = /* @__PURE__ */ I({
  __name: "BTable",
  props: {
    align: null,
    caption: null,
    captionTop: { default: !1 },
    borderless: { default: !1 },
    bordered: { default: !1 },
    borderVariant: null,
    dark: { default: !1 },
    fields: { default: () => [] },
    footClone: { default: !1 },
    hover: { default: !1 },
    items: { default: () => [] },
    provider: null,
    sortCompare: null,
    noProvider: null,
    noProviderPaging: null,
    noProviderSorting: null,
    noProviderFiltering: null,
    responsive: { type: [Boolean, String], default: !1 },
    small: { default: !1 },
    striped: { default: !1 },
    stacked: { type: [Boolean, String], default: !1 },
    labelStacked: { type: Boolean, default: !1 },
    variant: null,
    sortBy: null,
    sortDesc: { default: !1 },
    sortInternal: { default: !0 },
    selectable: { default: !1 },
    stickySelect: { default: !1 },
    selectHead: { type: [Boolean, String], default: !0 },
    selectMode: { default: "single" },
    selectionVariant: { default: "primary" },
    stickyHeader: { default: !1 },
    busy: { default: !1 },
    showEmpty: { default: !1 },
    perPage: null,
    currentPage: { default: 1 },
    filter: null,
    filterable: null,
    emptyText: { default: "There are no records to show" },
    emptyFilteredText: { default: "There are no records matching your request" }
  },
  emits: ["headClicked", "rowClicked", "rowDblClicked", "rowHovered", "rowUnhovered", "rowSelected", "rowUnselected", "selection", "update:busy", "update:sortBy", "update:sortDesc", "sorted", "filtered"],
  setup(e, { expose: t, emit: a }) {
    const l = e, n = Se(), r = sd(), d = u(o(l, "footClone")), c = u(o(l, "sortDesc")), v = u(o(l, "sortInternal")), m = u(o(l, "selectable")), S = u(o(l, "stickySelect")), p = u(o(l, "labelStacked")), b = u(o(l, "busy")), A = u(o(l, "showEmpty")), w = u(o(l, "noProviderPaging")), y = u(o(l, "noProviderSorting")), k = u(o(l, "noProviderFiltering")), g = K(b.value);
    r.filterEvent.value = async (T) => {
      if (C.value) {
        await H();
        return;
      }
      const U = await qt(T);
      a("filtered", U);
    };
    const $ = K(/* @__PURE__ */ new Set([])), F = i(() => $.value.size > 0), P = i(() => ({
      [`align-${l.align}`]: l.align !== void 0,
      "b-table-selectable": m.value,
      [`b-table-select-${l.selectMode}`]: m.value,
      "b-table-selecting user-select-none": m.value && F.value,
      "b-table-busy": g.value,
      "b-table-sortable": D.value,
      "b-table-sort-desc": D.value && c.value === !0,
      "b-table-sort-asc": D.value && c.value === !1
    })), O = i(() => ({
      bordered: l.bordered,
      borderless: l.borderless,
      borderVariant: l.borderVariant,
      captionTop: l.captionTop,
      dark: l.dark,
      hover: l.hover,
      responsive: l.responsive,
      striped: l.striped,
      stacked: l.stacked,
      small: l.small,
      tableClass: P.value,
      tableVariant: l.variant,
      stickyHeader: l.stickyHeader
    })), _ = i(() => r.normaliseFields(l.fields, l.items)), x = i(
      () => _.value.length + (m.value ? 1 : 0)
    ), V = i(() => l.filter !== void 0 && l.filter !== ""), C = i(() => l.provider !== void 0), E = i(
      () => m.value && (!!l.selectHead || n.selectHead !== void 0)
    ), D = i(
      () => l.fields.filter((T) => typeof T == "string" ? !1 : T.sortable).length > 0
    ), q = i(() => D.value && v.value === !0), G = i(() => {
      const T = C.value ? r.internalItems.value : q.value ? r.mapItems(l.fields, l.items, l, {
        isSortable: D,
        isFilterableTable: V,
        sortDescBoolean: c
      }) : l.items;
      if (l.perPage !== void 0) {
        const U = (l.currentPage - 1) * l.perPage;
        return T.splice(U, l.perPage);
      }
      return T;
    }), se = (T) => typeof T == "string" ? ma(T) : T.label !== void 0 ? T.label : typeof T.key == "string" ? ma(T.key) : T.key, J = (T, U, fe = !1) => {
      const R = typeof T == "string" ? T : T.key;
      a("headClicked", R, T, U, fe), ue(T);
    }, ge = (T, U, fe) => {
      a("rowClicked", T, U, fe), z(T, U, fe.shiftKey);
    }, ae = (T, U, fe) => a("rowDblClicked", T, U, fe), he = (T, U, fe) => a("rowHovered", T, U, fe), re = (T, U, fe) => a("rowUnhovered", T, U, fe), ue = (T) => {
      if (!D.value)
        return;
      const U = typeof T == "string" ? T : T.key, fe = typeof T == "string" ? !1 : T.sortable;
      if (D.value === !0 && fe === !0) {
        const R = !c.value;
        U !== l.sortBy && a("update:sortBy", U), a("update:sortDesc", R), a("sorted", U, R);
      }
    }, te = () => {
      !m.value || a("selection", Array.from($.value));
    }, z = (T, U, fe = !1) => {
      if (!!m.value) {
        if ($.value.has(T))
          $.value.delete(T), a("rowUnselected", T);
        else if (l.selectMode === "single" && $.value.size > 0 && ($.value.forEach((R) => a("rowUnselected", R)), $.value.clear()), l.selectMode === "range" && $.value.size > 0 && fe) {
          const R = Array.from($.value).pop(), Ce = G.value.findIndex((Ue) => Ue === R), pe = Math.min(Ce, U), Et = Math.max(Ce, U);
          G.value.slice(pe, Et + 1).forEach((Ue) => {
            $.value.has(Ue) || ($.value.add(Ue), a("rowSelected", Ue));
          });
        } else
          $.value.add(T), a("rowSelected", T);
        te();
      }
    }, H = async () => {
      if (!C.value || !l.provider || g.value)
        return;
      g.value = !0;
      const T = new Proxy(
        {
          currentPage: l.currentPage,
          filter: l.filter,
          sortBy: l.sortBy,
          sortDesc: l.sortDesc,
          perPage: l.perPage
        },
        {
          get(fe, R) {
            return R in fe ? fe[R] : void 0;
          },
          set() {
            return console.error("BTable provider context is a read-only object."), !0;
          }
        }
      ), U = l.provider(T, r.updateInternalItems);
      if (U !== void 0) {
        if (U instanceof Promise)
          try {
            const fe = await U;
            return Array.isArray(fe) ? await r.updateInternalItems(fe) : void 0;
          } finally {
            g.value && (g.value = !1);
          }
        try {
          return await r.updateInternalItems(U);
        } finally {
          g.value && (g.value = !1);
        }
      }
    }, Y = (T) => {
      T._showDetails = !T._showDetails;
    }, ne = (T) => [
      T.class,
      T.thClass,
      T.variant ? `table-${T.variant}` : void 0,
      {
        "b-table-sortable-column": D.value && T.sortable,
        "b-table-sticky-column": T.stickyColumn
      }
    ], ye = (T, U) => [
      T.class,
      T.tdClass,
      T.variant ? `table-${T.variant}` : void 0,
      (U == null ? void 0 : U._cellVariants) && (U == null ? void 0 : U._cellVariants[T.key]) ? `table-${U == null ? void 0 : U._cellVariants[T.key]}` : void 0,
      {
        "b-table-sticky-column": T.stickyColumn
      }
    ], oe = (T) => [
      T._rowVariant ? `table-${T._rowVariant}` : null,
      T._rowVariant ? `table-${T._rowVariant}` : null,
      m.value && $.value.has(T) ? `selected table-${l.selectionVariant}` : null
    ], de = () => {
      if (!m.value)
        return;
      const T = $.value.size > 0 ? Array.from($.value) : [];
      $.value = /* @__PURE__ */ new Set([...G.value]), $.value.forEach((U) => {
        T.includes(U) || a("rowSelected", U);
      }), te();
    }, Ae = () => {
      !m.value || ($.value.forEach((T) => {
        a("rowUnselected", T);
      }), $.value = /* @__PURE__ */ new Set([]), te());
    }, Ft = (T) => {
      if (!m.value)
        return;
      const U = G.value[T];
      !U || $.value.has(U) || ($.value.add(U), a("rowSelected", U), te());
    }, ct = (T) => {
      if (!m.value)
        return;
      const U = G.value[T];
      !U || !$.value.has(U) || ($.value.delete(U), a("rowUnselected", U), te());
    }, Me = async (T, U, fe) => {
      if (U === fe)
        return;
      const R = (_n) => l.noProvider && l.noProvider.includes(_n), Ce = !["currentPage", "perPage"].includes(T), pe = ["currentPage", "perPage"].includes(T) && (R("paging") || w.value === !0), Et = ["filter"].includes(T) && (R("filtering") || k.value === !0), Ue = ["sortBy", "sortDesc"].includes(T) && (R("sorting") || y.value === !0);
      pe || Et || Ue || (await H(), Ce && r.notifyFilteredItems());
    };
    return ce(
      () => l.filter,
      (T, U) => {
        T === U || C.value || T || qt(l.items).then((fe) => a("filtered", fe));
      }
    ), ce(
      g,
      () => g.value !== b.value && a("update:busy", g.value)
    ), ce(
      b,
      () => g.value !== b.value && (g.value = b.value)
    ), ce(
      () => l.filter,
      (T, U) => Me("filter", T, U)
    ), ce(
      () => l.currentPage,
      (T, U) => Me("currentPage", T, U)
    ), ce(
      () => l.perPage,
      (T, U) => Me("perPage", T, U)
    ), ce(
      () => l.sortBy,
      (T, U) => Me("sortBy", T, U)
    ), ce(
      () => l.sortDesc,
      (T, U) => Me("sortDesc", T, U)
    ), ke(() => {
      C.value && H();
    }), t({
      selectAllRows: de,
      clearSelected: Ae,
      selectRow: Ft,
      unselectRow: ct
    }), (T, U) => (f(), N(It, Be(_e(s(O))), {
      default: M(() => {
        var fe;
        return [
          j("thead", null, [
            T.$slots["thead-top"] ? B(T.$slots, "thead-top", { key: 0 }) : X("", !0),
            j("tr", null, [
              s(E) ? (f(), h("th", {
                key: 0,
                class: L(["b-table-selection-column", {
                  "b-table-sticky-column": s(S)
                }])
              }, [
                B(T.$slots, "select-head", {}, () => [
                  ee(W(typeof e.selectHead == "boolean" ? "Selected" : e.selectHead), 1)
                ])
              ], 2)) : X("", !0),
              (f(!0), h(ie, null, me(s(_), (R) => (f(), h("th", Q({
                key: R.key,
                scope: "col",
                class: ne(R),
                title: R.headerTitle,
                abbr: R.headerAbbr,
                style: R.thStyle
              }, R.thAttr, {
                onClick: (Ce) => J(R, Ce)
              }), [
                j("div", id, [
                  B(T.$slots, "sort-icon", {
                    field: R,
                    sortBy: e.sortBy,
                    selected: R.key === e.sortBy,
                    isDesc: s(c),
                    direction: s(c) ? "desc" : "asc"
                  }, () => [
                    s(D) && R.sortable ? (f(), h("span", {
                      key: 0,
                      class: L(["b-table-sort-icon", {
                        sorted: R.key === e.sortBy,
                        [`sorted-${s(c) ? "desc" : "asc"}`]: R.key === e.sortBy
                      }])
                    }, null, 2)) : X("", !0)
                  ]),
                  j("div", null, [
                    T.$slots["head(" + R.key + ")"] || T.$slots["head()"] ? B(T.$slots, T.$slots["head(" + R.key + ")"] ? "head(" + R.key + ")" : "head()", {
                      key: 0,
                      label: R.label
                    }) : (f(), h(ie, { key: 1 }, [
                      ee(W(se(R)), 1)
                    ], 64))
                  ])
                ])
              ], 16, rd))), 128))
            ]),
            T.$slots["thead-sub"] ? (f(), h("tr", ud, [
              (f(!0), h(ie, null, me(s(_), (R) => (f(), h("td", {
                key: R.key,
                scope: "col",
                class: L([R.class, R.thClass, R.variant ? `table-${R.variant}` : ""])
              }, [
                T.$slots["thead-sub"] ? B(T.$slots, "thead-sub", Q({
                  key: 0,
                  items: s(_)
                }, R)) : (f(), h(ie, { key: 1 }, [
                  ee(W(R.label), 1)
                ], 64))
              ], 2))), 128))
            ])) : X("", !0)
          ]),
          j("tbody", null, [
            (f(!0), h(ie, null, me(s(G), (R, Ce) => (f(), h(ie, { key: Ce }, [
              j("tr", {
                class: L(oe(R)),
                onClick: (pe) => !s(mt)(pe) && ge(R, Ce, pe),
                onDblclick: (pe) => !s(mt)(pe) && ae(R, Ce, pe),
                onMouseenter: (pe) => !s(mt)(pe) && he(R, Ce, pe),
                onMouseleave: (pe) => !s(mt)(pe) && re(R, Ce, pe)
              }, [
                s(E) ? (f(), h("td", {
                  key: 0,
                  class: L(["b-table-selection-column", {
                    "b-table-sticky-column": s(S)
                  }])
                }, [
                  B(T.$slots, "select-cell", {}, () => [
                    j("span", {
                      class: L($.value.has(R) ? "text-primary" : "")
                    }, "\u{1F5F9}", 2)
                  ])
                ], 2)) : X("", !0),
                (f(!0), h(ie, null, me(s(_), (pe) => (f(), h("td", Q({
                  key: pe.key
                }, pe.tdAttr, {
                  class: ye(pe, R)
                }), [
                  e.stacked && s(p) ? (f(), h("label", cd, W(se(pe)), 1)) : X("", !0),
                  T.$slots["cell(" + pe.key + ")"] || T.$slots["cell()"] ? B(T.$slots, T.$slots["cell(" + pe.key + ")"] ? "cell(" + pe.key + ")" : "cell()", {
                    key: 1,
                    value: R[pe.key],
                    index: Ce,
                    item: R,
                    field: pe,
                    items: e.items,
                    toggleDetails: () => Y(R),
                    detailsShowing: R._showDetails
                  }) : (f(), h(ie, { key: 2 }, [
                    ee(W(s(r).formatItem(R, pe)), 1)
                  ], 64))
                ], 16))), 128))
              ], 42, dd),
              R._showDetails === !0 && T.$slots["row-details"] ? (f(), h("tr", {
                key: 0,
                class: L(oe(R))
              }, [
                j("td", { colspan: s(x) }, [
                  B(T.$slots, "row-details", {
                    item: R,
                    toggleDetails: () => Y(R)
                  })
                ], 8, fd)
              ], 2)) : X("", !0)
            ], 64))), 128)),
            g.value ? (f(), h("tr", {
              key: 0,
              class: L(["b-table-busy-slot", { "b-table-static-busy": s(G).length === 0 }])
            }, [
              j("td", { colspan: s(x) }, [
                B(T.$slots, "table-busy", {}, () => [
                  j("div", md, [
                    ve(Pt, { class: "align-middle" }),
                    pd
                  ])
                ])
              ], 8, vd)
            ], 2)) : X("", !0),
            s(A) && s(G).length === 0 ? (f(), h("tr", bd, [
              j("td", { colspan: s(x) }, [
                B(T.$slots, "empty", {
                  items: s(G),
                  filtered: s(V)
                }, () => [
                  ee(W(s(V) ? e.emptyFilteredText : e.emptyText), 1)
                ])
              ], 8, gd)
            ])) : X("", !0)
          ]),
          s(d) ? (f(), h("tfoot", hd, [
            j("tr", null, [
              (f(!0), h(ie, null, me(s(_), (R) => (f(), h("th", Q({
                key: R.key
              }, R.thAttr, {
                scope: "col",
                class: [R.class, R.thClass, R.variant ? `table-${R.variant}` : ""],
                title: R.headerTitle,
                abbr: R.headerAbbr,
                style: R.thStyle,
                onClick: (Ce) => J(R, Ce, !0)
              }), W(R.label), 17, yd))), 128))
            ])
          ])) : T.$slots["custom-foot"] ? (f(), h("tfoot", Bd, [
            B(T.$slots, "custom-foot", {
              fields: s(_),
              items: e.items,
              columns: (fe = s(_)) == null ? void 0 : fe.length
            })
          ])) : X("", !0),
          T.$slots["table-caption"] ? (f(), h("caption", $d, [
            B(T.$slots, "table-caption")
          ])) : e.caption ? (f(), h("caption", kd, W(e.caption), 1)) : X("", !0)
        ];
      }),
      _: 3
    }, 16));
  }
}), Cd = /* @__PURE__ */ I({
  __name: "BTbody",
  props: {
    variant: null
  },
  setup(e) {
    const t = e, a = i(() => ({
      [`thead-${t.variant}`]: t.variant !== void 0
    }));
    return (l, n) => (f(), h("tbody", {
      role: "rowgroup",
      class: L(s(a))
    }, [
      B(l.$slots, "default")
    ], 2));
  }
}), wd = ["scope", "colspan", "rowspan", "data-label"], _d = { key: 0 }, Td = /* @__PURE__ */ I({
  __name: "BTd",
  props: {
    colspan: null,
    rowspan: null,
    stackedHeading: null,
    stickyColumn: { default: !1 },
    variant: null
  },
  setup(e) {
    const t = e, a = u(o(t, "stickyColumn")), l = i(() => ({
      [`table-${t.variant}`]: t.variant !== void 0,
      "b-table-sticky-column": a.value,
      "table-b-table-default": a.value && t.variant === void 0
    })), n = i(() => t.colspan ? "colspan" : t.rowspan ? "rowspan" : "col");
    return (r, d) => (f(), h("td", {
      role: "cell",
      scope: s(n),
      class: L(s(l)),
      colspan: e.colspan,
      rowspan: e.rowspan,
      "data-label": e.stackedHeading
    }, [
      e.stackedHeading ? (f(), h("div", _d, [
        B(r.$slots, "default")
      ])) : B(r.$slots, "default", { key: 1 })
    ], 10, wd));
  }
}), Vd = /* @__PURE__ */ I({
  __name: "BTfoot",
  props: {
    variant: null
  },
  setup(e) {
    const t = e, a = i(() => ({
      [`table-${t.variant}`]: t.variant !== void 0
    }));
    return (l, n) => (f(), h("tfoot", {
      role: "rowgroup",
      class: L(s(a))
    }, [
      B(l.$slots, "default")
    ], 2));
  }
}), Ad = ["scope", "colspan", "rowspan", "data-label"], Od = { key: 0 }, xd = /* @__PURE__ */ I({
  __name: "BTh",
  props: {
    colspan: null,
    rowspan: null,
    stackedHeading: null,
    stickyColumn: { default: !1 },
    variant: null
  },
  setup(e) {
    const t = e, a = u(o(t, "stickyColumn")), l = i(() => ({
      [`table-${t.variant}`]: t.variant !== void 0,
      "b-table-sticky-column": a.value,
      "table-b-table-default": a.value && t.variant === void 0
    })), n = i(() => t.colspan ? "colspan" : t.rowspan ? "rowspan" : "col");
    return (r, d) => (f(), h("th", {
      role: "columnheader",
      scope: s(n),
      class: L(s(l)),
      colspan: e.colspan,
      rowspan: e.rowspan,
      "data-label": e.stackedHeading
    }, [
      e.stackedHeading !== void 0 ? (f(), h("div", Od, [
        B(r.$slots, "default")
      ])) : B(r.$slots, "default", { key: 1 })
    ], 10, Ad));
  }
}), Pd = /* @__PURE__ */ I({
  __name: "BThead",
  props: {
    variant: null
  },
  setup(e) {
    const t = e, a = i(() => ({
      [`table-${t.variant}`]: t.variant !== void 0
    }));
    return (l, n) => (f(), h("thead", {
      role: "rowgroup",
      class: L(s(a))
    }, [
      B(l.$slots, "default")
    ], 2));
  }
}), Id = /* @__PURE__ */ I({
  __name: "BTr",
  props: {
    variant: null
  },
  setup(e) {
    const t = e, a = i(() => ({
      [`table-${t.variant}`]: t.variant !== void 0
    }));
    return (l, n) => (f(), h("tr", {
      role: "row",
      class: L(s(a))
    }, [
      B(l.$slots, "default")
    ], 2));
  }
}), Fd = /* @__PURE__ */ I({
  __name: "BTab",
  props: {
    id: null,
    title: null,
    active: { default: !1 },
    buttonId: { default: void 0 },
    disabled: { default: !1 },
    lazy: { default: void 0 },
    lazyOnce: { default: void 0 },
    noBody: { type: [Boolean, String], default: !1 },
    tag: { default: "div" },
    titleItemClass: null,
    titleLinkAttributes: { default: void 0 },
    titleLinkClass: null
  },
  setup(e) {
    const t = e, a = He(Cl), l = u(o(t, "active")), n = u(o(t, "disabled")), r = u(o(t, t.lazyOnce !== void 0 ? "lazyOnce" : "lazy")), d = K(!1), c = i(() => !!((a == null ? void 0 : a.lazy) || r.value)), v = i(() => t.lazyOnce !== void 0), m = i(() => l.value && !n.value), S = i(() => {
      const b = c.value && v.value && d.value;
      return m.value || !c.value || b;
    }), p = i(() => ({
      active: l.value,
      show: l.value,
      "card-body": (a == null ? void 0 : a.card) && t.noBody === !1
    }));
    return ce(S, (b) => {
      b && !d.value && (d.value = !0);
    }), (b, A) => (f(), N(Z(e.tag), {
      id: e.id,
      class: L(["tab-pane", s(p)]),
      role: "tabpanel",
      "aria-labelledby": "profile-tab"
    }, {
      default: M(() => [
        s(S) ? B(b.$slots, "default", { key: 0 }) : X("", !0)
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), Ed = ["id", "data-bs-target", "aria-controls", "aria-selected", "onClick"], Ld = /* @__PURE__ */ I({
  __name: "BTabs",
  props: {
    activeNavItemClass: null,
    activeTabClass: null,
    align: null,
    card: { default: !1 },
    contentClass: null,
    end: { default: !1 },
    fill: { default: !1 },
    id: null,
    justified: { default: !1 },
    lazy: { default: !1 },
    navClass: null,
    navWrapperClass: null,
    noFade: { default: !1 },
    noNavStyle: { default: !1 },
    pills: { default: !1 },
    small: { default: !1 },
    tag: { default: "div" },
    vertical: { default: !1 },
    modelValue: { default: -1 }
  },
  emits: ["update:modelValue", "activate-tab", "click"],
  setup(e, { emit: t }) {
    const a = e, l = Se(), n = u(o(a, "card")), r = u(o(a, "end")), d = u(o(a, "fill")), c = u(o(a, "justified")), v = u(o(a, "lazy")), m = u(o(a, "noFade")), S = u(o(a, "noNavStyle")), p = u(o(a, "pills")), b = u(o(a, "small")), A = u(o(a, "vertical")), w = K(a.modelValue), y = K(""), k = i({
      get: () => w.value,
      set: (C) => {
        w.value = C, g.value.length > 0 && C >= 0 && C < g.value.length ? y.value = g.value[C].buttonId : y.value = "", t("update:modelValue", C);
      }
    }), g = i(() => {
      let C = [];
      return l.default && (C = V(l).map((E, D) => {
        E.props || (E.props = {});
        const q = E.props["button-id"] || Re("tab"), G = E.props.id || Re(), se = k.value > -1 ? D === k.value : E.props.active === "", J = E.props["title-item-class"], ge = E.props["title-link-attributes"];
        return {
          buttonId: q,
          contentId: G,
          active: se,
          disabled: E.props.disabled === "" || E.props.disabled === !0,
          navItemClasses: [
            {
              active: se,
              disabled: E.props.disabled === "" || E.props.disabled === !0
            },
            se && a.activeNavItemClass ? a.activeNavItemClass : null,
            E.props["title-link-class"]
          ],
          tabClasses: [
            {
              fade: !m.value
            },
            se && a.activeTabClass ? a.activeTabClass : null
          ],
          target: `#${G}`,
          title: E.props.title,
          titleItemClass: J,
          titleLinkAttributes: ge,
          onClick: E.props.onClick,
          tab: E,
          tabComponent: () => V(l)[D]
        };
      })), C;
    }), $ = i(() => !((g == null ? void 0 : g.value) && g.value.length > 0)), F = i(() => ({
      "d-flex": A.value,
      "align-items-start": A.value
    })), P = dt(o(a, "align")), O = i(() => ({
      "nav-pills": p.value,
      "flex-column me-3": A.value,
      [P.value]: a.align !== void 0,
      "nav-fill": d.value,
      "card-header-tabs": n.value,
      "nav-justified": c.value,
      "nav-tabs": !S.value && !p.value,
      small: b.value
    })), _ = (C) => {
      let E = !1;
      if (C !== void 0 && C > -1 && C < g.value.length && !g.value[C].disabled && (k.value < 0 || g.value[C].buttonId !== y.value)) {
        const D = new De("activate-tab", { cancelable: !0 });
        t("activate-tab", C, k.value, D), D.defaultPrevented || (k.value = C, E = !0);
      }
      return !E && a.modelValue !== k.value && t("update:modelValue", k.value), E;
    }, x = (C, E) => {
      var D;
      _(E), E >= 0 && !g.value[E].disabled && ((D = g.value[E]) == null ? void 0 : D.onClick) && typeof g.value[E].onClick == "function" && g.value[E].onClick(C);
    }, V = (C) => !C || !C.default ? [] : C.default().reduce((E, D) => (typeof D.type == "symbol" ? E = E.concat(D.children) : E.push(D), E), []).filter((E) => {
      var D;
      return ((D = E.type) == null ? void 0 : D.__name) === "BTab";
    });
    return _(w.value), ce(
      () => a.modelValue,
      (C, E) => {
        if (C === E)
          return;
        if (C = Math.max(C, -1), E = Math.max(E, -1), g.value.length <= 0) {
          k.value = -1;
          return;
        }
        const D = C > E;
        let q = C;
        const G = g.value.length - 1;
        for (; q >= 0 && q <= G && g.value[q].disabled; )
          q += D ? 1 : -1;
        if (q < 0) {
          _(0);
          return;
        }
        if (q >= g.value.length) {
          _(g.value.length - 1);
          return;
        }
        _(q);
      }
    ), ce(g, () => {
      let C = g.value.map((E) => E.active && !E.disabled).lastIndexOf(!0);
      C < 0 && (k.value >= g.value.length ? C = g.value.map((E) => !E.disabled).lastIndexOf(!0) : g.value[k.value] && !g.value[k.value].disabled && (C = k.value)), C < 0 && (C = g.value.map((E) => !E.disabled).indexOf(!0)), g.value.forEach((E, D) => E.active = D === C), _(C);
    }), ke(() => {
      if (k.value < 0 && g.value.length > 0 && !g.value.some((C) => C.active)) {
        const C = g.value.map((E) => !E.disabled).indexOf(!0);
        _(C >= 0 ? C : -1);
      }
    }), at(Cl, {
      lazy: v.value,
      card: n.value
    }), (C, E) => (f(), N(Z(e.tag), {
      id: e.id,
      class: L(["tabs", s(F)])
    }, {
      default: M(() => [
        s(r) ? (f(), h("div", {
          key: 0,
          class: L(["tab-content", e.contentClass])
        }, [
          (f(!0), h(ie, null, me(s(g), ({ tabComponent: D, contentId: q, tabClasses: G, active: se }, J) => (f(), N(Z(D()), {
            id: q,
            key: J,
            class: L(G),
            active: se
          }, null, 8, ["id", "class", "active"]))), 128)),
          s($) ? (f(), h("div", {
            key: "bv-empty-tab",
            class: L(["tab-pane active", { "card-body": s(n) }])
          }, [
            B(C.$slots, "empty")
          ], 2)) : X("", !0)
        ], 2)) : X("", !0),
        j("div", {
          class: L([e.navWrapperClass, { "card-header": s(n), "ms-auto": e.vertical && s(r) }])
        }, [
          j("ul", {
            class: L(["nav", [s(O), e.navClass]]),
            role: "tablist"
          }, [
            B(C.$slots, "tabs-start"),
            (f(!0), h(ie, null, me(s(g), ({ tab: D, buttonId: q, contentId: G, navItemClasses: se, active: J, target: ge }, ae) => (f(), h("li", {
              key: ae,
              class: L(["nav-item", D.props["title-item-class"]]),
              role: "presentation"
            }, [
              j("button", Q({
                id: q,
                class: ["nav-link", se],
                "data-bs-toggle": "tab",
                "data-bs-target": ge,
                role: "tab",
                "aria-controls": G,
                "aria-selected": J
              }, D.props["title-link-attributes"], {
                onClick: Xe((he) => x(he, ae), ["stop", "prevent"])
              }), [
                D.children && D.children.title ? (f(), N(Z(D.children.title), { key: 0 })) : (f(), h(ie, { key: 1 }, [
                  ee(W(D.props.title), 1)
                ], 64))
              ], 16, Ed)
            ], 2))), 128)),
            B(C.$slots, "tabs-end")
          ], 2)
        ], 2),
        s(r) ? X("", !0) : (f(), h("div", {
          key: 1,
          class: L(["tab-content", e.contentClass])
        }, [
          (f(!0), h(ie, null, me(s(g), ({ tabComponent: D, contentId: q, tabClasses: G, active: se }, J) => (f(), N(Z(D()), {
            id: q,
            key: J,
            class: L(G),
            active: se
          }, null, 8, ["id", "class", "active"]))), 128)),
          s($) ? (f(), h("div", {
            key: "bv-empty-tab",
            class: L(["tab-pane active", { "card-body": s(n) }])
          }, [
            B(C.$slots, "empty")
          ], 2)) : X("", !0)
        ], 2))
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), zd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BAccordion: ss,
  BAccordionItem: $s,
  BAlert: Os,
  BAvatar: Fs,
  BAvatarGroup: Es,
  BBadge: Ns,
  BBreadcrumb: js,
  BBreadcrumbItem: Ql,
  BButton: et,
  BButtonGroup: qs,
  BButtonToolbar: Us,
  BCloseButton: nt,
  BCard: nn,
  BCardBody: an,
  BCardFooter: ln,
  BCardGroup: Ks,
  BCardHeader: Zl,
  BCardImg: _t,
  BCardSubtitle: tn,
  BCardText: Xs,
  BCardTitle: en,
  BCarousel: nr,
  BCarouselSlide: ur,
  BCol: st,
  BCollapse: Xl,
  BContainer: gr,
  BDropdown: un,
  BDropdownDivider: $r,
  BDropdownForm: _r,
  BDropdownGroup: Or,
  BDropdownHeader: Fr,
  BDropdownItem: Lr,
  BDropdownItemButton: Dr,
  BDropdownText: Rr,
  BForm: dn,
  BFormFloatingLabel: Ur,
  BFormInvalidFeedback: Jt,
  BFormRow: gt,
  BFormText: Qt,
  BFormValidFeedback: Yt,
  BFormCheckbox: cn,
  BFormCheckboxGroup: Zr,
  BFormGroup: ri,
  BFormInput: ci,
  BFormRadio: vn,
  BFormRadioGroup: gi,
  BFormSelect: $i,
  BFormSelectOption: ca,
  BFormSelectOptionGroup: mn,
  BFormTag: pn,
  BFormTags: Li,
  BFormTextarea: Hi,
  BImg: da,
  BInputGroup: Wi,
  BInputGroupAddon: fa,
  BInputGroupAppend: Ki,
  BInputGroupPrepend: Xi,
  BInputGroupText: bn,
  BLink: Ve,
  BListGroup: Ji,
  BListGroupItem: Qi,
  BModal: au,
  BNav: lu,
  BNavForm: nu,
  BNavItem: iu,
  BNavItemDropdown: du,
  BNavText: fu,
  BNavbar: vu,
  BNavbarBrand: bu,
  BNavbarNav: gu,
  BNavbarToggle: yu,
  BOffcanvas: Cu,
  BOverlay: gn,
  BPagination: Iu,
  BPlaceholder: xe,
  BPlaceholderButton: Bn,
  BPlaceholderCard: Fu,
  BPlaceholderTable: Eu,
  BPlaceholderWrapper: Lu,
  BPopover: Ru,
  BProgress: qu,
  BProgressBar: $n,
  BRow: Wu,
  BSkeleton: ht,
  BSkeletonIcon: Ku,
  BSkeletonTable: Qu,
  BSkeletonWrapper: Yu,
  BSpinner: Pt,
  BFormSpinButton: ld,
  BTable: Sd,
  BTableSimple: It,
  BTbody: Cd,
  BTd: Td,
  BTfoot: Vd,
  BTh: xd,
  BThead: Pd,
  BTr: Id,
  BTab: Fd,
  BTabs: Ld,
  BToastContainer: Xt,
  BTransition: lt,
  BToast: rn,
  BToaster: Xt,
  BToastPlugin: pr
}, Symbol.toStringTag, { value: "Module" })), Nd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  vBColorMode: rs,
  vBPopover: is,
  vBToggle: ua,
  vBTooltip: ms,
  vBVisible: bs
}, Symbol.toStringTag, { value: "Module" })), Rd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  useBreadcrumb: Dl,
  useColorMode: ns
}, Symbol.toStringTag, { value: "Module" })), jd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BvEvent: De,
  BvTriggerableEvent: na,
  BvCarouselEvent: dl
}, Symbol.toStringTag, { value: "Module" })), qd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), Gd = {
  install(e, t = {}) {
    Object.entries(zd).forEach(([a, l]) => {
      e.component(a, l);
    }), Object.entries(Nd).forEach(([a, l]) => {
      e.directive(a, l);
    }), ls(e);
  }
};
export {
  ss as BAccordion,
  $s as BAccordionItem,
  Os as BAlert,
  Fs as BAvatar,
  Es as BAvatarGroup,
  Ns as BBadge,
  js as BBreadcrumb,
  Ql as BBreadcrumbItem,
  et as BButton,
  qs as BButtonGroup,
  Us as BButtonToolbar,
  nn as BCard,
  an as BCardBody,
  ln as BCardFooter,
  Ks as BCardGroup,
  Zl as BCardHeader,
  _t as BCardImg,
  tn as BCardSubtitle,
  Xs as BCardText,
  en as BCardTitle,
  nr as BCarousel,
  ur as BCarouselSlide,
  nt as BCloseButton,
  st as BCol,
  Xl as BCollapse,
  gr as BContainer,
  un as BDropdown,
  $r as BDropdownDivider,
  _r as BDropdownForm,
  Or as BDropdownGroup,
  Fr as BDropdownHeader,
  Lr as BDropdownItem,
  Dr as BDropdownItemButton,
  Rr as BDropdownText,
  dn as BForm,
  cn as BFormCheckbox,
  Zr as BFormCheckboxGroup,
  Ur as BFormFloatingLabel,
  ri as BFormGroup,
  ci as BFormInput,
  Jt as BFormInvalidFeedback,
  vn as BFormRadio,
  gi as BFormRadioGroup,
  gt as BFormRow,
  $i as BFormSelect,
  ca as BFormSelectOption,
  mn as BFormSelectOptionGroup,
  ld as BFormSpinButton,
  pn as BFormTag,
  Li as BFormTags,
  Qt as BFormText,
  Hi as BFormTextarea,
  Yt as BFormValidFeedback,
  da as BImg,
  Wi as BInputGroup,
  fa as BInputGroupAddon,
  Ki as BInputGroupAppend,
  Xi as BInputGroupPrepend,
  bn as BInputGroupText,
  Ve as BLink,
  Ji as BListGroup,
  Qi as BListGroupItem,
  au as BModal,
  lu as BNav,
  nu as BNavForm,
  iu as BNavItem,
  du as BNavItemDropdown,
  fu as BNavText,
  vu as BNavbar,
  bu as BNavbarBrand,
  gu as BNavbarNav,
  yu as BNavbarToggle,
  Cu as BOffcanvas,
  gn as BOverlay,
  Iu as BPagination,
  xe as BPlaceholder,
  Bn as BPlaceholderButton,
  Fu as BPlaceholderCard,
  Eu as BPlaceholderTable,
  Lu as BPlaceholderWrapper,
  Ru as BPopover,
  qu as BProgress,
  $n as BProgressBar,
  Wu as BRow,
  ht as BSkeleton,
  Ku as BSkeletonIcon,
  Qu as BSkeletonTable,
  Yu as BSkeletonWrapper,
  Pt as BSpinner,
  Fd as BTab,
  Sd as BTable,
  It as BTableSimple,
  Ld as BTabs,
  Cd as BTbody,
  Td as BTd,
  Vd as BTfoot,
  xd as BTh,
  Pd as BThead,
  rn as BToast,
  Xt as BToastContainer,
  pr as BToastPlugin,
  Xt as BToaster,
  Id as BTr,
  lt as BTransition,
  Gd as BootstrapVueNext,
  dl as BvCarouselEvent,
  De as BvEvent,
  na as BvTriggerableEvent,
  zd as Components,
  Rd as Composables,
  Nd as Directives,
  qd as Types,
  jd as Utils,
  Gd as default,
  Dl as useBreadcrumb,
  ns as useColorMode,
  sn as useToast,
  rs as vBColorMode,
  is as vBPopover,
  ua as vBToggle,
  ms as vBTooltip,
  bs as vBVisible
};
//# sourceMappingURL=bootstrap-vue-next.es.js.map
